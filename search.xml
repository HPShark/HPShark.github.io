<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>ESXI的win10虚拟机跑hyper-v虚拟机无法上网解决方案</title>
      <link href="/2025/11/06/ESXIwin10%E8%99%9A%E6%8B%9F%E6%9C%BA%E8%B7%91hyper-v%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%97%A0%E6%B3%95%E4%B8%8A%E7%BD%91%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/"/>
      <url>/2025/11/06/ESXIwin10%E8%99%9A%E6%8B%9F%E6%9C%BA%E8%B7%91hyper-v%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%97%A0%E6%B3%95%E4%B8%8A%E7%BD%91%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/</url>
      
        <content type="html"><![CDATA[<hr><h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>物理机上跑了个ESXI6.7，运行了一个win10的虚拟机，但是虚拟机里头需要用hyper-v跑一个linux子系统，结果按网上的教程改桥接之后子系统死活上不了网，罪魁祸首就是ESXI默认不开启混杂模式，只要跟虚拟机的mac不一样的帧通通丢弃</p><h2 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h2><p><strong>VMware 的虚拟网卡</strong>（<code>Ethernet0</code> 的 MAC 以 <code>00:0C:29</code> 开头，这是 VMware 的 OUI），型号也正是 VMware 常用的 <em>Intel 82574L (e1000e)</em>。这说明你是在 <strong>VMware 里再跑 Hyper-V</strong>（嵌套虚拟化）。在这种架构下，把 Hyper-V 的“外网 vSwitch”绑到这块 VMware 虚拟网卡时，上层的 VMware vSwitch 默认会<strong>丢弃来自子虚拟机的 MAC</strong>（DHCP/ARP 都过不去），所以 Ubuntu 一接上“外网”就“断网/拿不到 IP”</p><p>嵌套场景里，内层 VM（Ubuntu）的帧会带 <strong>Ubuntu 自己的 MAC</strong> 从 Windows 这块“e1000e”虚拟网卡发出去；若上层 vSwitch 不允许“伪造/变化 MAC”或混杂接收，就会被过滤，导致 DHCP/ARP 都失败。</p><h2 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h2><p><strong>ESXi</strong>：把这台 Windows VM 所在<strong>端口组</strong>的安全策略改成<strong>Promiscuous Mode = Accept</strong>、<strong>MAC Address Changes = Accept</strong>、<strong>Forged Transmits = Accept</strong>。这些就是允许上层 vSwitch 接收/转发“不同源 MAC”的帧，是跑嵌套 Hyper-V/ESXi 的标准做法。</p><p><img src="https://blogimages.happyshark.cn/ESXI%E7%9A%84win10%E8%99%9A%E6%8B%9F%E6%9C%BA%E8%B7%91hyper-v%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%97%A0%E6%B3%95%E4%B8%8A%E7%BD%91%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/image-20251106163730795.png" alt="image-20251106163730795"></p><p>当然对于Workstation / Fusion：开启所连 VMnet 的<strong>混杂模式（Promiscuous/Allow VMs）</strong>，必要时（在 Linux 主机上）给 <code>/dev/vmnet*</code> 赋读写权限；有时还需在对应 VMX 里把 <code>ethernet0.noPromisc = &quot;FALSE&quot;</code></p><h2 id="检查"><a href="#检查" class="headerlink" title="检查"></a>检查</h2><p>完美！</p><p><img src="https://blogimages.happyshark.cn/ESXI%E7%9A%84win10%E8%99%9A%E6%8B%9F%E6%9C%BA%E8%B7%91hyper-v%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%97%A0%E6%B3%95%E4%B8%8A%E7%BD%91%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/image-20251106163905931.png" alt="image-20251106163905931"></p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 技术 </tag>
            
            <tag> 网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>不安全的实例</title>
      <link href="/2025/04/22/%E4%B8%8D%E5%AE%89%E5%85%A8%E7%9A%84%E5%AE%9E%E4%BE%8B-%E7%AC%94%E8%AE%B0/"/>
      <url>/2025/04/22/%E4%B8%8D%E5%AE%89%E5%85%A8%E7%9A%84%E5%AE%9E%E4%BE%8B-%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<hr><h2 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h2><p>卧村密码学报郭福春老师更新了一些针对签名的攻击方案demo，感觉很适合反复学习背诵全文（常见的密码方案攻击方法，加强挑刺能力hhh）pdf链接：<a href="https://documents.uow.edu.au/~fuchun/jow/052.pdf">documents.uow.edu.au/~fuchun/jow/052.pdf</a>下面是对pdf中例子的总结，如有疑问还请读者多指教~</p><h4 id="学习目标"><a href="#学习目标" class="headerlink" title="学习目标"></a>学习目标</h4><p>第1步：提出有效但不安全的方案。</p><p><strong>第2步：了解它们为什么不安全或知道如何攻击它们。</strong></p><p>第3步：具有修复不安全性的能力。</p><p>第4步：可以在修复安全方案后证明它们的安全性。</p><h2 id="Schemes"><a href="#Schemes" class="headerlink" title="Schemes"></a>Schemes</h2><h3 id="3-1-Scheme"><a href="#3-1-Scheme" class="headerlink" title="3.1 Scheme"></a>3.1 Scheme</h3><p>Let $(\mathbb{G},g,p)$ be the cyclic group and $H:{0,1}^{*}\to\mathbb{Z}_{p}$ be the cryptographic hash function that will be shared by all users.  </p><p><strong>KeyGen</strong>: The key generation algorithm chooses a random number $\alpha\in\mathbb{Z}<em>{p}$ , computes $g</em>{1}=g^{\alpha}$ , and returns a public/secret key pair $(p k,s k)$ as follows:  </p><script type="math/tex; mode=display">p k=g_{1},s k=\alpha.</script><p>给定循环群 $(G, g, p)$（$|G|=p$）和哈希函数 $H:{0,1}^* \to Z_p$ 。密钥生成选择随机私钥 $\alpha \in Z_p$，计算公钥元素 $g_1 = g^\alpha$。输出公钥 $pk = g_1$，私钥 $sk = \alpha$。</p><p><strong>Sign</strong>: The signing algorithm takes as input a message $m\in{0,1}^{*}$ and the secret key $s k$ . It computes the signature $\sigma_{m}$ on $m$ as  </p><script type="math/tex; mode=display">\sigma_{m}=\alpha+H(m)\mod p.</script><p>对于消息 $m$，签名者直接计算 $\sigma_m = \alpha + H(m) \pmod p$。<strong>(注意：</strong>此方案签名不使用随机数)**。</p><p><strong>Verify</strong>: The verification algorithm takes as input a message-signature pair $(m,\sigma_{m})$ and the public key $p k$ . It accepts the signature if  </p><script type="math/tex; mode=display">g^{\sigma_{m}}=g_{1}\cdot g^{H(m)}.</script><p>给定消息 $m$ 和签名 $\sigma_m$，验证者检查是否有 $g^{\sigma_m} \overset{?}{=} g_1 \cdot g^{H(m)}$ 。若等式成立则接受签名，否则拒绝。</p><h4 id="Question-1-Is-this-signature-scheme-secure-against-forgeability-in-the-key-only-attack"><a href="#Question-1-Is-this-signature-scheme-secure-against-forgeability-in-the-key-only-attack" class="headerlink" title="Question 1 Is this signature scheme secure against forgeability in the key-only attack?"></a><strong>Question 1</strong> Is this signature scheme secure against forgeability in the <strong>key-only attack</strong>?</h4><p><em>仅公钥攻击（Key-Only Attack）：</em> <strong>不安全。</strong>攻击者只有公钥 $g_1 = g^\alpha$。要伪造任意消息的有效签名，需要求解 $\alpha$ 使 $g_1 = g^\alpha$，但只要一一对消息就能反推出来$\alpha$。</p><h4 id="Question-2-Is-this-signature-scheme-secure-in-the-EUF-CMA-security-model"><a href="#Question-2-Is-this-signature-scheme-secure-in-the-EUF-CMA-security-model" class="headerlink" title="Question 2 Is this signature scheme secure in the EUF-CMA security model?"></a><strong>Question 2</strong> Is this signature scheme secure in the <strong>EUF-CMA</strong> security model?</h4><p><em>存在性不可伪造-选择消息攻击（EUF-CMA）：</em> <strong>不安全。</strong> 在允许查询签名的情况下，攻击者可以<strong>一条签名查询</strong>就完全攻破方案。具体地，在EUF-CMA安全性游戏中，攻击者先选定一个消息 $m<em>0$，查询其签名 $\sigma</em>{m<em>0} = \alpha + H(m_0)$。攻击者由此轻易解出私钥 $\alpha = \sigma</em>{m<em>0} - H(m_0)$（在模$p$下计算） 。得到私钥后，攻击者可自行为任何消息 $m^*$计算签名 $\sigma</em>{m^<em>} = \alpha + H(m^</em>)$，从而成功伪造。这种攻击利用了签名值直接暴露了私钥信息，违反了存在性不可伪造要求。因此本方案在 EUF-CMA 模型下显然不安全。</p><blockquote><p>EUF-CMA</p><p>这一模型中的CMA指Chosen Message Attack，即选择消息攻击，本质上与CPA其实是一样的，只不过在数字签名等算法中，用消息一词要比明文更加贴切。CMA和CPA都是形容敌手能自由地向算法提交输入并获得的相应输出这一能力。</p><p>EUF则是指存在性不可伪造，即 Existential UnForgeability，指的是对于消息认证、数字签名等算法而言，当敌手通过查询获得了 $q$ 个签名后， 他无法再获得第 $q + 1$ 个签名。这一Game的示意图如下所示。在查询阶段，敌手 $\mathcal{A}$ 可不断与一实现了签名Oracle的 $\mathcal{C}$ 交互，来获得所提交消息 $m$的签名 $\sigma$。在进行 $q$ 次交互后，敌手将输出一对 $(m^{<em>}, \sigma^{</em>} )$。这一Game的主要步骤为：</p><ol><li>Game中拥有一具有多项式资源的<strong>敌手 $\mathcal{A}$</strong> 和一个能自由调用签名算法oracle $E$ 的<strong>挑战者$\mathcal{C}$</strong>。</li><li>$\mathcal{C}$ 随机选取$\mathsf{sk} \stackrel{$}{\leftarrow} {0,1}^{n}$，作为签名算法的私钥</li><li>$\mathcal{A}$ 向 $\mathcal{C}$ 提交消息 $m$, $\mathcal{C}$ 得到 $m$ 对应的签名 $\sigma $</li><li>重复步骤 3 $q$ 次 (即敌手查询 $q$ 次不同消息的签名)</li><li>$\mathcal{A}$ 输出一对 $(m^{<em>}, \sigma^{</em>})$;</li><li>$\mathcal{C}$ 对  $\sigma^{*}$ 进行验证，并返回验证结果;</li></ol><p>若最后敌手输出的 $m^{<em>}$ 未曾被查询过，且 $\sigma^{</em>}$ 能通过验证，就可认为敌手挑战成功。这一结果即为“<strong>签名的伪造</strong>”，此处敌手的优势可写为：</p><script type="math/tex; mode=display">\mathrm{Adv}_{S}^{\mathrm{EUF-CMA}}(\mathcal{A}) = \mathrm{Pr}[\mathcal{A}\ \mathrm{forges}\ (m^{*}, \sigma^{*})]</script></blockquote><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>本方案实际上是一个<strong>不使用随机数的简单签名方案</strong>。与之类似的是<strong>BLS 签名方案</strong>（Boneh–Lynn–Shacham），BLS签名中，私钥也是离散对数$x$，公钥为$g^x$，但签名计算为 $\sigma = H(m)^x$（将消息哈希映射为群元素后再取幂）。BLS签名虽然同样<strong>无随机数</strong>，但伪造签名等价于求解 $H(m)^\alpha$ 的离散对数或计算 Diffie-Hellman 难题，在随机预言机模型下被证明满足 EUF-CMA 安全。而3.1方案仅将哈希值与私钥线性相加，<strong>签名直接泄露私钥</strong>，安全性显著弱于BLS等经典方案。</p><blockquote><p>BLS signatures</p><p><img src="https://blogimages.happyshark.cn/%E4%B8%8D%E5%AE%89%E5%85%A8%E7%9A%84%E5%AE%9E%E4%BE%8B/db8306738b25f9e4981c9c788a26c011.png" alt="img"></p></blockquote><h3 id="3-2-Scheme"><a href="#3-2-Scheme" class="headerlink" title="3.2 Scheme"></a>3.2 Scheme</h3><p>Let $(\mathbb{G},g,p)$ be the cyclic group and $H:{0,1}^{*}\to\mathbb{Z}_{p}$ be the cryptographic hash function that will be shared by all users.  </p><p><strong>KeyGen</strong>: The key generation algorithm chooses a random number $\alpha\in\mathbb{Z}<em>{p}$ , computes $g</em>{1}=g^{\alpha}$ , and returns a public/secret key pair $(p k,s k)$ as follows:  </p><script type="math/tex; mode=display">p k=g_{1},s k=\alpha.</script><p>同样取循环群 $(G, g, p)$和哈希函数 $H:{0,1}^* \to Z_p$。生成私钥 $\alpha \in Z_p$，计算 $g_1 = g^\alpha$，公钥 $pk = g_1$，私钥 $sk = \alpha$</p><p><strong>Sign</strong>: The signing algorithm takes as input a message $m\in{0,1}^{*}$ and the secret key $s k$ .  </p><ul><li>Choose a random $r\in\mathbb{Z}<em>{p}$ and compute $\sigma</em>{1}=g^{r}$ .   </li><li>Compute $\sigma_{2}=r+\alpha H(m)$ mod $p$ .   </li><li>Return the signature $\sigma<em>{m}=(\sigma</em>{1},\sigma_{2})$ .  </li></ul><p><strong>Sign：</strong> 对消息 $m$，签名者执行： (1) 选取随机 $r \in Z_p$，计算 $\sigma_1 = g^r$； (2) 计算 $\sigma_2 = r + \alpha \cdot H(m) \pmod p$ ； (3) 输出签名 $\sigma_m = (\sigma_1, \sigma_2)$。</p><p><strong>Verify</strong>: The verification algorithm takes as input a message-signature pair $(m,\sigma_{m})$ and the public key $p k$ . It accepts the signature if  </p><script type="math/tex; mode=display">g^{\sigma_{2}}=\sigma_{1}\cdot g_{1}^{H(m)}.</script><p><strong>Verify：</strong> 验证者对签名 $(\sigma_1,\sigma_2)$检查：是否 $g^{\sigma_2} \overset{?}{=} \sigma_1 \cdot g_1^{\,H(m)}$。展开验证式可见，左边$g^{\sigma_2} = g^{r+\alpha H(m)}$，右边$\sigma_1 \cdot g_1^{H(m)} = g^r \cdot (g^\alpha)^{H(m)} = g^{r+\alpha H(m)}$，二者相等则签名有效。</p><h4 id="Question-3-Is-this-signature-scheme-secure-against-forgeability-in-the-key-only-attack"><a href="#Question-3-Is-this-signature-scheme-secure-against-forgeability-in-the-key-only-attack" class="headerlink" title="Question 3 Is this signature scheme secure against forgeability in the key-only attack?"></a><strong>Question 3</strong> Is this signature scheme secure against forgeability in the <strong>key-only attack</strong>?</h4><p><em>仅公钥攻击：</em> <strong>不安全。</strong> 对任意消息 m，攻击者可自行挑选任意 <script type="math/tex">\sigma_2\in\mathbb Z_p</script>，并令  </p><script type="math/tex; mode=display">\sigma_1 \leftarrow g^{\sigma_2}\cdot (g_1)^{-H(m)}\</script><p>则验证式<script type="math/tex">g^{\sigma_2}\stackrel{?}{=}\sigma_1\cdot g_1^{H(m)}</script>恒成立，因此无需私钥即可伪造有效签名。这正是当“挑战值 <script type="math/tex">e</script>”<strong>不依赖承诺值</strong>（这里的 <script type="math/tex">\sigma_1</script>）时，Schnorr 结构出现的教科书级伪造。该攻击在公开资料中被明确指出：若把 <script type="math/tex">e</script> 设为 <script type="math/tex">H(m)</script> 而不含 <script type="math/tex">R=\sigma_1</script>，则“随意取 <script type="math/tex">s</script>，再设 <script type="math/tex">R=sG-cX</script>”即可伪造 <script type="math/tex">(R,s)</script>（把乘法群记号换成椭圆曲线加法即同一结论）。</p><h4 id="Question-4-Is-this-signature-scheme-secure-in-the-EUF-CMA-security-model"><a href="#Question-4-Is-this-signature-scheme-secure-in-the-EUF-CMA-security-model" class="headerlink" title="Question 4 Is this signature scheme secure in the EUF-CMA security model?"></a><strong>Question 4</strong> Is this signature scheme secure in the <strong>EUF-CMA security model</strong>?</h4><p><em>EUF-CMA 攻击：</em> <strong>不安全。</strong> 攻击者可以利用<strong>两条签名查询</strong>构造<strong>线性组合攻击</strong>来伪造新消息签名。设攻击者请求消息$m_1, m_2$的签名：</p><ul><li>得到$\sigma<em>{m_1}=(\sigma</em>{1,1}=g^{r<em>1},\,\sigma</em>{2,1}=r_1+\alpha H(m_1))$；</li><li>和$\sigma<em>{m_2}=(\sigma</em>{1,2}=g^{r<em>2},\,\sigma</em>{2,2}=r_2+\alpha H(m_2))$。</li></ul><p>攻击者选择欲伪造签名的目标消息$m^<em>$，令其哈希值 $H(m^</em>)$ 满足线性关系：$H(m^<em>) = c_1 \cdot H(m_1) + c_2 \cdot H(m_2) \pmod p$，其中 $c_1, c_2 \in Z_p$ 可由攻击者自行选定（因为哈希值是在模$p$下的数，攻击者可以通过解方程选取合适的系数，若视$H$为随机预言，可随机尝试消息直至找到满足关系的$H(m^</em>)$）。攻击者构造：</p><ul><li><script type="math/tex">\displaystyle \sigma^*_1 = (\sigma_{1,1})^{c_1} \cdot (\sigma_{1,2})^{c_2} = g^{c_1 r_1 + c_2 r_2}</script>，</li><li><script type="math/tex">\displaystyle \sigma^*_2 = c_1 \sigma_{2,1} + c_2 \sigma_{2,2} \pmod p = c_1(r_1+\alpha H(m_1)) + c_2(r_2+\alpha H(m_2))</script>。</li></ul><p>由于$H(m^<em>) = c_1 H(m_1)+c_2 H(m_2)$，可展开验证：<br>左边$g^{\sigma^</em>_2} = g^{c_1(r_1+\alpha H(m_1)) + c_2(r_2+\alpha H(m_2))} = g^{c_1 r_1 + c_2 r_2 + \alpha(c_1 H(m_1)+c_2 H(m_2))} = g^{c_1 r_1 + c_2 r_2 + \alpha H(m^<em>)}$。<br>右边$\sigma^</em>_1 \cdot g_1^{H(m^<em>)} = g^{c_1 r_1 + c_2 r_2} \cdot (g^\alpha)^{H(m^</em>)} = g^{c_1 r_1 + c_2 r_2 + \alpha H(m^<em>)}$。<br>二者完全相等，说明$(\sigma^</em>_1,\sigma^<em>_2)$通过了消息$m^</em>$的验证。因为攻击者<strong>不需要知道</strong>$\alpha$就成功伪造了签名，说明该方案在选择消息攻击下存在严重漏洞，不满足EUF-CMA安全性。这一攻击之所以可行，是因为签名验证公式对不同消息呈线性关系，可以被攻击者利用线性组合已有签名来生成新签名。</p><h4 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h4><p>本方案是典型的<strong>Schnorr签名方案不当修改</strong>。正确的 <strong>Schnorr 签名</strong> 使用 $H(R,m)$ 将随机承诺 $R=g^r$ 和消息一起哈希，使签名方程变为 $s = r + \alpha \cdot H(R,m)$。这样验证为 $g^s \overset{?}{=} R \cdot g_1^{H(R,m)}$，攻击者无法对不同签名进行线性组合，因为哈希将$R$绑定到了特定消息。Schnorr签名在随机预言机模型下被广泛认为是EUF-CMA安全的。而本方案的哈希$H(m)$<strong>缺少对随机承诺$\sigma_1$的依赖</strong>，导致多个签名间存在线性可组合性，被攻击者利用而伪造新签名。另外，<strong>ElGamal签名</strong>（及其DSA/ECDSA变种）与本方案结构类似，也采用随机数 $k$ 产生 $r=g^k$，但ElGamal签名的$\sigma_2$计算为 $k^{-1}(H(m) - \alpha \cdot \log_g r)$，非线性地结合了$\alpha$和$r$，确保安全性。本方案简单相加导致线性泄露，与经典安全签名方案相比漏洞明显。</p><blockquote><p>Schnorr签名</p><p><img src="https://blogimages.happyshark.cn/%E4%B8%8D%E5%AE%89%E5%85%A8%E7%9A%84%E5%AE%9E%E4%BE%8B/image-20250421162021742.png" alt="image-20250421162021742"></p><p>ElGamal签名</p><p><strong>密钥生成</strong>：</p><ol><li>选取一个足够大的素数p（十进制位数不低于160），以便于在 $\cdot Z_{p}$ 上求解离散对数问题是困难的。  </li><li>选取Z*的生成元g。  </li><li>随机选取整数 $\mathsf{d},0\leq d\leq p-2$ ，并计算 $y^{d}\equiv y\bmod p$ 。 </li></ol><p><strong>签名</strong>：A选取随机数k $\in Z_{p-1}$ ，并且 $g c d(k,p-1)=1$ ，对消息进行签名  </p><script type="math/tex; mode=display">s i g_{d}(m,k)=(r,s)</script><p>其中<script type="math/tex">r\equiv g^{k}\bmod p~,~s\equiv(m-d r)k^{-1}\bmod p-1~.</script></p><p><strong>验证</strong> ：如果 $\boldsymbol{g}^{m}\equiv\boldsymbol{y}^{r}\boldsymbol{r}^{s}$ mod $p$ ，那么验证成功，否则验证失败。这里验证成功的原理如下，首先我们有 <script type="math/tex">y^{r}r^{s}\equiv g^{d r}g^{k s}\equiv g^{d r+k s}</script> ，又因为  $ s\equiv(m-d r)k^{-1}{\bmod{p}}-1 $，所以 <script type="math/tex">k s\equiv m-d r{\bmod{p}}-1</script>，进而  <script type="math/tex">k s+d r=a*(p-1)+m</script>，所以  <script type="math/tex">g^{k s+d r}=g^{a*(p-1)+m}=(g^{p-1})^{a}*g^{m}</script>。所以根据费马定理，可得：</p><script type="math/tex; mode=display">g^{k s+d r}\equiv g^{m}{\bmod{p}}</script><p>ps： ElGamal常见攻击 ——完全破译攻击  </p><p><strong>攻击条件</strong>  ：</p><ul><li><p>p太小或无大素因子<br>如果p太小我们可以直接用大部小步算法分解，或者如果其无大的素因子，我们可以采用PohlingHellman算法计算离散对数即可进而求出私钥。  </p></li><li><p>随机数k复用<br>如果签名者复用了随机数k，那么攻击者就可以轻而易举地计算出私钥。具体的原理如下：假设目前有两个签名都是使用同一个随机数进行签名的。那么我们有 </p><script type="math/tex; mode=display">\begin{array}{c}{r\equiv g^{k}\bmod p}\\ {s_{1}\equiv(m_{1}-d r){k^{-1}}\bmod p-1}\\ {r\equiv g^{k}\bmod p}\\ {s_{2}\equiv(m_{2}-d r){k^{-1}}\bmod p-1}\end{array}</script><p>进而有 </p>>$$>\begin{array}{c}{{s_{1}k\equiv m_{1}-d r\bmod p-1}}\\ {{s_{2}k\equiv m_{2}-d r\bmod p-1}}\end{array}>$$></li></ul><p>两式相减  </p><script type="math/tex; mode=display">k(s_{1}-s_{2})\equiv m_{1}-m_{2}{\bmod{p}}-1</script><p>这里， $s<em>{1},s</em>{2},m<em>{1},m</em>{2},p-1$ 均已知，所以我们可以很容易算出 $k<em>{\circ}$ 当然，如果$g c d(s</em>{1}-s_{2},p-1)!=1$ 的话，可能会存在多个解，这时我们只需要多试一试。进而，我们可以根据s的计算方法得到私钥d，如下  </p><script type="math/tex; mode=display">d\equiv\frac{m-k s}{r}</script></blockquote><h3 id="3-3-Scheme"><a href="#3-3-Scheme" class="headerlink" title="3.3 Scheme"></a>3.3 Scheme</h3><p>Let $(\mathbb{G},g,p)$ be the cyclic group and $H:{0,1}^{*}\to\mathbb{Z}_{p}$ be the cryptographic hash function that will be shared by all users.  </p><p><strong>KeyGen</strong>: The key generation algorithm chooses random numbers $\alpha,\beta\in\mathbb{Z}<em>{p}$ , computes $g</em>{1}=g^{\alpha}$ , $g_{2}=g^{\beta}$ , and returns a public/secret key pair $(p k,s k)$ as follows:  </p><script type="math/tex; mode=display">p k=(g_{1},g_{2}),s k=(\alpha,\beta).</script><p>在循环群 $(G, g, p)$中取随机私钥 $\alpha,\beta \in Z_p$，计算 $g_1 = g^\alpha, g_2 = g^\beta$。公钥 $pk=(g_1,g_2)$，私钥 $sk=(\alpha,\beta)$。</p><p><strong>Sign</strong>: The signing algorithm takes as input a message $m\in{0,1}^{*}$ and the secret key $s k$ . It computes the signature $\sigma_{m}$ on $m$ as  </p><script type="math/tex; mode=display">\sigma_{m}=\alpha+H(m)\cdot\beta\mod p.</script><p>对消息 $m$，计算签名值为单个整数：$\displaystyle \sigma_m = \alpha + \beta \cdot H(m) \pmod p$。<em>(注：无随机数参与，签名为私钥线性组合)</em></p><p><strong>Verify</strong>: The verification algorithm takes as input a message-signature pair $(m,\sigma_{m})$ and the public key $p k$ . It accepts the signature if  </p><script type="math/tex; mode=display">g^{\sigma_{m}}=g_{1}\cdot g_{2}^{H(m)}.</script><p>验证者检查：$g^{\sigma_m} \overset{?}{=} g_1 \cdot g_2^{\,H(m)}$。代入$\sigma_m$展开，右边$g_1 \cdot g_2^{H(m)} = g^\alpha \cdot (g^\beta)^{H(m)} = g^{\alpha + \beta H(m)}$，恰好等于左边$g^{\sigma_m}$，因此签名正确性成立。</p><h4 id="Question-5-Is-this-signature-scheme-secure-against-forgeability-in-the-key-only-attack"><a href="#Question-5-Is-this-signature-scheme-secure-against-forgeability-in-the-key-only-attack" class="headerlink" title="Question 5 Is this signature scheme secure against forgeability in the key-only attack?"></a><strong>Question 5</strong> Is this signature scheme secure against forgeability in the <strong>key-only attack</strong>?</h4><p><em>仅公钥攻击：</em> <strong>不安全。</strong> 攻击者仅有公钥 $(g_1=g^\alpha, g_2=g^\beta)$。要直接伪造消息$m^<em>$的签名$\sigma^</em>=\alpha+\beta H(m^*)$，需要同时未知量$\alpha,\beta$的正确线性组合。这相当于从公钥中同时求出$\alpha,\beta$，属于计算Diffie-Hellman类似的困难问题（因为$g_1=g^\alpha, g_2=g^\beta$，已知这两个值单独求$\alpha,\beta$是离散对数难题，而同时求解更无捷径）。因此在无签名查询时，本方案应是不可伪造的。</p><h4 id="Question-6-Is-this-signature-scheme-secure-in-the-EUF-CMA-security-model"><a href="#Question-6-Is-this-signature-scheme-secure-in-the-EUF-CMA-security-model" class="headerlink" title="Question 6 Is this signature scheme secure in the EUF-CMA security model?"></a><strong>Question 6</strong> Is this signature scheme secure in the <strong>EUF-CMA security model</strong>?</h4><p><em>EUF-CMA 攻击：</em> <strong>不安全。</strong> 攻击者通过<strong>两条签名查询</strong>即可解出私钥，从而伪造任意签名。具体来说，攻击者请求消息$m_1, m_2$的签名：</p><ul><li>$\sigma_{m_1} = \alpha + \beta H(m_1)$</li><li>$\sigma_{m_2} = \alpha + \beta H(m_2)$</li></ul><p>视这两式为关于未知数$\alpha,\beta$的线性方程组。因为$H(m_1),H(m_2)$已知，攻击者从中可立即解出：</p><script type="math/tex; mode=display">\beta = \frac{\sigma_{m_1} - \sigma_{m_2}}{\,H(m_1) - H(m_2)\,} \pmod p,</script><script type="math/tex; mode=display">\alpha = \sigma_{m_1} - \beta H(m_1) \pmod p.</script><p>由此攻击者获得了完整私钥$(\alpha,\beta)$。剩下的游戏就简单了：攻击者可以用求得的$\alpha,\beta$为任何消息$m^<em>$计算$\sigma^</em>=\alpha + \beta H(m^<em>)$，从而成功伪造签名。可见，本方案<em>*在两次签名查询后即被完全攻破</em></em>，不满足EUF-CMA安全性。</p><h4 id="总结-2"><a href="#总结-2" class="headerlink" title="总结"></a>总结</h4><p>本方案使用了<strong>两个独立私钥的线性组合</strong>来签名，但<strong>缺乏随机盐值随机化</strong>。与之形成对比的是 <strong>Okamoto 签名方案</strong>（亦称双重秘密 Schnorr 签名）    。Okamoto签名中公钥为$(g_1^{\alpha}g_2^{\beta})$，签名者使用两个私钥并为每次签名选择<strong>两个随机数</strong>，产生二维的承诺值，再通过挑战哈希分别绑定这两个随机承诺，得到两个响应。这等价于对$\alpha,\beta$引入随机线性组合，避免了简单的线性泄露，从而是安全的。而本方案中<strong>没有任何随机化</strong>，导致不同签名之间私钥的线性组合固定不变，攻击者只需两条查询即可解方程求得秘密。另一经典方案 <strong>DSA</strong> 也可以看作是两部分（$r,s$）构成，其中$s$同时包含私钥和消息哈希，但因为有随机$k$的乘法逆模运算，方程并非简单可解。本方案的构造过于简单，安全性远不如上述经典方案。</p><blockquote><p>Okamoto 签名方案:</p><p>选择一个大素数 $p$ 和一个素数 $q$，使得 $q$ 整除 $p-1$，选择两个生成元 $g_1, g_2$ 属于 $\mathbb{Z}_p^<em>$，其阶均为 $q$，选择一个哈希函数 $H: {0, 1}^</em> \to \mathbb{Z}_q$。</p><p><strong>密钥生成</strong>：</p><ul><li>签名者选择两个随机整数作为私钥：$x_1, x_2 \in \mathbb{Z}_q$。</li><li>计算对应的公钥组件：$y_1 = g_1^{x_1} \pmod{p}$，$y_2 = g_2^{x_2} \pmod{p}$。</li><li>计算最终的公钥：$y = y_1 y_2 = g_1^{x_1} g_2^{x_2} \pmod{p}$。</li><li>私钥为 $(x_1, x_2)$。</li><li>公钥为 $(p, q, g_1, g_2, y)$。</li></ul><p><strong>签名</strong>：对于消息 $M$</p><ul><li>签名者选择两个随机整数：$k_1, k_2 \in \mathbb{Z}_q$。</li><li>计算承诺值 (commitment): $r = g_1^{k_1} g_2^{k_2} \pmod{p}$。</li><li>计算挑战值 (challenge): $e = H(M || r)$，其中 $||$ 表示串联。</li><li>计算响应值 (response):<ul><li>$s_1 = (k_1 + e x_1) \pmod{q}$</li><li>$s_2 = (k_2 + e x_2) \pmod{q}$</li></ul></li><li>签名为 $(r, s_1, s_2)$。</li></ul><p><strong>验证</strong>：验证签名 $(r, s_1, s_2)$ 对消息 $M$:</p><ul><li>验证者接收到消息 $M$ 和签名 $(r, s_1, s_2)$ 以及签名者的公钥 $(p, q, g_1, g_2, y)$。</li><li>计算挑战值：$e = H(M || r)$。</li><li>计算验证值：$v = g_1^{s_1} g_2^{s_2} y^{-e} \pmod{p}$。</li><li>如果 $v = r \pmod{p}$，则签名有效，否则无效。如果签名是有效生成的，那么：<br>$v = g_1^{s_1} g_2^{s_2} y^{-e} \pmod{p}$<br>$v = g_1^{k_1 + e x_1} g_2^{k_2 + e x_2} (g_1^{x_1} g_2^{x_2})^{-e} \pmod{p}$<br>$v = g_1^{k_1} g_1^{e x_1} g_2^{k_2} g_2^{e x_2} g_1^{-e x_1} g_2^{-e x_2} \pmod{p}$<br>$v = g_1^{k_1} g_2^{k_2} \pmod{p}$<br>$v = r \pmod{p}$</li></ul><p>数字签名算法 （DSA）： 选择一个大素数 $p$ (通常为 1024, 2048 或 3072 位)。选择一个素数 $q$ (通常为 160, 224 或 256 位)，使得 $q$ 整除 $p-1$。选择一个生成元 $g \in \mathbb{Z}_p^*$，其阶为 $q$。$g$ 的计算方法通常是选取任意 $h \in {2, \dots, p-2}$ 并计算 $g = h^{(p-1)/q} \pmod{p}$，直到 $g &gt; 1$。选择一个加密哈希函数 $H$ (例如 SHA-1, SHA-256 等)，其输出长度与 $q$ 的长度相匹配。</p><p><strong>密钥生成</strong>：</p><ul><li>签名者选择一个随机整数作为私钥：$x \in {1, \dots, q-1}$。</li><li>计算对应的公钥：$y = g^x \pmod{p}$。</li><li>私钥为 $x$。</li><li>公钥为 $(p, q, g, y)$。</li></ul><p><strong>签名</strong>：对于消息 $M$</p><ul><li>签名者选择一个随机整数作为每条消息的临时私钥 (或称 nonce): $k \in {1, \dots, q-1}$。此 $k$ 值必须对每条签名唯一且保密。</li><li>计算 $r = (g^k \pmod{p}) \pmod{q}$。如果 $r=0$，则重新选择 $k$。</li><li>计算消息的哈希值：$h = H(M)$。将哈希值转换为一个小于 $q$ 的整数 (通常取哈希值的最左边 $q$ 比特)。</li><li>计算 $s = (k^{-1} (h + x r)) \pmod{q}$。这里的 $k^{-1}$ 是 $k$ 对 $q$ 的模逆。如果 $s=0$，则重新选择 $k$。</li><li>签名为 $(r, s)$。</li></ul><p><strong>验证</strong>：对于签名 $(r, s)$ 和消息 $M$:</p><ul><li><p>验证者接收到消息 $M$ 和签名 $(r, s)$ 以及签名者的公钥 $(p, q, g, y)$。</p></li><li><p>检查是否 $1 \le r &lt; q$ 且 $1 \le s &lt; q$。如果不是，则签名无效。</p></li><li><p>计算消息的哈希值：$h = H(M)$。将哈希值转换为一个小于 $q$ 的整数。</p></li><li><p>计算 $w = s^{-1} \pmod{q}$。这里的 $s^{-1}$ 是 $s$ 对 $q$ 的模逆。</p></li><li><p>计算 $u_1 = (h w) \pmod{q}$。</p></li><li><p>计算 $u_2 = (r w) \pmod{q}$。</p></li><li><p>计算验证值：$v = ((g^{u_1} y^{u_2}) \pmod{p}) \pmod{q}$。</p></li><li><p>如果 $v = r$，则签名有效，否则无效。如果签名是有效生成的，那么：</p><p>$s = (k^{-1} (h + x r)) \pmod{q}$<br>$ks \equiv h + xr \pmod{q}$<br>$h \equiv ks - xr \pmod{q}$<br>$h w \equiv ksw - xrw \pmod{q}$<br>由于 $w = s^{-1} \pmod{q}$，$sw \equiv 1 \pmod{q}$。<br>$u_1 \equiv k - xr w \pmod{q}$<br>$u_1 \equiv k - x u_2 \pmod{q}$<br>根据指数的模运算性质：<br>$g^{u_1} y^{u_2} \equiv g^{k - x u_2} y^{u_2} \pmod{p}$<br>$g^{u_1} y^{u_2} \equiv g^k g^{-x u_2} (g^x)^{u_2} \pmod{p}$<br>$g^{u_1} y^{u_2} \equiv g^k g^{-x u_2} g^{x u_2} \pmod{p}$<br>$g^{u_1} y^{u_2} \equiv g^k \pmod{p}$<br>所以，$v = (g^{u_1} y^{u_2} \pmod{p}) \pmod{q} = (g^k \pmod{p}) \pmod{q} = r$。</p></li></ul></blockquote><h3 id="3-4-Scheme"><a href="#3-4-Scheme" class="headerlink" title="3.4 Scheme"></a>3.4 Scheme</h3><p>Let $(\mathbb{G},g,p)$ be the cyclic group and $H:{0,1}^{*}\to\mathbb{Z}_{p}$ be the cryptographic hash function that will be shared by all users.  </p><p><strong>KeyGen</strong>: The key generation algorithm chooses random numbers $\alpha,\beta\in\mathbb{Z}<em>{p}$ , computes $g</em>{1}=g^{\alpha}$ , $g_{2}=g^{\beta}$ , and returns a public/secret key pair $(p k,s k)$ as follows:  </p><script type="math/tex; mode=display">p k=(g_{1},g_{2}),s k=(\alpha,\beta).</script><p>在循环群 $(G, g, p)$中，选取私钥 $\alpha,\beta \in Z_p$，计算 $g_1 = g^\alpha, g_2 = g^\beta$，输出公钥 $pk=(g_1,g_2)$，私钥 $sk=(\alpha,\beta)$  。</p><p><strong>Sign</strong>: The signing algorithm takes as input a message $m\in{0,1}^{*}$ and the secret key $s k$ .  </p><ul><li>Choose a random $r\in\mathbb{Z}<em>{p}$ and compute $\sigma</em>{1}=g^{r}$ .   </li><li>Compute $\sigma_2 = \frac{\alpha + r}{\,\beta + H(m)\,} \pmod p$.   </li><li>Return the signature $\sigma<em>{m}=(\sigma</em>{1},\sigma_{2})$ .  </li></ul><p>对消息 $m$： (1) 选择随机数 $r \in Z_p$，计算 $\sigma_1 = g^r$； (2) 计算 $\sigma_2 = \frac{\alpha + r}{\,\beta + H(m)\,} \pmod p$  ；(3) 输出签名 $\sigma_m = (\sigma_1,\sigma_2)$。  <em>（注：上述 $\sigma_2$ 公式根据原文推导得到，应为将$\alpha+r$乘以$(\beta+H(m))^{-1}$取模$p$  。）</em></p><p><strong>Verify</strong>: The verification algorithm takes as input a message-signature pair $(m,\sigma_{m})$ and the public key $p k$ . It accepts the signature if  </p><script type="math/tex; mode=display">\Bigl(g_{2}g^{H(m)}\Bigr)^{\sigma_{2}}=g_{1}\cdot\sigma_{1}.</script><p>验证者计算校验：$(g_2 \cdot g^{H(m)})^{\sigma_2} \overset{?}{=} g_1 \cdot \sigma_1$  。将$\sigma_2$代入左侧，得到：</p><script type="math/tex; mode=display">\big(g^\beta \cdot g^{H(m)}\big)^{\sigma_2} = g^{(\beta + H(m))\sigma_2} \stackrel{!}{=} g_1 \cdot \sigma_1 = g^\alpha \cdot g^r = g^{\alpha+r}.</script><p>由于签名者构造$\sigma_2$时满足$(\beta+H(m))\sigma_2 = \alpha+r$，因此验证等式成立，签名有效。</p><h4 id="Question-7-Is-this-signature-scheme-secure-against-forgeability-in-the-key-only-attack"><a href="#Question-7-Is-this-signature-scheme-secure-against-forgeability-in-the-key-only-attack" class="headerlink" title="Question 7 Is this signature scheme secure against forgeability in the key-only attack?"></a>Question 7 Is this signature scheme secure against forgeability in the key-only attack?</h4><p><em>仅公钥攻击：</em> <strong>如果不伪造$(\sigma_1,\sigma_2)$：安全。</strong> 攻击者仅知公钥 $g_1=g^\alpha, g_2=g^\beta$。想要直接伪造，需要找到$(\sigma_1,\sigma_2)$使得 $(g_2 g^{H(m^<em>)})^{\sigma_2} = g_1 \cdot \sigma_1$。这要求$(\beta + H(m^</em>))\sigma_2 = \alpha + r$ 且 $\sigma_1=g^r$ 同时成立，相当复杂。攻击者即使猜测$r$，仍需满足 $\sigma_2 = (\alpha+r)/(\beta+H(m^<em>))$，但$\alpha,\beta$未知难以满足。此外，$\sigma_1=g^r$提供了一定的<em>*随机遮蔽</em></em>，进一步增加了直接伪造的难度。因此在无签名查询时，本方案应无法直接伪造。</p><p> <strong>如果伪造$(\sigma_1,\sigma_2)$：不安全。</strong> 给定公钥 $(g_1,g_2)$ 与消息 $m$，攻击者可执行：</p><ol><li>取随机 $\sigma_2\stackrel{$}{\leftarrow}\mathbb Z_p$。  </li><li>计算    <script type="math/tex">\sigma_1 \;=\;(g_2\cdot g^{H(m)})^{\sigma_2}\cdot g_1^{-1}.</script>该幂与乘法均在公开群中完成，无须离散对数。  </li><li>输出 $\sigma=(\sigma_1,\sigma_2)$。</li></ol><p>验证方程立刻成立：<script type="math/tex">g_2g^{H(m)})^{\sigma_2}=g_1\sigma_1</script><br>因为右端就是左端乘以 $g_1^{-1}\,g_1$。攻击者完全不需要私钥 $(\alpha,\beta)$ 或随机值 $r$。<a href="https://www.geeksforgeeks.org/types-of-digital-signature-attacks/?utm_source=chatgpt.com">GeeksforGeeks</a> <a href="https://www.cs.purdue.edu/homes/ninghui/courses/Fall05/lectures/355_Fall05_lect30.pdf?utm_source=chatgpt.com">cs.purdue.edu</a>  </p><p>类似伪造：</p><ul><li><strong>课本 RSA 签名</strong>：任选 $s\leftarrow\mathbb Z_n^{!*}$，设 $m=s^e\bmod n$，则 $(m,s)$ 为有效签名——与上式同样“先选 σ₂，再配 σ₁”。<a href="https://crypto.stackexchange.com/questions/20085/which-attacks-are-possible-against-raw-textbook-rsa?utm_source=chatgpt.com">Cryptography Stack Exchange</a>  </li><li><strong>原版 ElGamal 签名（无哈希）</strong>：可取 $e,v$ 两参数伪造 $(r,s)$ 使验证等式成立。<a href="https://en.wikipedia.org/wiki/ElGamal_signature_scheme?utm_source=chatgpt.com">Wikipedia</a>  </li></ul><p>这些例子都说明：若验证等式呈现出“可任意选未知数、再解另一个未知数”的结构，往往会导致 KOA 伪造。</p><h4 id="Question-8-Is-this-signature-scheme-secure-in-the-EUF-CMA-security-model"><a href="#Question-8-Is-this-signature-scheme-secure-in-the-EUF-CMA-security-model" class="headerlink" title="Question 8 Is this signature scheme secure in the EUF-CMA security model?"></a>Question 8 Is this signature scheme secure in the EUF-CMA security model?</h4><p><em>EUF-CMA 攻击：</em> <strong>不安全。</strong> 攻击者可以通过<strong>多次签名查询</strong>逐步求解出私钥或构造等式来伪造签名。虽然比起3.3方案，本方案在签名中加入了随机数$r$，但仍存在线性关系可被利用：每个签名满足 $(\beta+H(m))\sigma_2 - r = \alpha$（等价于$(\beta+H(m))\sigma_2 = \alpha + r$）。不同消息的签名提供了多条这样的等式：</p><script type="math/tex; mode=display">(\beta+H(m_1))\sigma_{2,1} - r_1 = \alpha,</script><script type="math/tex; mode=display">(\beta+H(m_2))\sigma_{2,2} - r_2 = \alpha.</script><p>攻击者知道$\sigma<em>{2,1},\sigma</em>{2,2},H(m<em>1),H(m_2)$以及$\sigma</em>{1,1}=g^{r<em>1}, \sigma</em>{1,2}=g^{r_2}$。虽然单独未知$r_1,r_2$，但两式右侧同为$\alpha$，攻击者可消去$\alpha$得到：</p><script type="math/tex; mode=display">(\beta+H(m_1))\sigma_{2,1} - (\beta+H(m_2))\sigma_{2,2} = r_1 - r_2.</script><p>右边$r<em>1-r_2 = \log_g(\sigma</em>{1,1}/\sigma_{1,2})$，攻击者若能计算离散对数就可解出一个关于$\beta$的线性方程。然而离散对数计算困难，因此需要更多查询累积信息。不过，由于攻击者可以选择消息，多次查询可形成多元线性方程组求解$\alpha,\beta$。一旦取得足够多的签名（例如通过选取不同$H(m)$值形成线性独立方程），攻击者即可解出私钥 $\alpha,\beta$，进而伪造任意签名。因此，本方案并未通过单一随机数完全阻止线性攻击，在EUF-CMA下仍不安全。</p><h4 id="总结-3"><a href="#总结-3" class="headerlink" title="总结"></a>总结</h4><p>本方案可看作是对双秘密密钥签名的一次尝试改进，引入了随机数和分母$(\beta+H(m))$以提高安全性，但效果不佳。经典的 <strong>Okamoto签名方案</strong> 提供了一种安全构造思路：它使用两个随机数分别对应两个私钥部分，并采用哈希挑战将随机承诺与消息绑定，从而生成两个响应。Okamoto签名的验证涉及同时检验两部分方程，保证了安全性。而3.4方案仅用<strong>一个随机数</strong>尝试掩饰两个私钥的组合，其验证等式仍然是一元的线性关系，安全性不足。可以说，3.4方案是一个未充分随机化的双秘钥签名，对比Okamoto等安全方案，它缺少足够的独立随机度，因而被攻击者利用签名间关系破解。</p><h3 id="3-5-Scheme"><a href="#3-5-Scheme" class="headerlink" title="3.5 Scheme"></a>3.5 Scheme</h3><p>Let $(\mathbb{G},g,p)$ be the cyclic group and $H:{0,1}^{*}\to\mathbb{Z}_{p}$ be the cryptographic hash function that will be shared by all users.  </p><p><strong>KeyGen</strong>: The key generation algorithm chooses a random number $\alpha\in\mathbb{Z}<em>{p}$ , computes $g</em>{1}=g^{\alpha}$ , and returns a public/secret key pair $(p k,s k)$ as follows:  </p><script type="math/tex; mode=display">p k=g_{1},s k=\alpha.</script><p>在循环群 $(G, g, p)$下，选择私钥 $\alpha \in Z_p$，计算公钥 $g_1 = g^\alpha$，输出 $pk = g_1$，$sk = \alpha$  。</p><p><strong>Sign</strong>: The signing algorithm takes as input a message $m\in{0,1}^{*}$ and the secret key $s k$ .  </p><ul><li>Choose random $r<em>{1},r</em>{2},t\in\mathbb{Z}<em>{p}$ and compute $\sigma</em>{1}=g^{r<em>{1}},\sigma</em>{2}=g^{r<em>{2}},\sigma</em>{3}=g^{t}.$ . </li><li>Compute $\displaystyle \sigma_4 = (r_1 \cdot H(m, pk, 1) + r_2 \cdot H(m, pk, 2)) / (\alpha + t \cdot H(\sigma_3)) \pmod p$</li><li>Return the signature $\sigma<em>{m}=(\sigma</em>{1},\sigma<em>{2},\sigma</em>{3},\sigma_{4})$ .  </li></ul><p>对消息 $m$ 和公钥 $pk$，签名者执行以下步骤：</p><ol><li>选择随机 $r_1, r_2, t \in Z_p$，计算 $\sigma_1 = g^{r_1},\; \sigma_2 = g^{r_2},\; \sigma_3 = g^t$  。</li><li>计算 $\displaystyle \sigma_4 = (r_1 \cdot H(m, pk, 1) + r_2 \cdot H(m, pk, 2)) / (\alpha + t \cdot H(\sigma_3)) \pmod p$  。</li><li>输出签名 $\sigma_m = (\sigma_1,\; \sigma_2,\; \sigma_3,\; \sigma_4)$。</li></ol><p><strong>Verify</strong>: The verification algorithm takes as input a message-signature pair $(m,\sigma_{m})$ and the public key $p k$ . It accepts the signature if  </p><script type="math/tex; mode=display">\sigma_{1}^{H(m,p k,1)}\cdot\sigma_{2}^{H(m,p k,2)}=(g_{1}\sigma_{3}^{H(\sigma_{3})})^{\sigma_{4}}.</script><p>验证者给定 $(m, \sigma_m)$ 和公钥，计算并验证：<script type="math/tex">\sigma_1^{\,H(m,pk,1)} \cdot \sigma_2^{\,H(m,pk,2)} \ \overset{?}{=} \ \Big(g_1 \cdot \sigma_3^{\,H(\sigma_3)}\Big)^{\sigma_4}.</script> </p><h4 id="Question-9-Is-this-signature-scheme-secure-against-forgeability-in-the-key-only-attack"><a href="#Question-9-Is-this-signature-scheme-secure-against-forgeability-in-the-key-only-attack" class="headerlink" title="Question 9 Is this signature scheme secure against forgeability in the key-only attack?"></a>Question 9 Is this signature scheme secure against forgeability in the key-only attack?</h4><p><em>仅公钥攻击：</em> <strong>不安全。</strong> 在只知道 $pk = g1 = g^α$ 的情况下，为任意消息 $m<em>$ 计算签名 $σ</em>=(σ1,σ2,σ3,σ4)$，使得下列等式成立：</p><script type="math/tex; mode=display">\sigma_1^{H(m,pk,1)}\;\sigma_2^{H(m,pk,2)}=\bigl(g_1\,\sigma_3^{H(\sigma_3)}\bigr)^{\sigma_4}\,.</script><ol><li>置 $σ1 = 1_G$, $σ2 = 1_G$（群单位）。  </li><li>随意选 $t←ℤ_p$，令 $σ3 = g^t$。  </li><li>置 $σ4 = 0$。  <ul><li>(1) 右端变为单位元，因为任何元素的 0 次幂皆为 1_G。  </li><li>左端同样是单位元，因为 $σ1 = σ2 = 1_G$。  </li></ul></li><li>(1) 恒成立，不依赖 $α$ 或 $m*$。  </li></ol><ul><li><strong>无需</strong>私钥、无需调用 Sign 算法；整个过程对消息 $m^{\star} $完全独立，因此可对<strong>任意</strong>消息重用。 <a href="https://eitca.org/cybersecurity/eitc-is-acc-advanced-classical-cryptography/digital-signatures/elgamal-digital-signature/examination-review-elgamal-digital-signature/what-is-the-existential-forgery-attack-against-rsa-digital-signatures-and-how-does-it-exploit-the-construction-of-the-rsa-digital-signature-scheme/?utm_source=chatgpt.com">eitca.org</a> <a href="https://www.packetlabs.net/posts/cryptanalysis-attack-classifications/?utm_source=chatgpt.com">Packetlabs</a>  </li><li>这种“零指数”手法在早期教材方案中屡见不鲜，被称作<strong>zero‑exponent forgery</strong>。 <a href="https://csrc.nist.gov/files/pubs/conference/2000/10/19/proceedings-of-the-23rd-nissc-2000/final/docs/papers/905slide.pdf?utm_source=chatgpt.com">csrc.nist.gov</a> <a href="https://crypto.stanford.edu/~dabo/pubs/papers/groupsigs.pdf?utm_source=chatgpt.com">crypto.stanford.edu</a>  </li></ul><div class="table-container"><table><thead><tr><th>方案</th><th>是否抗 key‑only</th><th>关键机制</th></tr></thead><tbody><tr><td><strong>Scheme 3.5</strong></td><td>✖ 易被零指数伪造</td><td>$\sigma_4$ 可令 0，并且 $\sigma_1,\sigma_2$可取单位元</td></tr><tr><td><strong>Schnorr</strong> 签名</td><td>✔ EUF‑CMA 证明</td><td>将挑战 (e=H(m,R)) 固定进指数，禁止 0 指数 <a href="https://crypto.stackexchange.com/questions/48616/prove-the-security-of-schnorrs-signature-scheme?utm_source=chatgpt.com">Cryptography Stack Exchange</a></td></tr><tr><td><strong>紧致 DL‑基签名</strong> (e.g., Boneh–Boyen)</td><td>✔ EUF‑KOA 起步</td><td>将消息、随机数和私钥紧耦合，避免独立调节 <a href="https://www.sciencedirect.com/science/article/pii/S0304397521004205?utm_source=chatgpt.com">ScienceDirect</a></td></tr></tbody></table></div><p>这些安全方案都会把随机挑战、消息与私钥<strong>耦合进同一指数</strong>，从而杜绝“幂 = 0”这类捷径。  设计安全签名的经验法则：  </p><ol><li><strong>禁止零指数</strong>——将哈希挑战嵌入指数且强制非零；  </li><li><strong>绑定消息与随机数</strong>——让验证式每一项都依赖 (H(m,\dots))；  </li></ol><h4 id="Question-10-Is-this-signature-scheme-secure-in-the-EUF-CMA-security-model"><a href="#Question-10-Is-this-signature-scheme-secure-in-the-EUF-CMA-security-model" class="headerlink" title="Question 10 Is this signature scheme secure in the EUF-CMA security model?"></a>Question 10 Is this signature scheme secure in the EUF-CMA security model?</h4><p><em>EUF-CMA 攻击：</em> <strong>不安全。</strong> </p><h4 id="总结-4"><a href="#总结-4" class="headerlink" title="总结"></a>总结</h4><p>攻击者在<strong>零交互、零计算量</strong>的情况下即可输出合法签名，显然破坏了<strong>存在性不可伪造性‑仅公钥攻击 (EUF‑KOA)</strong> 的最低要求。</p>]]></content>
      
      
      <categories>
          
          <category> 密码学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 安全证明 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>链上链下融合协议的安全证明方式分析</title>
      <link href="/2025/01/23/%E9%93%BE%E4%B8%8A%E9%93%BE%E4%B8%8B%E8%9E%8D%E5%90%88%E5%8D%8F%E8%AE%AE%E7%9A%84%E5%AE%89%E5%85%A8%E8%AF%81%E6%98%8E%E6%96%B9%E5%BC%8F%E5%88%86%E6%9E%90/"/>
      <url>/2025/01/23/%E9%93%BE%E4%B8%8A%E9%93%BE%E4%B8%8B%E8%9E%8D%E5%90%88%E5%8D%8F%E8%AE%AE%E7%9A%84%E5%AE%89%E5%85%A8%E8%AF%81%E6%98%8E%E6%96%B9%E5%BC%8F%E5%88%86%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<hr><p>在区块链应用的迅猛发展背景下，链上与链下融合协议的安全性日益受到关注。可证明安全理论为我们提供了一套系统的方法来分析协议在不同模型下的安全保证，从而在设计阶段就可针对潜在威胁进行防御。本报告针对“链上链下融合协议的安全证明方式”展开，首先介绍可证明安全理论的基本概念与发展背景，然后总结常见的安全协议规约与证明方法，接着聚焦于链上协议在威胁模型与安全防护方面的关键思路，以期为相关协议设计与安全分析提供参考。</p><h1 id="可证明安全理论概述"><a href="#可证明安全理论概述" class="headerlink" title="可证明安全理论概述"></a>可证明安全理论概述</h1><h2 id="可证明安全的定义与背景"><a href="#可证明安全的定义与背景" class="headerlink" title="可证明安全的定义与背景"></a>可证明安全的定义与背景</h2><h3 id="可证明安全的定义"><a href="#可证明安全的定义" class="headerlink" title="可证明安全的定义"></a>可证明安全的定义</h3><p>“可证明安全（Provable Security）”通常指的是在严格的数学假设或模型下，通过形式化的推导或归约论证来确保密码学协议或机制具备一定的安全性保证[1]。与经验性或启发式的安全分析不同，可证明安全要求将协议或算法的安全性归约到一个或多个被普遍接受的难题或复杂性假设之上。例如，若某协议的安全能被归约到离散对数问题（Discrete Logarithm Problem）不可求解这一假设，那么在该假设成立的前提下，我们就能证明协议满足指定的安全属性[2]。</p><h3 id="可证明安全的发展背景"><a href="#可证明安全的发展背景" class="headerlink" title="可证明安全的发展背景"></a>可证明安全的发展背景</h3><p><strong>密码学理论的演进</strong>：从最初的对称加密（如DES、AES）到公钥密码（如RSA、ECC），学术界逐渐意识到仅凭直觉或简单测试无法证明某一机制的安全性。为了解决“如何在形式化层面论证安全性”的问题，诞生了可证明安全理论[3]。</p><p><strong>关键的研究里程碑</strong>：1976年Diffie和Hellman提出公钥加密思想[4]，拉开了现代密码学的序幕；1984年ElGamal提出基于离散对数难题的公钥加密方案[5]；1985年RSA被形式化地纳入可证明安全研究的范畴；随后Goldwasser和Micali等人将复杂性理论与密码学相结合，为可证明安全奠定了坚实基础[6]。</p><p><strong>从传统到现代</strong>：进入21世纪后，可证明安全研究快速拓展到多方安全计算、同态加密、零知识证明等领域[7]，并在区块链应用中进一步得到关注和实践。</p><h3 id="研究意义"><a href="#研究意义" class="headerlink" title="研究意义"></a>研究意义</h3><p>可证明安全方法帮助设计者在协议部署前就能量化其在特定威胁模型下的风险，从而降低实际应用中的安全漏洞或隐患[8]。这对于构建信任基础薄弱、参与方众多的分布式系统尤其重要。在金融、物联网、区块链等高风险领域，可证明安全已经成为协议设计和审计的“标准配置”[9]。</p><h2 id="常见的可证明安全方法"><a href="#常见的可证明安全方法" class="headerlink" title="常见的可证明安全方法"></a>常见的可证明安全方法</h2><p>卧龙岗大学的郭福春老师[10]在Bilibili网站上开设密码学课程[11]，详细介绍了安全规约的方法，本节以郭老师的内容为基础，对常见的可证明安全的方法做一个总结。</p><h3 id="基于复杂性假设的可证明安全"><a href="#基于复杂性假设的可证明安全" class="headerlink" title="基于复杂性假设的可证明安全"></a>基于复杂性假设的可证明安全</h3><p>常见的复杂性假设包括如大数分解难题、离散对数难题、椭圆曲线离散对数难题等[2]，其安全规约思路和特点如下：</p><p>安全归约思路：如果能够证明“破解协议”比“解决某著名难题”更难或同等困难，则可在相应假设有效的前提下认定协议安全[12]。</p><p>特点：此方法直观易懂，且在已有的复杂性理论及大量实验验证的支持下，能为协议安全性提供较高说服力。</p><h3 id="基于随机预言机模型（Random-Oracle-Model，ROM）"><a href="#基于随机预言机模型（Random-Oracle-Model，ROM）" class="headerlink" title="基于随机预言机模型（Random Oracle Model，ROM）"></a>基于随机预言机模型（Random Oracle Model，ROM）</h3><p><strong>定义</strong>：将哈希函数抽象为真正的随机函数，攻击者无法对其进行结构性分析[13]。</p><p><strong>典型应用</strong>：Fiat-Shamir变换、许多签名方案和密钥交换协议均在随机预言机模型下得到简单且有效的安全证明[14]。</p><p><strong>局限性</strong>：随机预言机模型存在与实际哈希函数并不完全相符的风险；在标准模型中，随机预言机是假设的理想组件，并不能直接映射到现实世界[15]。</p><h3 id="基于标准模型（Standard-Model）的可证明安全"><a href="#基于标准模型（Standard-Model）的可证明安全" class="headerlink" title="基于标准模型（Standard Model）的可证明安全"></a>基于标准模型（Standard Model）的可证明安全</h3><p><strong>定义</strong>：不使用随机预言机等理想化假设，而是直接基于复杂性理论进行证明[12]。</p><p><strong>优点</strong>：证明结果更为严格，通常被视为“最能贴近真实环境”的安全保证[16]。</p><p><strong>挑战</strong>：证明难度大，往往需要构造更精巧的归约和大量的辅助结构，一些本在ROM下易于证明的协议，在标准模型下可能需要额外的技巧或修改[17]。</p><h2 id="可证明安全在区块链领域的地位"><a href="#可证明安全在区块链领域的地位" class="headerlink" title="可证明安全在区块链领域的地位"></a>可证明安全在区块链领域的地位</h2><h3 id="区块链对安全的特殊需求"><a href="#区块链对安全的特殊需求" class="headerlink" title="区块链对安全的特殊需求"></a>区块链对安全的特殊需求</h3><p>区块链是一个去中心化的分布式账本系统，通过共识算法和加密技术实现多方协作。其核心安全目标包括：</p><p><strong>数据不可篡改</strong>：交易记录一旦写入区块，不可逆转性对安全协议提出严格要求[18]。</p><p><strong>去中心化信任</strong>：无需中心信任机构，但需在协议层面保证各方按规则行事[19]。</p><p><strong>多方协作与高交互性</strong>：区块链上的操作往往涉及多方参与，如跨链互操作性、链上链下数据交换等场景，对协议安全性提出更高要求[20]。</p><h3 id="可证明安全在智能合约与链上协议设计中的意义"><a href="#可证明安全在智能合约与链上协议设计中的意义" class="headerlink" title="可证明安全在智能合约与链上协议设计中的意义"></a>可证明安全在智能合约与链上协议设计中的意义</h3><p><strong>事前防御</strong>：在智能合约或链上协议上线之前，利用可证明安全模型进行推演和归约，能有效避免常见漏洞与攻击场景[21]。</p><p><strong>审计与合规</strong>：在金融、供应链、物联网等领域，安全合规成为必要条件，可证明安全提供了可量化和可验证的合规依据[22]。</p><p><strong>促进技术进化</strong>：在零知识证明、多方安全计算（MPC）等新兴方向中，区块链应用尤为广泛，借助可证明安全的理念和工具，可推动这些新技术快速成熟[23]。</p><h3 id="典型实践案例"><a href="#典型实践案例" class="headerlink" title="典型实践案例"></a>典型实践案例</h3><p><strong>比特币与UTXO</strong>模型**：比特币脚本语言非常简洁，其安全性设计可被部分规约至哈希碰撞难题和椭圆曲线签名的安全性[24]。</p><p><strong>以太坊智能合约</strong>：大量去中心化应用（DApps）在以太坊上运行，智能合约在部署前多采用形式化验证与可证明安全分析工具进行审计[25]。</p><p><strong>跨链与侧链方案</strong>：在跨链通信时，通常需要Merkle证明或零知识证明（ZKP）机制来。</p><h1 id="链下安全协议的证明方法"><a href="#链下安全协议的证明方法" class="headerlink" title="链下安全协议的证明方法"></a>链下安全协议的证明方法</h1><p>在对一个安全协议进行分析或证明之前，必须先“规约”该协议，也即对其进行形式化或半形式化的描述，包括协议交互流程、角色和安全属性等。完善而准确的规约不仅有助于后续的安全模型构建，也为安全证明提供了明确的分析起点。</p><h2 id="常见安全协议的规约方式"><a href="#常见安全协议的规约方式" class="headerlink" title="常见安全协议的规约方式"></a>常见安全协议的规约方式</h2><p>本节从协议语义与流程描述、协议所需满足的安全特性，以及常见的形式化方法与工具三个方面进行阐述。</p><h3 id="协议语义与流程描述"><a href="#协议语义与流程描述" class="headerlink" title="协议语义与流程描述"></a>协议语义与流程描述</h3><h4 id="协议语义的内涵"><a href="#协议语义的内涵" class="headerlink" title="协议语义的内涵"></a>协议语义的内涵</h4><p>协议语义是指在安全通信或交互过程中，各个角色（如客户端、服务器、第三方）所发送或接收的消息类型、内容及顺序[26]。只有先明确各步骤的具体含义，才能进一步讨论协议在何种假设下能够保持安全性质，也才能有效地评估其在面对潜在攻击时的行为。</p><h4 id="流程描述的常见方式"><a href="#流程描述的常见方式" class="headerlink" title="流程描述的常见方式"></a>流程描述的常见方式</h4><p><strong>消息序列图（Message Sequence Chart</strong>）**：通过可视化的时序图展示协议中各参与方之间的消息交换顺序、消息内容以及条件判断。这样的图解方法直观、易于理解，适合在初期沟通或教学场景中使用。</p><p><strong>过程语言（Process Calculus</strong>）**：例如π演算（pi-calculus）或其扩展形式Applied π Calculus，这些形式化语言提供了严谨的语法规则和推理规则，让研究者能对协议流程进行系统建模，并支持自动化或半自动化的工具验证[27]。</p><p><strong>伪代码/</strong>操作描述**：以接近编程语言的方式直接描述协议中每一步的输入、输出和条件分支，实现者可依此快速理解并编写对应的程序或智能合约逻辑。</p><h4 id="协议语义描述要点"><a href="#协议语义描述要点" class="headerlink" title="协议语义描述要点"></a>协议语义描述要点</h4><p><strong>参与方角色定义</strong>：明确协议中哪些实体（人、设备、节点）参与交互，以及每个角色的功能和权限。</p><p><strong>消息格式与编码</strong>：规定消息中包含哪些字段（如时间戳、随机数、签名值等），以及如何进行编码和解码（例如ASN。1、JSON或自定义格式）。</p><p><strong>交互顺序与条件</strong>：清晰标明协议执行时的先后顺序、条件判断以及异常处理流程（如超时、消息丢失或校验失败时该如何处理）。</p><h3 id="安全特性的定义"><a href="#安全特性的定义" class="headerlink" title="安全特性的定义"></a>安全特性的定义</h3><p>不同场景下的协议对安全的要求并不相同：有的协议更关注机密性（确保信息不被窃听），有的则更加注重完整性（保证消息不被篡改），也有的强调匿名性（隐藏通信双方的真实身份）。如果没有在协议规约阶段做好安全特性定义，就无法针对性地评估或证明协议能否满足这些需求。</p><p>常见安全属性</p><p>（1）保密性（Confidentiality）：协议应保证未经授权的实体无法获取敏感信息。</p><p>（2）完整性（Integrity）：数据传输或存储期间不被篡改或伪造，或若发生篡改能被及时检测。</p><p>（3）身份认证（Authentication）：各参与方应能证明自己的身份，防止冒充或假冒行为。</p><p>（4）不可抵赖性（Non-repudiation）：协议执行后，发送方不能否认自己曾发送过某条消息，接收方也不能否认自己已接收。</p><p>（5）匿名性（Anonymity）或隐私（Privacy）：在某些场景下，需要隐藏通信双方的真实身份或交易细节。</p><p>（6）可用性（Availability）：协议在面对拒绝服务攻击或资源消耗攻击时，依然能维持必要的功能。</p><p>属性间的潜在冲突</p><p>在实际系统中，不同安全属性间可能出现权衡或冲突：</p><p>（1）隐私与审计冲突：为了便于审计或监管，往往需要对通信进行记录；这在一定程度上会影响匿名性或隐私。</p><p>（2）不可抵赖性与用户体验冲突：为实现不可抵赖性，可能需要增加数字签名、时间戳等操作，导致用户体验变差或协议实现更复杂。</p><p>（3）安全与性能冲突：频繁的加密或签名操作、额外的安全验证步骤，都会带来性能上的开销，需要在安全与效率之间做平衡。</p><h3 id="形式化方法与工具"><a href="#形式化方法与工具" class="headerlink" title="形式化方法与工具"></a>形式化方法与工具</h3><p>人工分析在面对复杂协议时易出现遗漏和误判，而形式化方法借助数学模型或符号推理的严谨性，有助于覆盖更多攻击路径并减少主观失误[28]。</p><h4 id="典型形式化工具"><a href="#典型形式化工具" class="headerlink" title="典型形式化工具"></a>典型形式化工具</h4><p><strong>ProVerif</strong>：基于Applied π Calculus的自动化分析工具，能检测包括保密性、认证性在内的多种安全属性。</p><p><strong>Tamarin</strong>：擅长分析协议在多种攻击场景下的复杂属性，如多重身份认证、组合攻击等，更适合研究分布式或多方安全性。</p><p><strong>CryptoVerif</strong>：使用复杂性理论进行可证明安全分析，能够在给定的复杂性假设下输出形式化的安全保证。</p><p><strong>AVISPA</strong>：具备多种后端工具（如 OFMC、CL-AtSe 等），适合对Internet协议（如IPSec、TLS）进行快速验证。</p><h4 id="工具使用的局限与建议"><a href="#工具使用的局限与建议" class="headerlink" title="工具使用的局限与建议"></a>工具使用的局限与建议</h4><p><strong>状态空间爆炸</strong>：随着协议规模和状态数增多，自动化工具可能面临计算量急剧膨胀的难题。</p><p><strong>建模抽象</strong>：形式化建模需要合理的抽象，过于简化会导致分析结果与现实脱节，过于精细又会导致模型过度复杂、难以分析。</p><p><strong>与实现结合</strong>：在工具验证完成后，实际代码实现环节中若存在新的漏洞（如编程错误或配置错误），依旧可能破坏协议原本的安全</p><h2 id="安全模型"><a href="#安全模型" class="headerlink" title="安全模型"></a>安全模型</h2><p>在完成协议的基本规约后，需要根据实际应用场景与安全需求构建相应的“安全模型”。该模型描述了系统中的通信方式、攻击者能力以及系统假设等关键要素。只有在一个合理、完备的模型下进行安全分析或证明，才能确保所得结论对真实环境有针对性和指导价值。</p><h3 id="通信模型"><a href="#通信模型" class="headerlink" title="通信模型"></a>通信模型</h3><h4 id="同步与异步"><a href="#同步与异步" class="headerlink" title="同步与异步"></a>同步与异步</h4><p><strong>同步通信</strong>：假设所有消息都在既定时限内完成传输，且系统能够检测并处理迟到或丢失消息。这类假设有助于简化协议分析，但往往不够贴近现实的网络情况。</p><p><strong>异步通信</strong>：在真实互联网中，各节点的消息传输往往存在延迟、丢包等现象，协议必须考虑这些不确定性。异步模型下，对去中心化系统的安全性分析更具现实意义，但形式化证明也更复杂。</p><h4 id="点对点与广播"><a href="#点对点与广播" class="headerlink" title="点对点与广播"></a>点对点与广播</h4><p><strong>点对点</strong>：典型的客户端-服务器模式或一对一通信模式，安全分析中更关注两方间的秘密交换与身份认证。</p><p><strong>广播</strong>：在多方参与或分布式系统（如区块链）中，广播通信是核心特性，需要评估篡改广播、重放广播、以及网络分区等情形下的安全性。</p><h4 id="可信第三方（TTP）的存在与否"><a href="#可信第三方（TTP）的存在与否" class="headerlink" title="可信第三方（TTP）的存在与否"></a>可信第三方（TTP）的存在与否</h4><p><strong>有TTP</strong>：如果系统中有被所有方公认可信的第三方，可以帮助完成仲裁、时间戳签发、密钥管理等操作，协议设计可能更简单。</p><p><strong>无TTP</strong>：若系统要在完全去中心化模式下运行，就需要使用共识算法、多方安全计算等技术来替代传统第三方的职能，但安全分析也更加复杂。</p><h3 id="攻击者模型"><a href="#攻击者模型" class="headerlink" title="攻击者模型"></a>攻击者模型</h3><p><strong>被动攻击者（Passive Adversary</strong>）：仅能窃听或记录通信，但无法篡改或伪造消息。针对被动攻击者，协议主要需要确保保密性和不可识别性（若需要匿名）。</p><p><strong>主动攻击者（Active Adversary</strong>）：可以篡改、伪造、拦截消息，甚至在某些情况下能够移除或重放特定消息。在区块链场景中，还需考虑矿工或节点本身作为主动攻击者时可能发起的分叉攻击或双花攻击。</p><p><strong>适应性攻击者（Adaptive Adversary</strong>）：具备动态调整攻击策略的能力，能够随着协议执行过程的进展，进行针对性攻击。对多方安全计算或链上智能合约来说，适应性攻击模型通常被视为最具威胁的场景之一。</p><p><strong>内生攻击者（Insider Attacker</strong>）：在系统内部拥有合法身份和权限，但实际上具备恶意行为。例如，在联盟链或企业内部系统中，拥有管理员权限的攻击者可能利用特权窃取或篡改关键数据。相应协议需要对内部滥用行为进行限制与审计。</p><h3 id="系统假设与信任环境"><a href="#系统假设与信任环境" class="headerlink" title="系统假设与信任环境"></a>系统假设与信任环境</h3><p><strong>密码学算法假设：</strong>例如，假设哈希函数满足碰撞难以发生、离散对数难题无解或大数分解难度足够高等。只有在这些复杂性假设成立的前提下，才能推导出协议的可证明安全性。</p><p><strong>硬件环境与操作系统假设：</strong>某些协议可能依赖于安全硬件模块（如TPM、HSM）或受信任执行环境（如Intel SGX）来存储和处理敏感信息。如果硬件本身存在安全漏洞，则协议的整体安全性就会受到影响。</p><p><strong>实现层面与外围系统依赖</strong>网络传输层的TLS/SSL安全性、服务器操作系统或智能合约平台是否存在已知漏洞、第三方：库是否安全等，都是可能破坏协议安全的外部因素。因此，需在安全模型中对外围系统做适度的风险评估和防护。</p><p><strong>信任域划分与管理：</strong>不同模块或不同参与方可以被分配到不同的信任级别：例如，数据库管理员仅可访问明文，但无法更改加密策略；智能合约执行环境是公开的，但核心的密钥管理模块是私有的。这种划分能帮助更细粒度地进行安全分析。</p><h2 id="安全证明"><a href="#安全证明" class="headerlink" title="安全证明"></a>安全证明</h2><p>完成协议规约与安全模型构建后，接下来就是核心的“安全证明”环节。安全证明的目标在于：在所设定的模型和假设下，论证协议能抵御何种类型的攻击或满足哪些安全属性。本节将从模拟范式、归约证明以及工具辅助验证三个方面展开。</p><h3 id="模拟范式（Simulation-Paradigm）"><a href="#模拟范式（Simulation-Paradigm）" class="headerlink" title="模拟范式（Simulation Paradigm）"></a>模拟范式（Simulation Paradigm）</h3><p>模拟范式广泛用于多方安全计算（MPC）、零知识证明（ZKP）以及通用组合安全（UC）框架等领域。其主要思路是：构造一个模拟器（Simulator），在不知真实机密的情况下，生成与真实协议执行“不可区分”的交互输出。如果攻击者在模拟环境中无法获取更多的信息，则说明协议在该模型下是安全的。</p><h4 id="关键概念"><a href="#关键概念" class="headerlink" title="关键概念"></a>关键概念</h4><p><strong>模拟器（Simulator</strong>）：扮演所有诚实方或特定角色，以伪造或生成看似“合法”的通信记录，让攻击者无法察觉差异。</p><p><strong>判别器（Distinguisher</strong>）：攻击者尝试区分模拟环境与真实环境，如果区分概率微不足道（可忽略），则协议可被视为安全。</p><p><strong>通用组合性（Universal Composability</strong>，UC<strong>）</strong>：Canetti提出的UC框架允许把一个安全协议作为“构件”组合到更大的系统中，只要各协议都满足UC安全定义，组合后仍能保持安全。</p><h4 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h4><p><strong>优点</strong>：该范式直观地反映了攻击者在协议执行中的信息获取情况；若在模拟环境中攻击者无法取得优势，在真实环境中也无法取得优势。</p><p><strong>缺点</strong>：构造模拟器往往较为复杂，需要深入考虑协议各步骤的可见性、随机性以及对攻击者的限制；某些复杂场景的模拟证明会相当冗长。</p><h3 id="归约证明（Reduction）"><a href="#归约证明（Reduction）" class="headerlink" title="归约证明（Reduction）"></a>归约证明（Reduction）</h3><p>将“破坏协议”这件事与“解决某个公认的复杂难题”相挂钩。如果假设有一个敌手能在合理时间内破坏协议，那么就能用它来高效率地解决这个复杂难题，从而与难题“难解”这一假设产生矛盾。这样，就能证明协议安全性建立在该复杂难题的不可解之上。</p><h4 id="常见复杂难题"><a href="#常见复杂难题" class="headerlink" title="常见复杂难题"></a>常见复杂难题</h4><p><strong>离散对数问题（Discrete Logarithm Problem</strong>）：给定$g^x mod p$ 和$g$ ，求出$x$被认为在多项式时间内不可行。</p><p><strong>大整数分解问题（Integer Factorization Problem</strong>）：寻找大整数的因数分解在现有算法和硬件条件下极其困难。</p><p><strong>基于格的难题（Lattice-based Problems</strong>）：如短向量问题（Shortest Vector Problem，SVP）、近似最短向量问题（Approx-SVP）等，被视为抗量子密码学的重要候选。</p><h4 id="归约证明的构造技巧"><a href="#归约证明的构造技巧" class="headerlink" title="归约证明的构造技巧"></a>归约证明的构造技巧</h4><p><strong>伪装“</strong>敌手”<strong>为子例程</strong>：在归约过程中，把“假设存在的攻击者”当作一个可以接受输入并输出结果的黑盒程序，通过调用它来完成对难题的求解。</p><p><strong>保持机密性与随机性</strong>：需仔细设计协议中的随机数和密钥生成方式，确保在归约构造中不会暴露可被敌手利用的弱点。</p><p><strong>复杂度分析</strong>：证明过程需指出，如果攻击者能在多项式时间内破坏协议，那么就能在相似或更短的多项式时间内解决难题，从而达成矛盾。</p><h4 id="适用范围"><a href="#适用范围" class="headerlink" title="适用范围"></a>适用范围</h4><p>归约证明通常适用于基于公钥加密、数字签名、密钥交换等需要依赖数学难题的协议。对于结合多方交互或应用层逻辑较繁琐的协议（如跨链协议、链上链下融合协议等），可能需要在安全模型中增加更多场景假设后再进行归约分析。</p><h1 id="链上协议的证明方法"><a href="#链上协议的证明方法" class="headerlink" title="链上协议的证明方法"></a>链上协议的证明方法</h1><p>与传统的中心化系统相比，区块链网络在去中心化、透明度和不可篡改等方面具有显著的优势。然而，这些特性也带来了新的攻击面和安全风险：</p><p><strong>去中心化与共识机制：</strong>块链通过分布式节点达成共识来维护账本的一致性，不依赖任何单一的中央机构。虽然这能有效减少单点故障的风险，但同时意味着攻击者只要能控制或影响到一定比例的节点，就有可能破坏共识流程（如51%算力攻击或拜占庭故障攻击）[29]。</p><p>此外，由于节点地理分布广泛，网络延迟、网络分区等问题也可能被恶意利用，导致分叉、交易回滚或双花攻击等安全隐患。</p><p><strong>公开透明的合约代码：</strong>在公有链环境下（如以太坊），智能合约的源码大多是公开的，任何人都可以审阅合约逻辑并从中寻找漏洞。一旦发现安全缺陷，攻击者可以快速定位并利用漏洞，进行针对性攻击，例如重入攻击、整数溢出或者权限错误配置。[21]</p><p><strong>不可篡改与数据持久性：</strong>区块链上已确认的交易或合约状态难以篡改，除非进行极其耗费资源的回滚操作。这在一定程度上确保了历史数据的完整性，但如果智能合约逻辑本身存在缺陷，一旦部署则难以通过传统意义上的“热修复”快速修补，需要想办法通过合约升级或分叉来解决问题，增加了维护与运营难度。[20]</p><h2 id="常见威胁类别"><a href="#常见威胁类别" class="headerlink" title="常见威胁类别"></a>常见威胁类别</h2><p>在链上协议或智能合约中，常见的威胁类别大致可分为以下几个方面。了解这些攻击场景有助于我们在设计和证明协议时做出有针对性的防御措施。</p><h3 id="合约漏洞"><a href="#合约漏洞" class="headerlink" title="合约漏洞"></a>合约漏洞</h3><p><strong>重入攻击（Re-entrancy Attack**</strong>）**：攻击者在合约调用外部合约时利用状态更新时机不当，反复调用目标合约并窃取资金。</p><p><strong>整数溢出/**</strong>下溢（Overflow/Underflow<strong>**）</strong>：攻击者利用数学运算的边界问题，导致余额或计数器在无意间重置，进而造成错误的业务逻辑或资产损失。</p><p><strong>访问控制漏洞</strong>：智能合约中常使用 require 或权限修饰器控制函数的可调用主体，但若逻辑不严谨就可能被绕过，造成合约被随意调用或资产被非法转移。</p><h3 id="重放攻击（Replay-Attack）"><a href="#重放攻击（Replay-Attack）" class="headerlink" title="重放攻击（Replay Attack）"></a>重放攻击（Replay Attack）</h3><p>在某些链上链下交互或跨链通信场景中，若没有做好消息的时间戳验证或唯一性检测，攻击者可以将同样的数据包或交易多次在不同上下文中重放，导致资源或资产被多次消耗。</p><p><strong>女巫攻击（Sybil Attack**</strong>）：**在区块链环境中，攻击者可以创建大量假身份（节点）来操纵投票、共识或其他依赖节点数量的机制。女巫攻击尤其在P2P网络或去中心化投票中较为常见，需要额外的身份验证或抵押机制进行防范。[30]</p><h3 id="共识层攻击"><a href="#共识层攻击" class="headerlink" title="共识层攻击"></a>共识层攻击</h3><p><strong>51%**</strong>攻击**：若攻击者掌握全网超过51%的算力或权益，则可自行决定哪些区块最终得到确认，从而进行双花攻击或拒绝某些交易上链。</p><p><strong>自私挖矿（Selfish Mining**</strong>）**：攻击者在挖矿时秘密保留私有链，不及时将找到的新区块广播出去，企图累积更多区块后一次性发布，导致 honest 矿工浪费资源。[31]</p><h3 id="Gas耗尽与拒绝服务"><a href="#Gas耗尽与拒绝服务" class="headerlink" title="Gas耗尽与拒绝服务"></a>Gas耗尽与拒绝服务</h3><p>以太坊等平台的“Gas”机制用来限制智能合约执行消耗。攻击者可能利用合约中的大量循环或复杂操作来消耗发起方的Gas，从而干扰合约的正常执行，或逼迫合约中止执行引发拒绝服务。[32]</p><h2 id="价值与风险权衡"><a href="#价值与风险权衡" class="headerlink" title="价值与风险权衡"></a>价值与风险权衡</h2><p>链上协议能显著提升交易透明度与安全审计能力，但也引入了额外的风险与系统复杂度。对于从传统中心化系统迁移到区块链场景的业务，需要从以下角度进行价值与风险权衡：</p><h3 id="透明度与隐私"><a href="#透明度与隐私" class="headerlink" title="透明度与隐私"></a>透明度与隐私</h3><p>区块链的所有交易都对外公开，带来“可审计性”的优点，同时也可能暴露用户账户余额或交易模式，导致隐私泄露。若业务高度依赖隐私保护，就需要结合零知识证明或隐私合约技术。</p><h3 id="去中心化与可控性"><a href="#去中心化与可控性" class="headerlink" title="去中心化与可控性"></a>去中心化与可控性</h3><p>去中心化意味着不需要信任单一方，但在出现安全事故或重大漏洞时，也难以通过“一刀切”的方式回滚或修改数据。这个特性在监管和合规层面常会引发争议，需要在协议设计时考虑可升级性或紧急机制。</p><h3 id="不可篡改与灵活度"><a href="#不可篡改与灵活度" class="headerlink" title="不可篡改与灵活度"></a>不可篡改与灵活度</h3><p>一旦部署在链上的协议发生错误，除非设计了升级代理合约（proxy pattern）或多签治理结构，否则修复和升级的代价相当高。因此在上线前需要投入更多资源进行审计与形式化验证，以降低潜在风险。</p><h2 id="抵御威胁的关键思路"><a href="#抵御威胁的关键思路" class="headerlink" title="抵御威胁的关键思路"></a>抵御威胁的关键思路</h2><p>在了解了链上协议的特点与主要威胁后，本节将介绍常用的抵御策略，包括安全合约编程实践、经济激励和惩罚机制、可验证计算与零知识证明，以及多方安全计算（MPC）等先进技术。通过这些手段，协议设计者能够在不同层面上强化合约安全性并对潜在攻击实施有效防范。</p><h3 id="全合约编程规范"><a href="#全合约编程规范" class="headerlink" title="全合约编程规范"></a>全合约编程规范</h3><h4 id="编译器与语言特性"><a href="#编译器与语言特性" class="headerlink" title="编译器与语言特性"></a>编译器与语言特性</h4><p>建议选择成熟度较高且具有安全特性支持的智能合约语言（如Solidity、Vyper等）。一些语言会在编译阶段或语法层面提供安全检查，例如限制整数溢出、禁止不安全的低级调用等。充分利用这些语言特性能减少常见漏洞的发生。[33]</p><h4 id="设计模式与最佳实践"><a href="#设计模式与最佳实践" class="headerlink" title="设计模式与最佳实践"></a>设计模式与最佳实践</h4><p><strong>Checks-Effects-Interactions**</strong>模式**：先检查条件，然后更新合约内部状态，最后与外部合约进行交互，能有效防范重入攻击。[21]</p><p><strong>使用安全库</strong>：官方或社区维护的安全库（如OpenZeppelin）提供了安全数学运算、权限控制、可升级代理合约等模块，能降低低级错误带来的风险。</p><p><strong>最小权限原则（Principle of Least Privilege**</strong>）**：在合约内部和外部交互中，只暴露必要的接口与权限，防止过度授予权限导致的安全威胁。</p><h4 id="形式化验证与审计"><a href="#形式化验证与审计" class="headerlink" title="形式化验证与审计"></a>形式化验证与审计</h4><p>在完成合约编写后，通常需要利用诸如Slither、MythX等静态分析工具，或结合模型检测、符号执行等技术对合约逻辑进行审计；对关键模块，还可以使用ProVerif、Tamarin等进行形式化验证。[25]</p><p>一些企业或社区会聘请专业的第三方审计机构（如Trail of Bits、Consensys Diligence等）进行审计，帮助尽可能提前发现逻辑漏洞。</p><h3 id="激励与惩罚机制"><a href="#激励与惩罚机制" class="headerlink" title="激励与惩罚机制"></a>激励与惩罚机制</h3><h4 id="Token激励"><a href="#Token激励" class="headerlink" title="Token激励"></a>Token激励</h4><p>链上协议往往涉及Token或加密货币。通过设计合理的经济模型，可以让节点或用户遵循协议获得收益，若作恶则面临代价。比如在权益证明（PoS）中，节点需要抵押代币来参与共识，一旦违规就会被惩罚没收部分或全部抵押金。</p><h4 id="治理与投票"><a href="#治理与投票" class="headerlink" title="治理与投票"></a>治理与投票</h4><p>对于复杂的去中心化协议，常采用链上治理机制，让代币持有者投票决定合约升级或重大参数调整。若某些节点或参与方进行恶意操作或提交不利提案，在投票环节就可能被否决并受到信誉影响或经济损失。</p><h4 id="惩罚与声誉机制"><a href="#惩罚与声誉机制" class="headerlink" title="惩罚与声誉机制"></a>惩罚与声誉机制</h4><p><strong>惩罚：</strong>在合约层面或共识层面设置处罚规则，如挖矿或出块时发现某节点双签（Double Signing）或离线过久，就会扣减其押金或权益。</p><p><strong>声誉体系：</strong>在部分区块链应用中，引入对节点或用户行为的持续评估。连续贡献有益行为者会提高声誉值，恶意行为则降低声誉值，甚至被剔除出网络。</p><h3 id="可验证计算与零知识证明"><a href="#可验证计算与零知识证明" class="headerlink" title="可验证计算与零知识证明"></a>可验证计算与零知识证明</h3><h4 id="可验证计算（Verifiable-Computation）"><a href="#可验证计算（Verifiable-Computation）" class="headerlink" title="可验证计算（Verifiable Computation）"></a>可验证计算（Verifiable Computation）</h4><p>为了确保链上执行结果的正确性和完整性，一些协议会将大量计算放到链下进行，并在链上只验证计算结果的正确性。[34]这样既能节省Gas和时间成本，又能避免链上重复计算造成的资源浪费。常见技术包括：</p><p><strong>SNARKs**</strong>（Succinct Non-Interactive ARguments of Knowledge<strong>**）</strong>：如zk-SNARKs能在不暴露计算输入/细节的情况下，为计算结果生成一个简洁的证明，链上只需较短时间就能验证证明的有效性。</p><p><strong>STARKs**</strong>（Scalable Transparent ARguments of Knowledge<strong>**）</strong>：与SNARKs相比不依赖可信设置，更注重透明性，但在某些实现上证明大小和验证速度会有区别。</p><h4 id="零知识证明与隐私保护"><a href="#零知识证明与隐私保护" class="headerlink" title="零知识证明与隐私保护"></a>零知识证明与隐私保护</h4><p>区块链通常是透明的，但某些场景下需要保护交易隐私，例如金融数据或个人敏感信息。零知识证明允许证明者在不泄露信息本身的情况下，让验证者确信某个陈述为真。</p><h4 id="应用实例："><a href="#应用实例：" class="headerlink" title="应用实例："></a>应用实例：</h4><p>Zcash中使用zk-SNARKs来隐藏交易金额与地址；</p><p>以太坊Layer 2扩容方案中采用zk-Rollup，将大量交易打包证明后提交主链，从而既提高扩展性又保护隐私。</p><h3 id="多方安全计算（MPC）"><a href="#多方安全计算（MPC）" class="headerlink" title="多方安全计算（MPC）"></a>多方安全计算（MPC）</h3><p>在链上链下融合的场景中，往往有多方需要共同计算某些敏感数据（如用户隐私、商业机密），但又不希望把数据完全暴露给其他方。多方安全计算（MPC）通过密码学手段实现“在不泄漏敏感信息的前提下完成计算并得到正确结果”的目标。</p><h4 id="典型协议"><a href="#典型协议" class="headerlink" title="典型协议"></a>典型协议</h4><p><strong>阈值签名（Threshold Signature**</strong>）**：将私钥分成多份，分布在不同节点上，只有在大多数节点同意的情况下才能合成有效签名，用于提高数字资产保管的安全性。</p><p><strong>秘密共享（Secret Sharing**</strong>）**：Shamir秘密共享等机制能保证即使少数节点遭到入侵，攻击者也无法恢复完整的敏感信息。</p><p><strong>组合MPC**</strong>协议**：在学术界已经出现多种基于电路或基于同态加密的通用MPC协议，在实际区块链应用中可与共识层或合约层结合，进一步提升隐私与安全。[35]</p><h4 id="在区块链中的应用"><a href="#在区块链中的应用" class="headerlink" title="在区块链中的应用"></a>在区块链中的应用</h4><p>当多方想要联合训练模型或交换数据，但又互不信任时，MPC能在链下完成主要计算，然后只将最终结果或加密证明上链公示，避免泄漏各方的原始数据。对于链上链下融合协议的安全证明而言，结合MPC的安全模型需要考虑更多角色、更多交互轮次的形式化分析。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>综观整门课程，从可证明安全理论的缘起与内涵，到常见的安全协议规约与证明方法，再到区块链环境下链上协议的特殊威胁与针对性防护，再结合“数据所有权转让协议”的具体案例分析，可以清晰地看到可证明安全理论在实际应用中的巨大价值和必要性。首先，可证明安全要求在基于复杂性假设或形式化模型的前提下，利用模拟范式或归约方法等思路，为协议的安全属性提供可量化、可检验的数学保证；这种严谨的设计与分析方式，与区块链去中心化、高透明度以及不可篡改等特性交相呼应，能够在合约部署或协议上线前尽早发现并修补潜在漏洞，从而最大程度地避免因恶意攻击或逻辑缺陷造成的财产损失与信誉损坏。其次，对于链上协议这种将核心逻辑直接写入智能合约、且常常公开暴露在透明的区块链网络中的应用场景，安全威胁更为多样且复杂，如合约漏洞、女巫攻击、重放攻击、共识层算力操纵等都可能在无形中危及系统的整体安全；因此，结合经济激励和惩罚机制、多方安全计算、零知识证明与可验证计算等技术手段，通过完备的安全模型进行系统化防御，才能既保障合约的正确性与高效性，又兼顾用户隐私与网络稳定性。而在“数据所有权转让协议”这一具体实例中，我们进一步看到如何把可证明安全的种种方法落地到实际业务流程，特别是通过形式化建模和自动化验证，让参与方在链上链下的交互过程中既能保护自身利益，也能确保数据的所有权边界和使用合规性得到可靠验证。这些理论与实践的结合，不仅为区块链领域的协议设计和实施提供了稳固的安全保障，也为后续更多跨领域的融合应用带来启示：在日益复杂的数字经济时代，只有将安全需求放在首位，依托严格的可证明安全技术与完善的协议设计，才能构筑起可信、可审计、可持续进化的业务生态。</p><h1 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h1><p>[1]  O. Goldreich. Foundations of Cryptography. Cambridge University Press, 2001.</p><p>[2]  J. Katz, Y. Lindell. Introduction to Modern Cryptography. 2014.</p><p>[3]  A. A Menezes. Handbook of applied cryptography. 1996.</p><p>[4]  W. Diffie, M. Hellman. New directions in cryptography. IEEE Transactions on Information Theory, 22(6): 644-654, 1976.</p><p>[5]  T. Elgamal. A public key cryptosystem and a signature scheme based on discrete logarithms. IEEE Transactions on Information Theory, 31(4): 469-472, 1985.</p><p>[6]  S. Goldwasser, S. Micali. Probabilistic encryption. Journal of Computer and System Sciences, 28(2): 270-299, 1984.</p><p>[7]  D. Boneh, V. Shoup. A graduate course in applied cryptography. Draft 0.5, 2020.</p><p>[8]  U. Maurer. Modelling a public-key infrastructure. Lecture Notes in Computer Science, 325-350, 1996.</p><p>[9]  A. R. Regenscheid. NIST Cryptographic Standards and Guidelines Development Process. National Institute of Standards and Technology, 2016.</p><p>[10] Fuchun Guo’s Homepage. <a href="https://documents.uow.edu.au/~fuchun/">https://documents.uow.edu.au/~fuchun/</a>.</p><p>[11] 郭福春个人主页. <a href="https://space.bilibili.com/2095536965">https://space.bilibili.com/2095536965</a>.</p><p>[12] V. Shoup. On formal models for secure key exchange. 1999.</p><p>[13] M. Bellare, P. Rogaway. Random oracles are practical. Proceedings of the 1st ACM conference on Computer and communications security - CCS ’93: 62-73, 1993.</p><p>[14] A. Fiat, A. Shamir. How To Prove Yourself: Practical Solutions to Identification and Signature Problems. Advances in Cryptology — CRYPTO’ 86, 263: Springer Berlin Heidelberg, 186-194, 2006.</p><p>[15] R. Canetti, O. Goldreich, S. Halevi. On the Random-Oracle Methodology as Applied to Length-Restricted Signature Schemes. Lecture Notes in Computer Science, 40-57, 2004.</p><p>[16] D. Pointcheval, J. Stern. Security Arguments for Digital Signatures and Blind Signatures. Journal of Cryptology, 13(3): 361-396, 2000.</p><p>[17] J. Camenisch, M. Stadler. Efficient group signature schemes for large groups. Lecture Notes in Computer Science, 410-424, 1997.</p><p>[18] S. Nakamoto. Bitcoin: A peer-to-peer electronic cash system. Satoshi Nakamoto, 2008.</p><p>[19] J. Garay, A. Kiayias, N. Leonardos. The Bitcoin Backbone Protocol: Analysis and Applications. Lecture Notes in Computer Science, 281-310, 2015.</p><p>[20] V. Buterin. A next-generation smart contract and decentralized application platform. white paper, 3(37): 2-1, 2014.</p><p>[21] L. Luu, D. H. Chu, H. Olickel, P. Saxena, A. Hobor. Making Smart Contracts Smarter. Proceedings of the 2016 ACM SIGSAC Conference on Computer and Communications Security: 254-269, 2016.</p><p>[22] N. Atzei, M. Bartoletti, T. Cimoli. A Survey of Attacks on Ethereum Smart Contracts (SoK). Lecture Notes in Computer Science, 164-186, 2017.</p><p>[23] J. Groth. On the Size of Pairing-Based Non-interactive Arguments. Lecture Notes in Computer Science, 305-326, 2016.</p><p>[24] A. Poelstra. Mimblewimble: Private, Massively-Prunable Blockchains.</p><p>[25] P. Tsankov, A. Dan, D. Drachsler-Cohen, A. Gervais, F. Bünzli, M. Vechev. Securify: Practical Security Analysis of Smart Contracts. Proceedings of the 2018 ACM SIGSAC Conference on Computer and Communications Security: 2018.</p><p>[26] G. Lowe. A hierarchy of authentication specifications. Proceedings 10th Computer Security Foundations Workshop: 31-43, 1997.</p><p>[27] M. Abadi, C. Fournet. Mobile values, new names, and secure communication. ACM SIGPLAN Notices, 36(3): 104-115, 2001.</p><p>[28] E. M. Clarke, J. M. Wing. Formal Methods: State of the Art and Future Directions. ACM Computing Surveys, 28(4): 626-643, 1996.</p><p>[29] I. Eyal, E. G. Sirer. Majority Is Not Enough: Bitcoin Mining Is Vulnerable. Lecture Notes in Computer Science, 436-454, 2014.</p><p>[30] J. R. Douceur. The Sybil Attack. Lecture Notes in Computer Science, 251-260, 2002.</p><p>[31] I. Eyal. The Miner’s Dilemma. 2015 IEEE Symposium on Security and Privacy: 2015.</p><p>[32] C. P. Gilman. The Yellow Wall-Paper. The Yellow Wall-Paper and Other Stories, 2009.</p><p>[33] C. Dannen. Solidity Programming. Introducing Ethereum and Solidity, 69-88, 2017.</p><p>[34] R. Gennaro, C. Gentry, B. Parno. Non-interactive Verifiable Computing: Outsourcing Computation to Untrusted Workers. Lecture Notes in Computer Science, 465-482, 2010.</p><p>[35] I. Damgård, M. Keller, E. Larraia, V. Pastro, P. Scholl, N. P. Smart. Practical Covertly Secure MPC for Dishonest Majority – Or: Breaking the SPDZ Limits. Lecture Notes in Computer Science, 1-18, 2013.</p><p>[36] M. Herlihy. Atomic Cross-Chain Swaps. arXiv:1801.09515, 2018.</p><p>[37] A. Dalton, D. Thomas, P. Cheung. Secret Swapping: Two Party Fair Exchange. Cryptology ePrint Archive, 2023.</p>]]></content>
      
      
      <categories>
          
          <category> 密码学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 安全规约 </tag>
            
            <tag> 安全证明 </tag>
            
            <tag> 链上链下融合 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>中文latex论文修订方法汇总（changes包方式，latexdiff指令，中文乱码解决）</title>
      <link href="/2025/01/13/%E4%B8%AD%E6%96%87latex%E8%AE%BA%E6%96%87%E4%BF%AE%E8%AE%A2%E6%96%B9%E6%B3%95%E6%B1%87%E6%80%BB/"/>
      <url>/2025/01/13/%E4%B8%AD%E6%96%87latex%E8%AE%BA%E6%96%87%E4%BF%AE%E8%AE%A2%E6%96%B9%E6%B3%95%E6%B1%87%E6%80%BB/</url>
      
        <content type="html"><![CDATA[<hr><p>最近碰到了一个硬钉子，论文审稿意见返回来需要修改，但是修改完要提交两个修改版本：一个是修改后的最新版论文稿件，这个好说；另外一个是包含了修改痕迹的修订版稿件，而且修订的内容还要<strong>高亮</strong>（见下图，这个图扯就扯在它是word版的，但投稿要用latex写，惊不惊喜意不意外？），为了实现这两个要求，跟latex斗智斗勇十几天终于在老师和师姐的帮助下解决了这个老大难的问题，特此总结一下防止以后在掉进坑里。特别感谢老板提供的latexdiff修改方法还陪我一块加班改论文到大半夜，以及老婆对latexdiff编译乱码问题的关键帮助！</p><p><img src="https://blogimages.happyshark.cn/%E4%B8%AD%E6%96%87latex%E8%AE%BA%E6%96%87%E4%BF%AE%E8%AE%A2%E6%96%B9%E6%B3%95%E6%B1%87%E6%80%BB/clip_image002.jpg" alt="img"></p><h1 id="如何选择latex的修改方案"><a href="#如何选择latex的修改方案" class="headerlink" title="如何选择latex的修改方案"></a>如何选择latex的修改方案</h1><p>如果可以的话，其实还是推荐changes包，因为你只需要通过代码的形式把修改内容写进latex里，然后通过全局控制<code>只显示旧版</code>、<code>只显示新版</code>、<code>显示修订过程</code>实现三个版本的快速渲染，完美符合latex的思想！<strong>但是</strong>，changes包也有坏处，他对中文的支持很不好，<strong>而且不支持双栏</strong>，所以如果是双栏的论文那就只能选择latexdiff的方案了。而latexdiff虽然可以显示出修订过程，<strong>但是没法按照要求高亮背景，并添加批注</strong>，想要高亮和批注就只能渲染完一版然后一点一点手工土法修改，要是再多来几个老师和同学一块修订，不停的返工，那太酸爽了o(╥﹏╥)o。所以总结一下changes包和latexdiff的优缺点，看自己的需求选择<strong>人工工作量少</strong>的方案，哪怕花1天去搞自动流程都不要引入人工，不然一旦返工就得花掉成倍的垃圾时间。</p><div class="table-container"><table><thead><tr><th></th><th>优势</th><th>劣势</th></tr></thead><tbody><tr><td>changes包</td><td>一次编写，自动生成三种不同的文档，而且生成的pdf自带高亮和批注</td><td>文档兼容性极差，除非是eprint那种简单格式的，不然动不动就不显示高亮或者批注</td></tr><tr><td>latexdiff</td><td>直接把新的tex和旧的tex合并就完事了，对于大多数英文期刊这个指令还是很友好的</td><td>没有高亮和批注，生成的pdf得靠自己纯手工高亮，一旦返工就是噩梦</td></tr></tbody></table></div><h1 id="changes包方式"><a href="#changes包方式" class="headerlink" title="changes包方式"></a>changes包方式</h1><p> changes包其实很适合overleaf这种在线协作的写论文方式，使用这个包的时候需要注意一点，批注的宽度可能会超过页面宽度，所以需要先在导言区手动设置页面宽度以便留出足够的空间显示批注：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">\geometry&#123;a4paper,left=3cm,right=3cm,top=3cm,bottom=2cm&#125; % 调整页面布局，右侧留出空间</span><br><span class="line">\setlength&#123;\paperwidth&#125;&#123;26cm&#125; % 扩展页面宽度，增加几厘米用于边注</span><br><span class="line">\setlength&#123;\textwidth&#125;&#123;16cm&#125; % 保持左侧正文为A4纸宽度</span><br></pre></td></tr></table></figure><p>然后在导言区添加changes包：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">\usepackage&#123;changes&#125;</span><br></pre></td></tr></table></figure><h2 id="命令用法"><a href="#命令用法" class="headerlink" title="命令用法"></a>命令用法</h2><p>常见的命令如下，更多的自定义设置见文档：<a href="https://mirrors.ibiblio.org/CTAN/macros/latex/contrib/changes/changes.english.pdf">https://mirrors.ibiblio.org/CTAN/macros/latex/contrib/changes/changes.english.pdf</a></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">% 添加</span><br><span class="line">This is \added&#123;added text&#125;.</span><br><span class="line">% 删除</span><br><span class="line">This is \deleted[comment=&#123;two words&#125;]&#123;deleted text&#125;.</span><br><span class="line">% 替换</span><br><span class="line">This is \replaced&#123;new&#125;&#123;old&#125; text.</span><br><span class="line">% 高亮</span><br><span class="line">This is \highlight&#123;highlight&#125; text.</span><br><span class="line">% 批注</span><br><span class="line">This is \comment&#123;comment&#125; commented text.</span><br></pre></td></tr></table></figure><p>效果如下：</p><p><img src="https://blogimages.happyshark.cn/%E4%B8%AD%E6%96%87latex%E8%AE%BA%E6%96%87%E4%BF%AE%E8%AE%A2%E6%96%B9%E6%B3%95%E6%B1%87%E6%80%BB/image-20250114101016914.png" alt="image-20250114101016914"></p><p>需要注意的是，直接导入changes包可能会报错，一般这种情况是因为指令冲突，需要在导入的时候添加<code>commandnameprefix=always</code>指令。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">\usepackage[commandnameprefix=always]&#123;changes&#125;</span><br></pre></td></tr></table></figure><p>使用指令的时候就需要在原有的指令前加上<code>ch</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">% 这是一个\chadded&#123;新增的&#125;句子。</span><br><span class="line">% 这是一个\chdeleted&#123;需要删除的&#125;句子。</span><br><span class="line">% 这是一个\chreplaced&#123;新的文本&#125;&#123;旧的文本&#125;。</span><br><span class="line">% 这是一个\chhighlight&#123;需要注意的部分&#125;。</span><br></pre></td></tr></table></figure><p>如果对changes的批注有要求的话，还需要引用<code>todonotes</code>， 在进一步对todonotes进行配置。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">\usepackage[colorinlistoftodos,size=tiny]&#123;todonotes&#125;%配置批注栏的效果</span><br><span class="line">\usepackage[authormarkup=todonotes,commandnameprefix=always]&#123;changes&#125;%引入todonotes包</span><br></pre></td></tr></table></figure><p>对于需要添加高亮和批注的修订，只需要在正文代码中进行以下修改即可，这里以删除为例，这里使用了高亮和删除的嵌套，<code>[comment=&#123;审阅意见10&#125;]</code>跟在<code>\chhighlight</code>后作为对高亮的批注，高亮内部在嵌套一个删除，实现修订痕迹和修订批注的效果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">实验结果表明，本协议\chhighlight[comment=&#123;审阅意见10&#125;]&#123;\chdeleted&#123;在保证效率的同时，&#125;&#125;极大提升了效果。</span><br></pre></td></tr></table></figure><p>效果如下：</p><p><img src="https://blogimages.happyshark.cn/%E4%B8%AD%E6%96%87latex%E8%AE%BA%E6%96%87%E4%BF%AE%E8%AE%A2%E6%96%B9%E6%B3%95%E6%B1%87%E6%80%BB/image-20250114103502740.png" alt="image-20250114103502740"></p><p>添加<code>\chadded</code>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">本协议\chhighlight[comment=&#123;审阅意见10&#125;]&#123;\chadded&#123;在保证效率的同时，&#125;&#125;极大提升了效果。</span><br></pre></td></tr></table></figure><p>效果：</p><p><img src="https://blogimages.happyshark.cn/%E4%B8%AD%E6%96%87latex%E8%AE%BA%E6%96%87%E4%BF%AE%E8%AE%A2%E6%96%B9%E6%B3%95%E6%B1%87%E6%80%BB/image-20250114104427004.png" alt="image-20250114104427004"></p><p>替换<code>\chreplaced</code>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">本协议\chhighlight[comment=&#123;审阅意见10&#125;]&#123;\chreplaced&#123;balabala&#125;&#123;在保证效率的同时，&#125;&#125;极大提升了效果。</span><br></pre></td></tr></table></figure><p>效果：</p><p><img src="https://blogimages.happyshark.cn/%E4%B8%AD%E6%96%87latex%E8%AE%BA%E6%96%87%E4%BF%AE%E8%AE%A2%E6%96%B9%E6%B3%95%E6%B1%87%E6%80%BB/image-20250114104519595.png" alt="image-20250114104519595"></p><h2 id="颜色格式"><a href="#颜色格式" class="headerlink" title="颜色格式"></a>颜色格式</h2><p>如果对高亮的颜色有要求，也可以通过newcommand命令个性化设置，但是我一直没搞定批注的颜色设置，所以使用了changes包修订todo批注的方式。首先在导言区自定义包含颜色的高亮和批注：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">% 自定义批注颜色</span><br><span class="line">\newcommand&#123;\redtodo&#125;[2][]&#123;\todo[color=red!20, linecolor=red, bordercolor=red, size=tiny, #1]&#123;#2&#125;&#125;</span><br><span class="line">\newcommand&#123;\bluetodo&#125;[2][]&#123;\todo[color=blue!20, linecolor=blue, bordercolor=blue, #1]&#123;#2&#125;&#125;</span><br><span class="line"></span><br><span class="line">% 自定义高亮颜色</span><br><span class="line">\newcommand&#123;\coloredhighlight&#125;[2]&#123;%</span><br><span class="line">  \colorbox&#123;#1!20&#125;&#123;#2&#125;%</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后在正文中使用这个两个指令即可：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">\coloredhighlight&#123;red&#125;&#123;In the decentralized markets based on \chadded&#123;blockchain&#125;&#125;\redtodo[size=\tiny]&#123;意见9&#125;</span><br></pre></td></tr></table></figure><p>效果：</p><p><img src="https://blogimages.happyshark.cn/%E4%B8%AD%E6%96%87latex%E8%AE%BA%E6%96%87%E4%BF%AE%E8%AE%A2%E6%96%B9%E6%B3%95%E6%B1%87%E6%80%BB/image-20250114105118537.png" alt="image-20250114105118537"></p><h2 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h2><p>changes包对双栏的支持效果很不好，双栏的无论是使用changes内嵌的<code>comment</code>方法还是手动定义<code>todo</code>的方法都无法在边栏显示批注内容，我就卡在这里一直没法解决，被迫使用latexdiff指令的方法。</p><h1 id="latexdiff方式"><a href="#latexdiff方式" class="headerlink" title="latexdiff方式"></a>latexdiff方式</h1><p>因为我的论文是用overleaf写的，使用latexdiff必须要在本地配置一下latex环境，所以需要先安装texlive2024、texstudio、latexdiff，在进行比对生成diff文件，放进texstudio里渲染后手动高亮修改痕迹。</p><h2 id="安装texlive2024"><a href="#安装texlive2024" class="headerlink" title="安装texlive2024"></a>安装texlive2024</h2><ol><li><p>texlive官网下载安装包：<a href="https://tug.org/texlive/windows.html">https://tug.org/texlive/windows.html</a></p></li><li><p>使用简易安装<br><img src="https://blogimages.happyshark.cn/%E4%B8%AD%E6%96%87latex%E8%AE%BA%E6%96%87%E4%BF%AE%E8%AE%A2%E6%96%B9%E6%B3%95%E6%B1%87%E6%80%BB/image-20250114105742804.png" alt="image-20250114105742804"></p></li><li><p>选择install，一路next<br><img src="C:\Users\happy\AppData\Roaming\Typora\typora-user-images\image-20250114105822705.png" alt="image-20250114105822705"></p></li><li><p>修改路径，然后点安装（installation root 可以使用默认位置，这样环境变量和texstudio设置会很方便）<br><img src="https://blogimages.happyshark.cn/%E4%B8%AD%E6%96%87latex%E8%AE%BA%E6%96%87%E4%BF%AE%E8%AE%A2%E6%96%B9%E6%B3%95%E6%B1%87%E6%80%BB/image-20250114110034873.png" alt="image-20250114110034873"></p></li><li><p>安装过程时间会很久（20分钟+），等到所有安装包执行完毕，退出即可。然后再检查一下环境变量的path是否有texlive路径<br><img src="https://blogimages.happyshark.cn/%E4%B8%AD%E6%96%87latex%E8%AE%BA%E6%96%87%E4%BF%AE%E8%AE%A2%E6%96%B9%E6%B3%95%E6%B1%87%E6%80%BB/image-20250114110233321.png" alt="image-20250114110233321"></p><blockquote><p>这里的用户变量和系统变量里的path最好都添加上，否则会出现管理员运行就可以，非管理员运行报错的问题</p></blockquote></li><li><p>使用cmd验证是否安装成功<br><img src="https://blogimages.happyshark.cn/%E4%B8%AD%E6%96%87latex%E8%AE%BA%E6%96%87%E4%BF%AE%E8%AE%A2%E6%96%B9%E6%B3%95%E6%B1%87%E6%80%BB/image-20250114110414993.png" alt="image-20250114110414993"></p></li></ol><h2 id="安装texstudio"><a href="#安装texstudio" class="headerlink" title="安装texstudio"></a>安装texstudio</h2><ol><li>去texstudio官网：<a href="https://texstudio.sourceforge.net/">https://texstudio.sourceforge.net/</a> ，选择Windows installer下载<br><img src="https://blogimages.happyshark.cn/%E4%B8%AD%E6%96%87latex%E8%AE%BA%E6%96%87%E4%BF%AE%E8%AE%A2%E6%96%B9%E6%B3%95%E6%B1%87%E6%80%BB/image-20250114110722200.png" alt="image-20250114110722200"></li><li>运行texstudio安装程序，修改安装路径然后一路下一步就行。</li><li>打开texstudio，<code>选项-设置TeXstudio</code><br><img src="https://blogimages.happyshark.cn/%E4%B8%AD%E6%96%87latex%E8%AE%BA%E6%96%87%E4%BF%AE%E8%AE%A2%E6%96%B9%E6%B3%95%E6%B1%87%E6%80%BB/image-20250114111006211.png" alt="image-20250114111006211"></li><li>（可选步骤）选择<code>构建</code>，这里因为我是中文论文，默认的<code>pdflatex</code>用不了，所以需要手动修改成<code>Xelatex</code><br><img src="https://blogimages.happyshark.cn/%E4%B8%AD%E6%96%87latex%E8%AE%BA%E6%96%87%E4%BF%AE%E8%AE%A2%E6%96%B9%E6%B3%95%E6%B1%87%E6%80%BB/image-20250114111129468.png" alt="image-20250114111129468"></li><li>此时设置成功，就可以在本地使用latex编辑文件了，测试一下，编译通过<br><img src="https://blogimages.happyshark.cn/%E4%B8%AD%E6%96%87latex%E8%AE%BA%E6%96%87%E4%BF%AE%E8%AE%A2%E6%96%B9%E6%B3%95%E6%B1%87%E6%80%BB/image-20250114111220695.png" alt="image-20250114111220695"></li></ol><h2 id="安装strawberry-perl"><a href="#安装strawberry-perl" class="headerlink" title="安装strawberry perl"></a>安装strawberry perl</h2><ol><li>去strawberry perl官网下载msi包即可：<a href="https://strawberryperl.com/">https://strawberryperl.com/</a><br><img src="https://blogimages.happyshark.cn/%E4%B8%AD%E6%96%87latex%E8%AE%BA%E6%96%87%E4%BF%AE%E8%AE%A2%E6%96%B9%E6%B3%95%E6%B1%87%E6%80%BB/image-20250114111700740.png" alt="image-20250114111700740"></li><li>一路安装即可，路径可以自己设置，但我使用的是默认的。<br><img src="https://blogimages.happyshark.cn/%E4%B8%AD%E6%96%87latex%E8%AE%BA%E6%96%87%E4%BF%AE%E8%AE%A2%E6%96%B9%E6%B3%95%E6%B1%87%E6%80%BB/image-20250114111746020.png" alt="image-20250114111746020"></li></ol><h2 id="latexdiff使用"><a href="#latexdiff使用" class="headerlink" title="latexdiff使用"></a>latexdiff使用</h2><p>由于我的texlive2024自带了latexdiff，不需要额外进行安装。这里直接介绍如何使用latexdiff。</p><blockquote><p>latexdiff对中文路径支持很不好，使用的时候需要尤其注意中文路径的问题和编码问题！</p></blockquote><ol><li><p>先打开cmd，输入latexdiff看下是否正常使用<br><img src="https://blogimages.happyshark.cn/%E4%B8%AD%E6%96%87latex%E8%AE%BA%E6%96%87%E4%BF%AE%E8%AE%A2%E6%96%B9%E6%B3%95%E6%B1%87%E6%80%BB/image-20250114111911178.png" alt="image-20250114111911178"></p></li><li><p>将<code>old.tex</code>和<code>new.tex</code>放到同一个路径下，如果两个tex引用了同一个参考文献文件，需要手动修改其中的一个确保两个文件引用的是不一样的bib文件。</p><blockquote><p>比如old.tex文件里头的参考文献修改成<code>oldref.bib</code>，然后再把参考文献文件复制一份，重命名成<code>oldref.bib</code>，确保相同目录下同时有新旧论文tex文件和对应的新旧参考文献文件。</p></blockquote><p><img src="https://blogimages.happyshark.cn/%E4%B8%AD%E6%96%87latex%E8%AE%BA%E6%96%87%E4%BF%AE%E8%AE%A2%E6%96%B9%E6%B3%95%E6%B1%87%E6%80%BB/image-20250114112407264.png" alt="image-20250114112407264"></p></li><li><p>确认<code>old.tex</code>和<code>new.tex</code>文件是<strong>UTF-8</strong>编码，这一步很重要，否则latexdiff生成的是乱码，我这里用的是sublimetext（记事本也可以）</p><p><img src="https://blogimages.happyshark.cn/%E4%B8%AD%E6%96%87latex%E8%AE%BA%E6%96%87%E4%BF%AE%E8%AE%A2%E6%96%B9%E6%B3%95%E6%B1%87%E6%80%BB/image-20250114112619184.png" alt="image-20250114112619184"></p><p>如不是utf-8编码的话，就手动保存成utf-8编码即可<br><img src="https://blogimages.happyshark.cn/%E4%B8%AD%E6%96%87latex%E8%AE%BA%E6%96%87%E4%BF%AE%E8%AE%A2%E6%96%B9%E6%B3%95%E6%B1%87%E6%80%BB/image-20250114112831982.png" alt="image-20250114112831982"></p></li><li><p>使用latexdiff命令比较文件，输出到different.tex中，请注意，这个指令中不能有任何非英文字母，否则会报错</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">D:\lunwen\new&gt;latexdiff old.tex new.tex &gt; different.tex</span><br></pre></td></tr></table></figure></li><li><p>得到different.tex文件之后，<strong>先不要</strong>在texstudio中打开进行编译，因为此时<code>different.tex</code>是utf-16编码，导入到texstudio就乱码了，像这样：<br><img src="https://blogimages.happyshark.cn/%E4%B8%AD%E6%96%87latex%E8%AE%BA%E6%96%87%E4%BF%AE%E8%AE%A2%E6%96%B9%E6%B3%95%E6%B1%87%E6%80%BB/8e67dca52d0316926899f2e9a533e8d.png" alt="8e67dca52d0316926899f2e9a533e8d"></p></li><li><p><strong>在sublimetext中打开<code>different.tex</code>文件，按照步骤3的方式修改一下这个文件的编码为utf-8然后保存。</strong></p></li><li><p>然后在texstudio里打开，就是正常的了</p><p><img src="https://blogimages.happyshark.cn/%E4%B8%AD%E6%96%87latex%E8%AE%BA%E6%96%87%E4%BF%AE%E8%AE%A2%E6%96%B9%E6%B3%95%E6%B1%87%E6%80%BB/image-20250114113607125.png" alt="image-20250114113607125"></p></li><li><p>编译通过！但是很多地方会有奇怪的换行问题，只能用<code>\\</code>(公式里用<code>\allowbreak</code>)手动控制换行（酸爽*1）<br><img src="https://blogimages.happyshark.cn/%E4%B8%AD%E6%96%87latex%E8%AE%BA%E6%96%87%E4%BF%AE%E8%AE%A2%E6%96%B9%E6%B3%95%E6%B1%87%E6%80%BB/image-20250114114043199.png" alt="image-20250114114043199"></p></li><li><p>然后在打开pdf编辑器（different.pdf一定要备份！），手动高亮，添加注释（酸爽*2）<br><img src="https://blogimages.happyshark.cn/%E4%B8%AD%E6%96%87latex%E8%AE%BA%E6%96%87%E4%BF%AE%E8%AE%A2%E6%96%B9%E6%B3%95%E6%B1%87%E6%80%BB/image-20250114125000209.png" alt="image-20250114125000209"></p><blockquote><p>如果有返工的话建议直接在这个版本上改，不然会重复5-9步，工作量超级加倍</p></blockquote></li></ol>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> latex </tag>
            
            <tag> changes </tag>
            
            <tag> latexdiff </tag>
            
            <tag> 乱码 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>dblp rss转换器部署</title>
      <link href="/2024/12/09/dblp%20rss%E8%BD%AC%E6%8D%A2%E5%99%A8%E9%83%A8%E7%BD%B2/"/>
      <url>/2024/12/09/dblp%20rss%E8%BD%AC%E6%8D%A2%E5%99%A8%E9%83%A8%E7%BD%B2/</url>
      
        <content type="html"><![CDATA[<hr><p>dblp默认的前100条只有xml和json格式，zotero识别不了，github上有个开源项目可以将DBLP的api返回结果转换成RSS格式，方便zotero识别。</p><p>项目地址：<a href="https://github.com/Pantoofle/dblp-rss">Pantoofle/dblp-rss: A quick and dirty RSS server to translate DBLP API results to a standard RSS flux</a></p><h2 id="服务器配置过程"><a href="#服务器配置过程" class="headerlink" title="服务器配置过程"></a>服务器配置过程</h2><h3 id="开启防火墙"><a href="#开启防火墙" class="headerlink" title="开启防火墙"></a>开启防火墙</h3><p>如果是走cloudflarecdn的话只能是以下几个端口，这里使用2083：</p><p><strong>Cloudflare 支持的 HTTP 端口：</strong></p><ul><li>80</li><li>8080</li><li>8880</li><li>2052</li><li>2082</li><li>2086</li><li>2095</li></ul><p><strong>Cloudflare 支持的 HTTPS 端口：</strong></p><ul><li>443</li><li>2053</li><li>2083</li><li>2087</li><li>2096</li><li>8443</li></ul><h4 id="使用firewalld"><a href="#使用firewalld" class="headerlink" title="使用firewalld"></a>使用firewalld</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install firewalld</span><br><span class="line">sudo firewall-cmd --zone=public --permanent \</span><br><span class="line">--add-port=22/tcp --add-port=22/udp \</span><br><span class="line">--add-port=80/tcp --add-port=80/udp \</span><br><span class="line">--add-port=8080/tcp --add-port=8080/udp \</span><br><span class="line">--add-port=443/tcp --add-port=443/udp \</span><br><span class="line">--add-port=2053/tcp --add-port=2053/udp \</span><br><span class="line">--add-port=2083/tcp --add-port=2083/udp \</span><br><span class="line">--add-port=8087/tcp --add-port=8087/udp \</span><br><span class="line">--add-port=2096/tcp --add-port=2096/udp \</span><br><span class="line">--add-port=8443/tcp --add-port=8443/udp</span><br><span class="line">sudo firewall-cmd --reload</span><br></pre></td></tr></table></figure><blockquote><p>查看防火墙状态：sudo firewall-cmd —zone=public —list-ports</p><p>查看防火墙当前规则：sudo firewall-cmd —list-all</p><p>确认特定端口是否开放：sudo firewall-cmd —zone=public —query-port=8080/tcp</p></blockquote><h4 id="使用x-ui自带的iptables管理工具"><a href="#使用x-ui自带的iptables管理工具" class="headerlink" title="使用x-ui自带的iptables管理工具"></a>使用x-ui自带的iptables管理工具</h4><p>输入<code>x-ui</code>选择21，开启防火墙并放行端口，将上述端口放行即可</p><h3 id="安装docker"><a href="#安装docker" class="headerlink" title="安装docker"></a>安装docker</h3><p>使用runoob教程的方案，地址：<a href="https://www.runoob.com/docker/ubuntu-docker-install.html">Ubuntu Docker 安装 | 菜鸟教程</a></p><ol><li><p>安装docker</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">curl -fsSL https://test.docker.com -o test-docker.sh</span><br><span class="line">sudo sh test-docker.sh</span><br></pre></td></tr></table></figure></li><li><p>测试Helloworld：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run ubuntu:15.10 /bin/echo &quot;Hello world&quot;</span><br></pre></td></tr></table></figure></li></ol><h3 id="安装dblp-rss"><a href="#安装dblp-rss" class="headerlink" title="安装dblp-rss"></a>安装dblp-rss</h3><ol><li><p>克隆项目代码</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/Pantoofle/dblp-rss.git</span><br></pre></td></tr></table></figure></li><li><p>进入项目目录，构建 Docker 镜像</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd dblp-rss</span><br><span class="line">docker build -t dblp-rss .</span><br></pre></td></tr></table></figure></li><li><p>运行 Docker 容器</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -d -p 8080:8080 --restart always --name dblp-rss dblp-rss</span><br></pre></td></tr></table></figure><blockquote><p><code>-p 8080:8080</code>：将服务器的 2083 端口映射到容器的 80 端口。</p><p><code>--restart always</code>：设置容器在意外退出时自动重启。</p><p><code>--name dblp-rss</code>：将容器命名为 <code>dblp-rss</code>。</p></blockquote></li><li><p>验证运行状态</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker ps</span><br></pre></td></tr></table></figure><p>确认 <code>dblp-rss</code> 容器正在运行，并且 <code>PORTS</code> 列显示 <code>0.0.0.0:2083-&gt;80/tcp</code>。</p></li><li><p>访问：<a href="http://ip:8080/dblp/">http://ip:8080/dblp/</a><keyword></p></li></ol><blockquote><p>查看日志：docker logs dblp-rss</p><p>重启容器：docker start dblp-rss</p><p>停止容器：docker stop dblp-rss</p><p>删除容器，但不删除镜像和数据：docker rm dblp-rss</p><p>删除镜像：docker rmi dblp-rss</p><p>查看所有容器（包括停止的）：docker ps -a</p><p>一键启动：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker build -t dblp-rss .</span><br><span class="line">docker run -d -p 8080:8080 --restart always --name dblp-rss dblp-rss</span><br></pre></td></tr></table></figure><p>一键删除：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">docker stop dblp-rss</span><br><span class="line">docker rm dblp-rss</span><br><span class="line">docker rmi dblp-rss</span><br></pre></td></tr></table></figure></blockquote><h2 id="cloudflare配置ssl"><a href="#cloudflare配置ssl" class="headerlink" title="cloudflare配置ssl"></a>cloudflare配置ssl</h2><p>一般情况下网站的SSL/TLS 全局加密模式为：完全（严格），这里通过特殊规则的形式为dblp rss配置单独ssl。</p><ol><li>dns设置域名，比如dblp.xxx.xxx，并<strong>开启</strong>cdn小云朵代理。</li><li><p><code>规则-origin rules</code>里头新建一个dblp规则，进行如下配置，将页面访问的443端口重定向到8080：</p><ul><li>选择<code>自定义筛选表达式</code></li><li>字段：主机名</li><li>运算符：等于</li><li>值填写：dblp.xxx.xxx</li><li>目标端口重写到：8080</li><li>保存</li></ul></li><li><p><code>规则-页面规则</code>里新建一个规则，将该域名的ssl配置修改为<code>灵活</code>：</p><ul><li>URL：dblp.xxx.xxx</li><li>选取设置：SSL</li><li>选择 SSL/TLS 加密模式：灵活</li><li>保存页面规则</li></ul></li><li>访问：<a href="https://dblp.xxx.xxx/dblp/">https://dblp.xxx.xxx/dblp/</a><keyword></li></ol>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> rss </tag>
            
            <tag> dblp cloudflare </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>甲骨文x-ui搭建过程笔记</title>
      <link href="/2024/12/02/%E7%94%B2%E9%AA%A8%E6%96%87%E6%A2%AF%E5%AD%90%E6%90%AD%E5%BB%BA%E8%BF%87%E7%A8%8B/"/>
      <url>/2024/12/02/%E7%94%B2%E9%AA%A8%E6%96%87%E6%A2%AF%E5%AD%90%E6%90%AD%E5%BB%BA%E8%BF%87%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<hr><h2 id="甲骨文开台机子"><a href="#甲骨文开台机子" class="headerlink" title="甲骨文开台机子"></a>甲骨文开台机子</h2><p>此处略过，注意主机选择ubuntu2004</p><p>防火墙相关：<a href="https://woodchen.ink/archives/hard-core-tutorial-oracle-cloud-oracle-cloud-settings-settings-that-the-security-group-is-still-unable-to-access-z2ealvo">「硬核教程」Oracle Cloud甲骨文云设定安全组仍无法访问的解决办法-Wood Chen</a></p><p>注意开放22,80,443,2053,2083,8087,2096,8443</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install firewalld</span><br><span class="line">sudo firewall-cmd --zone=public --permanent \</span><br><span class="line">--add-port=22/tcp --add-port=22/udp \</span><br><span class="line">--add-port=80/tcp --add-port=80/udp \</span><br><span class="line">--add-port=443/tcp --add-port=443/udp \</span><br><span class="line">--add-port=2053/tcp --add-port=2053/udp \</span><br><span class="line">--add-port=2083/tcp --add-port=2083/udp \</span><br><span class="line">--add-port=8087/tcp --add-port=8087/udp \</span><br><span class="line">--add-port=2096/tcp --add-port=2096/udp \</span><br><span class="line">--add-port=8443/tcp --add-port=8443/udp</span><br><span class="line">sudo firewall-cmd --reload</span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><p>查看防火墙状态：sudo firewall-cmd —zone=public —list-ports</p><p>查看防火墙当前规则：sudo firewall-cmd —list-all</p><p>确认特定端口是否开放：sudo firewall-cmd —zone=public —query-port=2083/tcp</p></blockquote><h2 id="系统初始化配置"><a href="#系统初始化配置" class="headerlink" title="系统初始化配置"></a>系统初始化配置</h2><ol><li><p>设置时间：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo timedatectl set-timezone Asia/Shanghai</span><br><span class="line">sudo hwclock --systohc</span><br></pre></td></tr></table></figure></li><li><p>安装3x-ui：<a href="https://github.com/xeefei/3x-ui">xeefei/3x-ui: 〔3X-UI〕中文优化版</a></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bash &lt;(curl -Ls https://raw.githubusercontent.com/xeefei/3x-ui/master/install.sh)</span><br></pre></td></tr></table></figure></li><li><p>配置ssl<br>先在cloudflare添加解析，确保能ping</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sudo systemd-resolve --statistics #查看当前缓存</span><br><span class="line">sudo systemd-resolve --flush-caches #刷新缓存</span><br><span class="line"></span><br><span class="line">输入x-ui，申请ssl证书</span><br></pre></td></tr></table></figure></li><li><p>进入面板，配置面板ssl，配置订阅ssl</p><blockquote><p>注意面板的地址挂小黄云代理，订阅ssl不挂小黄云代理</p></blockquote></li><li><p>建两个协议<br>vless+vision+reality：正常配置<br>vless+ws+tls：地址写面板地址，得添加请求头host，min/ max version改为1.1-1.3，删除所有alpn，并allow insecure，证书选择面板证书</p></li><li><p>安装warp：<a href="https://gitlab.com/fscarmen/warp">fscarmen / warp · GitLab</a>，选择安装 WireProxy</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget -N https://gitlab.com/fscarmen/warp/-/raw/main/menu.sh &amp;&amp; bash menu.sh [option] [lisence/url/token]</span><br></pre></td></tr></table></figure></li><li><p>配置面板出入站：xray设置-高级设置</p><ul><li><p>出站规则</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">  &#123;</span><br><span class="line">    &quot;tag&quot;: &quot;direct&quot;,</span><br><span class="line">    &quot;protocol&quot;: &quot;freedom&quot;</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    &quot;tag&quot;: &quot;warp&quot;,</span><br><span class="line">    &quot;protocol&quot;: &quot;socks&quot;,</span><br><span class="line">    &quot;settings&quot;: &#123;</span><br><span class="line">      &quot;servers&quot;: [</span><br><span class="line">        &#123;</span><br><span class="line">          &quot;address&quot;: &quot;127.0.0.1&quot;,</span><br><span class="line">          &quot;port&quot;: 40000</span><br><span class="line">        &#125;</span><br><span class="line">      ]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    &quot;tag&quot;: &quot;WARP-socks5-v4&quot;,</span><br><span class="line">    &quot;protocol&quot;: &quot;freedom&quot;,</span><br><span class="line">    &quot;settings&quot;: &#123;</span><br><span class="line">      &quot;domainStrategy&quot;: &quot;UseIPv4&quot;</span><br><span class="line">    &#125;,</span><br><span class="line">    &quot;proxySettings&quot;: &#123;</span><br><span class="line">      &quot;tag&quot;: &quot;warp&quot;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    &quot;tag&quot;: &quot;WARP-socks5-v6&quot;,</span><br><span class="line">    &quot;protocol&quot;: &quot;freedom&quot;,</span><br><span class="line">    &quot;settings&quot;: &#123;</span><br><span class="line">      &quot;domainStrategy&quot;: &quot;UseIPv6&quot;</span><br><span class="line">    &#125;,</span><br><span class="line">    &quot;proxySettings&quot;: &#123;</span><br><span class="line">      &quot;tag&quot;: &quot;warp&quot;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    &quot;tag&quot;: &quot;blocked&quot;,</span><br><span class="line">    &quot;protocol&quot;: &quot;blackhole&quot;,</span><br><span class="line">    &quot;settings&quot;: &#123;&#125;</span><br><span class="line">  &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure></li><li><p>路由规则：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">  &#123;</span><br><span class="line">    &quot;type&quot;: &quot;field&quot;,</span><br><span class="line">    &quot;inboundTag&quot;: [</span><br><span class="line">      &quot;api&quot;</span><br><span class="line">    ],</span><br><span class="line">    &quot;outboundTag&quot;: &quot;api&quot;</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    &quot;type&quot;: &quot;field&quot;,</span><br><span class="line">    &quot;outboundTag&quot;: &quot;blocked&quot;,</span><br><span class="line">    &quot;ip&quot;: [</span><br><span class="line">      &quot;geoip:private&quot;</span><br><span class="line">    ]</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    &quot;type&quot;: &quot;field&quot;,</span><br><span class="line">    &quot;outboundTag&quot;: &quot;blocked&quot;,</span><br><span class="line">    &quot;protocol&quot;: [</span><br><span class="line">      &quot;bittorrent&quot;</span><br><span class="line">    ]</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    &quot;type&quot;: &quot;field&quot;,</span><br><span class="line">    &quot;domain&quot;: [</span><br><span class="line">      &quot;ip.sb&quot;//走ipv4的地址</span><br><span class="line">    ],</span><br><span class="line">    &quot;outboundTag&quot;: &quot;WARP-socks5-v4&quot;</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    &quot;type&quot;: &quot;field&quot;,</span><br><span class="line">    &quot;domain&quot;: [</span><br><span class="line">      &quot;geosite:netflix&quot;,//走ipv6的地址</span><br><span class="line">      &quot;geosite:openai&quot;,</span><br><span class="line">      &quot;p3terx.com&quot;,</span><br><span class="line">      &quot;ip111.cn&quot;,</span><br><span class="line">      &quot;ip.gs&quot;</span><br><span class="line">    ],</span><br><span class="line">    &quot;outboundTag&quot;: &quot;WARP-socks5-v6&quot;</span><br><span class="line">  &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure></li></ul></li></ol><h2 id="时间设置"><a href="#时间设置" class="headerlink" title="时间设置"></a>时间设置</h2><ol><li>首先输入</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">date -R1.</span><br></pre></td></tr></table></figure><p>查看当下系统时间是否一致。</p><ol><li>设置时区，亚洲/上海：</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo timedatectl set-timezone Asia/Shanghai1.</span><br></pre></td></tr></table></figure><ol><li>将当前时间写入BIOS避免重启之后失效：</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo hwclock --systohc1.</span><br></pre></td></tr></table></figure><ol><li>再次查看日期是否更改成功</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">date -R</span><br></pre></td></tr></table></figure><h2 id="cloudflare设置"><a href="#cloudflare设置" class="headerlink" title="cloudflare设置"></a>cloudflare设置</h2><p>由于订阅的地址无法修改，都是xxx.xxx.com，但是两个协议只想让reality访问直连域名（443端口），ws+tls（8443端口，自己改优选ip才能使用）需要阻断以保证vps安全性，故还需配置cloudflare</p><p>待定，目前关闭reality，只是用ws+tls</p><h2 id="只允许域名，不允许ip访问"><a href="#只允许域名，不允许ip访问" class="headerlink" title="只允许域名，不允许ip访问"></a>只允许域名，不允许ip访问</h2><p>在x-ui的<code>面板设置</code>-<code>常规</code>里面的面板监听域名处填写访问的域名即可</p><blockquote><p>慎重，因为一旦域名网站进不去就寄了</p></blockquote><h2 id="防火墙设置"><a href="#防火墙设置" class="headerlink" title="防火墙设置"></a>防火墙设置</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">#开放端口</span><br><span class="line">firewall-cmd  --add-port=5672/tcp</span><br><span class="line">#永久开放端口</span><br><span class="line">firewall-cmd  --add-port=2083/tcp --permanent </span><br><span class="line">firewall-cmd  --add-port=2083/udp --permanent </span><br><span class="line">#关闭端口</span><br><span class="line">firewall-cmd  --remove-port=5672/tcp --permanent</span><br><span class="line"># 配置立即生效</span><br><span class="line">firewall-cmd --reload</span><br><span class="line"></span><br><span class="line">#查看防火墙</span><br><span class="line">firewall-cmd --list-all</span><br><span class="line">#查看防火墙所有开放的端口</span><br><span class="line">firewall-cmd --zone=public --list-ports</span><br><span class="line"></span><br><span class="line">#启动Firewalld服务：</span><br><span class="line">sudo systemctl start firewalld</span><br><span class="line"></span><br><span class="line">#停止Firewalld服务：</span><br><span class="line">sudo systemctl stop firewalld</span><br><span class="line"></span><br><span class="line">#重新启动Firewalld服务：</span><br><span class="line">sudo systemctl restart firewalld</span><br><span class="line"></span><br><span class="line">#查看Firewalld状态：</span><br><span class="line">sudo systemctl status firewalld</span><br><span class="line"></span><br><span class="line">#开机自启Firewalld服务：</span><br><span class="line">sudo systemctl enable firewalld</span><br><span class="line"></span><br><span class="line">#禁止Firewalld开机自启：</span><br><span class="line">sudo systemctl disable firewalld</span><br></pre></td></tr></table></figure><h2 id="bbr-cake加速"><a href="#bbr-cake加速" class="headerlink" title="bbr+cake加速"></a>bbr+cake加速</h2><h2 id="安装锐速-BBR-cake"><a href="#安装锐速-BBR-cake" class="headerlink" title="安装锐速 BBR+cake"></a>安装<del>锐速</del> BBR+cake</h2><p><strong>支持系统：</strong><code>Centos 6+</code>/<code>Debian 7+</code>/<code>Ubuntu 14+</code>，<code>BBR</code> 魔改版不支持 <code>Debian 8</code>。<br><strong>注意：</strong>该脚本在 <code>Vultr</code> 各个系统均测试通过，如果期间有出现任何问题，可向原作者反映帮助改善。<br>运行以下命令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget -N --no-check-certificate &quot;https://github.com/ylx2016/Linux-NetSpeed/raw/master/tcp.sh&quot; &amp;&amp; chmod +x tcp.sh &amp;&amp; ./tcp.sh</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 技术 </tag>
            
            <tag> 网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>windows部署ubuntu wsl2子系统并调用windows GPU</title>
      <link href="/2024/05/28/windows%E9%83%A8%E7%BD%B2ubuntu%20wsl2%E5%AD%90%E7%B3%BB%E7%BB%9F%E5%B9%B6%E8%B0%83%E7%94%A8windows%20GPU/"/>
      <url>/2024/05/28/windows%E9%83%A8%E7%BD%B2ubuntu%20wsl2%E5%AD%90%E7%B3%BB%E7%BB%9F%E5%B9%B6%E8%B0%83%E7%94%A8windows%20GPU/</url>
      
        <content type="html"><![CDATA[<hr><hr><p>最近天天想跑一下github上的热门repo，实验室的电脑太少了导致不得不充分利用一下工位上的windwos电脑，把windows部署docker并跑wsl2调GPU的过程总结一下~</p><h1 id="安装前提"><a href="#安装前提" class="headerlink" title="安装前提"></a>安装前提</h1><ul><li>需要win10 22H2或win11 pro以上的版本</li><li>需要将nvidia更新为最新的驱动</li></ul><h1 id="安装docker-desktop"><a href="#安装docker-desktop" class="headerlink" title="安装docker desktop"></a>安装docker desktop</h1><ol><li><p>Docker下载地址：<a href="https://www.docker.com/get-started/">docker官网下载地址</a><br><img src="https://blogimages.happyshark.cn/windows部署ubuntu-wsl2子系统并调用windows-GPU/aa5fd0b0411b470693b3dc2ce03aa54c.png" alt="在这里插入图片描述"></p></li><li><p>启用hyper-v：<a href="https://docs.microsoft.com/zh-cn/virtualization/hyper-v-on-windows/quick-start/enable-hyper-v">微软教程官网</a>。<br><img src="https://blogimages.happyshark.cn/windows%E9%83%A8%E7%BD%B2ubuntu-wsl2%E5%AD%90%E7%B3%BB%E7%BB%9F%E5%B9%B6%E8%B0%83%E7%94%A8windows-GPU/68169e17ba0849f8bedfd760ab4598c0.png" alt="在这里插入图片描述"></p><p><img src="https://blogimages.happyshark.cn/windows%E9%83%A8%E7%BD%B2ubuntu-wsl2%E5%AD%90%E7%B3%BB%E7%BB%9F%E5%B9%B6%E8%B0%83%E7%94%A8windows-GPU/41e7a15adce54a278dc9148f24d59f5b.png" alt="在这里插入图片描述"><br><img src="https://blogimages.happyshark.cn/windows%E9%83%A8%E7%BD%B2ubuntu-wsl2%E5%AD%90%E7%B3%BB%E7%BB%9F%E5%B9%B6%E8%B0%83%E7%94%A8windows-GPU/c32129b0a7e54b45b10b6935135be218.png" alt="在这里插入图片描述"></p></li><li><p>Shift + Ctrl + ESC 启动任务管理器，查看<code>性能-虚拟化</code>是否启用。<br><img src="https://blogimages.happyshark.cn/windows%E9%83%A8%E7%BD%B2ubuntu-wsl2%E5%AD%90%E7%B3%BB%E7%BB%9F%E5%B9%B6%E8%B0%83%E7%94%A8windows-GPU/fec8ecc8d51442e9b38eae0f10c1e975.png" alt="在这里插入图片描述"></p></li><li><p>安装docker<br><img src="https://blogimages.happyshark.cn/windows%E9%83%A8%E7%BD%B2ubuntu-wsl2%E5%AD%90%E7%B3%BB%E7%BB%9F%E5%B9%B6%E8%B0%83%E7%94%A8windows-GPU/image-20240528162625523.png" alt="image-20240528162625523"></p><blockquote><p>如果需要配置docker镜像加速，推荐阿里云：<a href="https://cr.console.aliyun.com/cn-hangzhou/instances/mirrors">容器镜像服务 (aliyun.com)</a></p></blockquote></li></ol><h1 id="安装wsl2"><a href="#安装wsl2" class="headerlink" title="安装wsl2"></a>安装wsl2</h1><h2 id="执行以下命令-将wsl升级为wsl2："><a href="#执行以下命令-将wsl升级为wsl2：" class="headerlink" title="执行以下命令, 将wsl升级为wsl2："></a>执行以下命令, 将wsl升级为wsl2：</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">wsl --update</span><br><span class="line">wsl --set-default-version 2</span><br></pre></td></tr></table></figure><p>执行以下命令确认版本均为2：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wsl -l -v </span><br></pre></td></tr></table></figure></p><p><img src="https://blogimages.happyshark.cn/windows%E9%83%A8%E7%BD%B2ubuntu-wsl2%E5%AD%90%E7%B3%BB%E7%BB%9F%E5%B9%B6%E8%B0%83%E7%94%A8windows-GPU/image-20240528172427389.png" alt="image-20240528172427389"></p><h2 id="安装linux子系统"><a href="#安装linux子系统" class="headerlink" title="安装linux子系统"></a>安装linux子系统</h2><ol><li>打开微软商店。搜索【Ubuntu】或【linux】都可以，安装tls长期支持版即可。<br><img src="https://blogimages.happyshark.cn/windows%E9%83%A8%E7%BD%B2ubuntu-wsl2%E5%AD%90%E7%B3%BB%E7%BB%9F%E5%B9%B6%E8%B0%83%E7%94%A8windows-GPU/image-20240528172610644.png" alt="image-20240528172610644"></li><li>打开子系统并进行配置<br><img src="https://blogimages.happyshark.cn/windows%E9%83%A8%E7%BD%B2ubuntu-wsl2%E5%AD%90%E7%B3%BB%E7%BB%9F%E5%B9%B6%E8%B0%83%E7%94%A8windows-GPU/8d2f32885cd440d1a9f7d0f2249adb41.png" alt="在这里插入图片描述"></li><li>设置默认使用root登录<br>管理员权限打开【powershell】<br>运行：<code>ubuntu2004.exe config --default-user root</code><br><img src="https://blogimages.happyshark.cn/windows%E9%83%A8%E7%BD%B2ubuntu-wsl2%E5%AD%90%E7%B3%BB%E7%BB%9F%E5%B9%B6%E8%B0%83%E7%94%A8windows-GPU/22ec365c2e3a49eb863f94f6613f52d0.png" alt="在这里插入图片描述"><br>然后再打开的时候就可以看到默认登录用户为【root】。<br><img src="https://blogimages.happyshark.cn/windows%E9%83%A8%E7%BD%B2ubuntu-wsl2%E5%AD%90%E7%B3%BB%E7%BB%9F%E5%B9%B6%E8%B0%83%E7%94%A8windows-GPU/e6ac5e1e64c348ad9d2b0d42345bb255.png" alt="在这里插入图片描述"></li><li>将Ubuntu2004设置为默认wsl，执行<code>wslconfig /setdefault Ubuntu-20.04</code><br><img src="https://blogimages.happyshark.cn/windows%E9%83%A8%E7%BD%B2ubuntu-wsl2%E5%AD%90%E7%B3%BB%E7%BB%9F%E5%B9%B6%E8%B0%83%E7%94%A8windows-GPU/image-20240528203453444.png" alt="image-20240528203453444"></li><li>docker配置ubuntu20.04 LTS<br><img src="https://blogimages.happyshark.cn/windows部署ubuntu-wsl2子系统并调用windows-GPU/9f6b7a93620c42dca28b80019e3e31f0.png" alt="在这里插入图片描述"><br><img src="https://blogimages.happyshark.cn/windows%E9%83%A8%E7%BD%B2ubuntu-wsl2%E5%AD%90%E7%B3%BB%E7%BB%9F%E5%B9%B6%E8%B0%83%E7%94%A8windows-GPU/0bfebde60dc14a579cf621bce9d6bef2.png" alt="在这里插入图片描述"></li></ol><h1 id="配置ssh链接"><a href="#配置ssh链接" class="headerlink" title="配置ssh链接"></a>配置ssh链接</h1><p>因为有局域网访问的需求，故需要配置远程ssh链接。</p><ol><li><p>打开powershell，执行代码，其中<code>172.27.155.153</code>是wsl的dockerIP</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">netsh interface portproxy add v4tov4 listenaddress=0.0.0.0 listenport=2222 connectaddress=172.27.155.153 connectport=22</span><br></pre></td></tr></table></figure><blockquote><p>listenport不要设为22，否则会有bug</p></blockquote></li><li><p>查看windows宿主机端口转发情况：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">netsh interface portproxy show all</span><br></pre></td></tr></table></figure><p><img src="https://blogimages.happyshark.cn/windows%E9%83%A8%E7%BD%B2ubuntu-wsl2%E5%AD%90%E7%B3%BB%E7%BB%9F%E5%B9%B6%E8%B0%83%E7%94%A8windows-GPU/image-20240529193206740.png" alt="image-20240529193206740"></p></li><li><p>当然，如果配置错的话可以删除：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">netsh interface portproxy delete v4tov4 listenaddress=0.0.0.0 listenport=2222</span><br></pre></td></tr></table></figure></li></ol><h1 id="GPU的使用"><a href="#GPU的使用" class="headerlink" title="GPU的使用"></a>GPU的使用</h1><ol><li><p>请确保打开开发人员模式</p><p><img src="https://blogimages.happyshark.cn/windows%E9%83%A8%E7%BD%B2ubuntu-wsl2%E5%AD%90%E7%B3%BB%E7%BB%9F%E5%B9%B6%E8%B0%83%E7%94%A8windows-GPU/image-20240529091738047.png" alt="image-20240529091738047"></p></li><li><p>windows更新到最新版本，并开启可选更新<br><img src="https://blogimages.happyshark.cn/windows%E9%83%A8%E7%BD%B2ubuntu-wsl2%E5%AD%90%E7%B3%BB%E7%BB%9F%E5%B9%B6%E8%B0%83%E7%94%A8windows-GPU/image-20240529091903162.png" alt="image-20240529091903162"><br><img src="https://blogimages.happyshark.cn/windows%E9%83%A8%E7%BD%B2ubuntu-wsl2%E5%AD%90%E7%B3%BB%E7%BB%9F%E5%B9%B6%E8%B0%83%E7%94%A8windows-GPU/image-20240529091937321.png" alt="image-20240529091937321"></p></li><li><p>显卡驱动下载<br>首先需要安装显卡驱动，<a href="https://www.nvidia.cn/Download/index.aspx?lang=cn">NVIDIA官网下载地址</a>。<br>找到自己的显卡型号下载安装即可。<br><img src="https://blogimages.happyshark.cn/windows%E9%83%A8%E7%BD%B2ubuntu-wsl2%E5%AD%90%E7%B3%BB%E7%BB%9F%E5%B9%B6%E8%B0%83%E7%94%A8windows-GPU/image-20240528174134569.png" alt="image-20240528174134569"></p></li><li><p>CUDA For WSL<br>驱动下载：<a href="https://docs.microsoft.com/zh-cn/windows/ai/directml/gpu-cuda-in-wsl">NVIDIA官网文档</a>，找到对应版本下载安装即可。<br><img src="https://blogimages.happyshark.cn/windows%E9%83%A8%E7%BD%B2ubuntu-wsl2%E5%AD%90%E7%B3%BB%E7%BB%9F%E5%B9%B6%E8%B0%83%E7%94%A8windows-GPU/image-20240528174213939.png" alt="image-20240528174213939"></p></li><li><p>在Ubuntu中安装cuda toolkit<br><a href="https://developer.nvidia.com/cuda-toolkit-archive">CUDA Toolkit Archive | NVIDIA Developer</a>在这里找对应的版本，选择x86_64 ws-ubuntu系统选择对应的安装方式即可。</p></li><li><p>配置权限</p><p>完成第三步后如果用root账户登录直接置执行<code>nvidia-smi</code>可以正常使用cuda，但是用普通账户会报错<code>Command &#39;nvidia-smi&#39; not found, but can be installed with:xxx</code>，如果需要用普通账户访问需要还需要配置权限，执行以下梁行代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cp /usr/lib/wsl/lib/nvidia-smi /usr/bin/nvidia-smi</span><br><span class="line">chmod ogu+x /usr/bin/nvidia-smi</span><br></pre></td></tr></table></figure><p>然后在执行<code>nvidia-smi</code>配置成功~<br><img src="https://blogimages.happyshark.cn/windows%E9%83%A8%E7%BD%B2ubuntu-wsl2%E5%AD%90%E7%B3%BB%E7%BB%9F%E5%B9%B6%E8%B0%83%E7%94%A8windows-GPU/image-20240529091424235.png" alt="image-20240529091424235"></p></li></ol>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> docker </tag>
            
            <tag> wsl2 </tag>
            
            <tag> nvidia-smi </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>语法大学习</title>
      <link href="/2023/10/24/%E8%AF%AD%E6%B3%95%E5%A4%A7%E5%AD%A6%E4%B9%A0/"/>
      <url>/2023/10/24/%E8%AF%AD%E6%B3%95%E5%A4%A7%E5%AD%A6%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<hr><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>本文是为了记录一下本人在论文之路上遇到的各种奇怪的语法问题，高中不好好学语文，现在被迫承受语法暴击。感谢师兄/师姐/同门对我稀烂语文语文水平的包容。</p><h1 id="中文语法"><a href="#中文语法" class="headerlink" title="中文语法"></a>中文语法</h1><h2 id="形容词需要有主语描述"><a href="#形容词需要有主语描述" class="headerlink" title="形容词需要有主语描述"></a>形容词需要有主语描述</h2><div class="table-container"><table><thead><tr><th>错误</th><th>正确</th><th>原因</th></tr></thead><tbody><tr><td>一个满足选择明文攻击下不可区分(Indistinguishability under Chosen Plaintext Attack,IND-CPA)的对称认证加密方案</td><td>一个满足选择明文攻击下<code>密文</code>不可区分(Indistinguishability under Chosen Plaintext Attack,IND-CPA)的对称认证加密方案</td><td>什么不可区分，当然是密文</td></tr></tbody></table></div><h2 id="动词的主语不要丢"><a href="#动词的主语不要丢" class="headerlink" title="动词的主语不要丢"></a>动词的主语不要丢</h2><div class="table-container"><table><thead><tr><th>错误</th><th>正确</th><th>原因</th></tr></thead><tbody><tr><td>双方随机选择一个密钥对需要交换的秘密$dx$和$dy$加密</td><td>双方<code>分别</code>随机选择一个密钥<code>，并对各自</code>需要交换的秘密$dx$和$dy$加密<code>.</code></td><td>双方是选择一个密钥呢还是分别整两个密钥呢</td></tr></tbody></table></div><h2 id="动词问题"><a href="#动词问题" class="headerlink" title="动词问题"></a>动词问题</h2><div class="table-container"><table><thead><tr><th>错误</th><th>正确</th><th>原因</th></tr></thead><tbody><tr><td>代理合约的权限管理功能确保只有授权的参与方可以更新合约,进一步增强了系统的安全性.</td><td>代理合约的权限管理功能<code>确保了</code>只有授权的参与方可以更新合约,进一步增强了系统的安全性.</td><td>确保/确保了…</td></tr></tbody></table></div><h2 id="宾语问题"><a href="#宾语问题" class="headerlink" title="宾语问题"></a>宾语问题</h2><div class="table-container"><table><thead><tr><th>错误</th><th>正确</th><th>原因</th></tr></thead><tbody><tr><td>本文将参考于雷等人[38]提出的链上公平交换方案思路,Alex等人[7]方案的基础上构造链下部分的密钥公平交换方案,以实现在不显著增加链上开销的情况下对已有原子贷款协议进行扩展.</td><td>本文将参考于雷等人[38]提出的链上公平交换方案思路,Alex等人[7]方案的基础上构造链下部分的密钥公平交换方案,以实现在不显著增加链上开销的情况下对已有原子贷款协议<code>的</code>扩展.</td><td>实现…扩展/实现对…的扩展/实现在…的情况下对…的扩展。<code>进行</code>这里多余了</td></tr><tr><td>这不仅减少了链上的计算需求,还提供了更快的响应时间.</td><td>这不仅减少了链上的计算需求,还提供了更快的响应<code>速度</code>.</td><td>更快的响应速度/更短的响应时间</td></tr><tr><td>这为未来央行数字货币[39]以及数字人民币开展金融业务提供了新思路.</td><td>这为未来央行数字货币[39]以及数字人民币的金融应用提供了新思路。</td><td>货币没法开展业务，开展业务的是人</td></tr></tbody></table></div><h2 id="我干了我自己"><a href="#我干了我自己" class="headerlink" title="我干了我自己"></a>我干了我自己</h2><div class="table-container"><table><thead><tr><th>错误</th><th>正确</th><th>原因</th></tr></thead><tbody><tr><td>基于系统模型和威胁模型,本文从效率、安全性以及可扩展性三个方面定义了本文的设计目标:</td><td>基于系统模型和威胁模型,<code>本节</code>将从效率、安全性以及可扩展性三个方面定义设计目标:</td><td>本文定义了本文的目标？</td></tr></tbody></table></div><h2 id="一件事描述完得用句号"><a href="#一件事描述完得用句号" class="headerlink" title="一件事描述完得用句号"></a>一件事描述完得用句号</h2><div class="table-container"><table><thead><tr><th>错误</th><th>正确</th><th>原因</th></tr></thead><tbody><tr><td>对称认证加密方案$\varepsilon$需满足正确性要求，对于任意认证密钥…</td><td>对称认证加密方案$\varepsilon$需满足正确性要求<code>。</code>对于任意认证密钥…</td><td>第一句话总领全文，句号就ok</td></tr></tbody></table></div><h2 id="表并列省略主语，不然看着太啰嗦"><a href="#表并列省略主语，不然看着太啰嗦" class="headerlink" title="表并列省略主语，不然看着太啰嗦"></a>表并列省略主语，不然看着太啰嗦</h2><div class="table-container"><table><thead><tr><th>错误</th><th>正确</th><th>原因</th></tr></thead><tbody><tr><td>对于任意一个概率多项式时间敌手[A],[A]在下述游戏中的优势…</td><td>对于任意一个概率多项式时间敌手[A],在下述游戏中的优势…</td><td>逗号后面的主语可以删掉了</td></tr></tbody></table></div><h2 id="全称-简称要统一"><a href="#全称-简称要统一" class="headerlink" title="全称-简称要统一"></a>全称-简称要统一</h2><div class="table-container"><table><thead><tr><th>错误</th><th>正确</th><th>原因</th></tr></thead><tbody><tr><td>敌手[A]与挑战者执行游戏…</td><td>敌手[A]与挑战者[C]执行游戏…</td><td>不能敌手有简称挑战者么得</td></tr></tbody></table></div><h2 id="减少长难句"><a href="#减少长难句" class="headerlink" title="减少长难句"></a>减少长难句</h2><div class="table-container"><table><thead><tr><th>错误</th><th>正确</th><th>原因</th></tr></thead><tbody><tr><td>Alex等人[7]基于不经意传输协议和满足IND-CPA的对称认证加密方案提出的两方公平秘密交换协议可以在不需要任何第三方参与的情况下实现秘密交换,即参与交换的两个秘密要么都会被交换,要么没有一个秘密会被交换.</td><td>Alex等人[7]基于不经意传输协议和满足IND-CPA安全定义的对称认证加密方案,提出了一种两方公平秘密交换协议。该协议可以在没有第三方参与的情况下,实现两方之间的秘密交换.参与交换的两个秘密要么都会被交换,要么没有一个秘密会被交换.</td><td>长难句要拆开</td></tr></tbody></table></div><h2 id="表意不明"><a href="#表意不明" class="headerlink" title="表意不明"></a>表意不明</h2><div class="table-container"><table><thead><tr><th>错误</th><th>正确</th><th>原因</th></tr></thead><tbody><tr><td>通过以上过程,实现了X和Y之间的秘密公平交换,并且在此过程中无需任何第三方介入,但代价是协议的错误率为$({M-1)}/{M}\;$并且协议最大需要运行M次,如果将协议运行在合约中会造成大量的计算开销</td><td>通过以上<code>步骤</code>,实现了X和Y之间的秘密公平交换,在此过程中无需任何第三方介入<code>.</code>但是该协议的错误率为$({M-1)}/{M}\;$,并且最多需要运行M次,如果在智能合约中执行该协议会造成较大的计算开销.</td><td>连词过多，太乱了</td></tr><tr><td>此外,通过将部分计算移到链下,进一步提高了系统的效率.这不仅减少了链上的计算需求,还提供了更快的响应时间.</td><td>此外,通过将部分计算<code>迁移</code>至链下执行,进一步提高了系统的效率.这不仅减少了链上的<code>计算量</code>,<code>还缩短了</code>响应时间.</td><td>减少口语化描述</td></tr></tbody></table></div><h2 id="标点符号"><a href="#标点符号" class="headerlink" title="标点符号"></a>标点符号</h2><div class="table-container"><table><thead><tr><th>错误</th><th>正确</th><th>原因</th></tr></thead><tbody><tr><td>债权人、债务人和第三方都参与了链上智能合约的交互过程,如果第三方不参与债务转让,则链上合约只执行贷款协议部分,此时债务转让部分不会产生额外的开销;如果第三方参与债务转让,则在债务转让完成后原本债务人与债权人的贷款协议将转变为第三方与债权人的贷款协议,债务人在债务转让完成后不再参与后续的贷款流程.</td><td>债权人、债务人和第三方都参与了链上智能合约的交互过程.如果第三方不参与债务转让,则链上合约只执行贷款协议部分,此时债务转让部分不会产生额外的开销.如果第三方参与债务转让,则在债务转让完成后,原本存在于债务人与债权人之间的贷款协议将转变为第三方与债权人之间的新的贷款协议.在债务转让后,债务人不再参与后续的贷款流程.</td><td>一件事说完，如果要另起一件事就是句号隔开。</td></tr><tr><td>本文参考了Black等人[3]设计的原子贷款协议,基于可升级智能合约的特点设计了可转让原子贷款协议,协议包含三个合约,具体如下:</td><td>本文参考了Black等人[3]设计的原子贷款协议,基于可升级智能合约的特点设计了可转让原子贷款协议<code>.</code>协议包含三个合约,具体如下:</td><td>两件事用句号隔开</td></tr></tbody></table></div><h1 id="英文语法"><a href="#英文语法" class="headerlink" title="英文语法"></a>英文语法</h1><p>未完待续…</p>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 语文 </tag>
            
            <tag> 论文 </tag>
            
            <tag> 学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>群辉container Manager修复思源笔记v2.10.x的accessAuthCode执行命令的错误</title>
      <link href="/2023/10/19/%E7%BE%A4%E8%BE%89container%20Manager%E4%BF%AE%E5%A4%8D%E6%80%9D%E6%BA%90%E7%AC%94%E8%AE%B0v2.10.x%E7%9A%84accessAuthCode%E6%89%A7%E8%A1%8C%E5%91%BD%E4%BB%A4%E7%9A%84%E9%94%99%E8%AF%AF/"/>
      <url>/2023/10/19/%E7%BE%A4%E8%BE%89container%20Manager%E4%BF%AE%E5%A4%8D%E6%80%9D%E6%BA%90%E7%AC%94%E8%AE%B0v2.10.x%E7%9A%84accessAuthCode%E6%89%A7%E8%A1%8C%E5%91%BD%E4%BB%A4%E7%9A%84%E9%94%99%E8%AF%AF/</url>
      
        <content type="html"><![CDATA[<hr><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>群晖自从升级到DSM7.2之后原来的docker就变成container Manager了，新的管理面板没法修改容器的执行命令，只能通过ssh修改了。</p><p><img src="https://blogimages.happyshark.cn/%E7%BE%A4%E6%99%96%E4%BF%AE%E6%94%B9container%20Manager%E5%AE%B9%E5%99%A8%E6%89%A7%E8%A1%8C%E5%91%BD%E4%BB%A4%E6%96%B9%E6%B3%95/image-20231019221429031.png" alt="image-20231019221429031"></p><p>刚好思源笔记的docker最新版增加了accessAuthCode检查，如果启动命令没有accessAuthCode的话会报错无法启动，需要在执行命令中添加<code>-accessAuthCode</code>参数，故记录一下配置过程。</p><h1 id="配置过程"><a href="#配置过程" class="headerlink" title="配置过程"></a>配置过程</h1><ol><li><p>先在群晖的<code>控制面板-终端机和SNMP-终端机</code>界面启用<code>ssh功能</code>。<br><img src="https://blogimages.happyshark.cn/%E7%BE%A4%E6%99%96%E4%BF%AE%E6%94%B9container%20Manager%E5%AE%B9%E5%99%A8%E6%89%A7%E8%A1%8C%E5%91%BD%E4%BB%A4%E6%96%B9%E6%B3%95/image-20231019220626878.png" alt="image-20231019220626878"></p></li><li><p>在群晖的<code>套件中心</code>里停止container Manager运行。<br><img src="https://blogimages.happyshark.cn/%E7%BE%A4%E6%99%96%E4%BF%AE%E6%94%B9container%20Manager%E5%AE%B9%E5%99%A8%E6%89%A7%E8%A1%8C%E5%91%BD%E4%BB%A4%E6%96%B9%E6%B3%95/image-20231019223208191.png" alt="image-20231019223208191"></p></li><li><p>使用ssh软件登陆群晖后台，我这里用的finalshell，账号就是nas的管理员账号，密码就是管理员密码。<br><img src="https://blogimages.happyshark.cn/%E7%BE%A4%E6%99%96%E4%BF%AE%E6%94%B9container%20Manager%E5%AE%B9%E5%99%A8%E6%89%A7%E8%A1%8C%E5%91%BD%E4%BB%A4%E6%96%B9%E6%B3%95/image-20231019220731971.png" alt="image-20231019220731971"></p></li><li><p>输入<code>sudo su</code>指令，获取root权限，密码就是nas管理员账号的密码。</p><p><img src="https://blogimages.happyshark.cn/%E7%BE%A4%E6%99%96%E4%BF%AE%E6%94%B9container%20Manager%E5%AE%B9%E5%99%A8%E6%89%A7%E8%A1%8C%E5%91%BD%E4%BB%A4%E6%96%B9%E6%B3%95/image-20231019221053321.png" alt="image-20231019221053321"></p></li><li><p>执行命令<code>docker ps -a --no-trunc</code>，查看需要修改执行命令的容器名<br><img src="https://blogimages.happyshark.cn/%E7%BE%A4%E6%99%96%E4%BF%AE%E6%94%B9container%20Manager%E5%AE%B9%E5%99%A8%E6%89%A7%E8%A1%8C%E5%91%BD%E4%BB%A4%E6%96%B9%E6%B3%95/image-20231019221327696.png" alt="image-20231019221327696"></p></li><li><p>执行命令<code>cd /volume1/\@docker/containers</code>进入docker的容器文件夹，输入<code>ls</code>查看需要修改的容器文件夹，然后<code>cd &lt;容器id&gt;</code>并进入。</p><p><img src="https://blogimages.happyshark.cn/%E7%BE%A4%E6%99%96%E4%BF%AE%E6%94%B9container%20Manager%E5%AE%B9%E5%99%A8%E6%89%A7%E8%A1%8C%E5%91%BD%E4%BB%A4%E6%96%B9%E6%B3%95/image-20231019221901980.png" alt="image-20231019221901980"></p></li><li><p>执行命令<code>vi config.v2.json</code>修改容器的配置文件，找到<code>Args</code>和<code>Cmd</code>，在里头增加新的命令和参数。</p><blockquote><p>Args是参数，Cmd是完整命令,这里都要填</p></blockquote><p>修改后的Args如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&quot;Args&quot;:[&quot;-workspace&quot;,&quot;/siyuan/workspace/&quot;,&quot;-accessAuthCode&quot;,&quot;itseclab&quot;],</span><br></pre></td></tr></table></figure><p>修改后的Cmd如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">,&quot;Cmd&quot;:[&quot;-workspace&quot;,&quot;/siyuan/workspace/&quot;,&quot;-accessAuthCode&quot;,&quot;itseclab&quot;],</span><br></pre></td></tr></table></figure><p><img src="https://blogimages.happyshark.cn/%E7%BE%A4%E6%99%96%E4%BF%AE%E6%94%B9container%20Manager%E5%AE%B9%E5%99%A8%E6%89%A7%E8%A1%8C%E5%91%BD%E4%BB%A4%E6%96%B9%E6%B3%95/image-20231019223013922.png" alt="image-20231019223013922"></p></li><li><p>保存退出，然后回到群晖的<code>套件中心</code>，运行container Manager。<br><img src="https://blogimages.happyshark.cn/%E7%BE%A4%E6%99%96%E4%BF%AE%E6%94%B9container%20Manager%E5%AE%B9%E5%99%A8%E6%89%A7%E8%A1%8C%E5%91%BD%E4%BB%A4%E6%96%B9%E6%B3%95/image-20231019223245164.png" alt="image-20231019223245164"></p></li></ol><h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>思源笔记的最最最新版2.10.11貌似又改回去了，不过老版本因为打不开而没法升级到最新版…就死锁了。</p><h1 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h1><p><a href="https://blog.51cto.com/u_16175484/6828146">群晖 docker 修改命令行启动_mob649e81607bf3的技术博客_51CTO博客</a></p><p><a href="https://www.mmuaa.com/post/52f239637089c8ea.html">docker容器修改启动命令 - 斐斐のBlog (mmuaa.com)</a></p><p><a href="https://www.reddit.com/r/synology/comments/r0rjwk/docker_on_synology_easy_way_to_edit_the_execution/">Docker on Synology - Easy Way to Edit the Execution Command? : synology (reddit.com)</a></p>]]></content>
      
      
      <categories>
          
          <category> 实验室大杂烩 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> docker </tag>
            
            <tag> 群晖 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>PC,树莓派,安卓的miracl库环境配置</title>
      <link href="/2023/04/03/PC,%E6%A0%91%E8%8E%93%E6%B4%BE,%E5%AE%89%E5%8D%93%E7%9A%84miracl%E5%BA%93%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/"/>
      <url>/2023/04/03/PC,%E6%A0%91%E8%8E%93%E6%B4%BE,%E5%AE%89%E5%8D%93%E7%9A%84miracl%E5%BA%93%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>此篇文章的目的是详细介绍一下miracl库在x86，树莓派4B，安卓手机上的环境配置，按本文章配置完成后就可以直接在PC运行使用miracl库的c++代码，并且将相同代码移植到树莓派4B，安卓手机上，方便把精力更多的放在代码本身而不是环境配置上。文章是我与李慧琳师姐合作完成，感谢师姐领我入坑以及提供的海量技术支持~</p><p>关键词：交叉编译，adb，visualgdb，visual studio</p><h1 id="x86-miracl库环境配置（visual-studio）"><a href="#x86-miracl库环境配置（visual-studio）" class="headerlink" title="x86 miracl库环境配置（visual studio）"></a>x86 miracl库环境配置（visual studio）</h1><p>x86环境配置分为三个部分：</p><ul><li>编译miracl.lib</li><li>导入vs</li><li>运行测试代码</li></ul><h2 id="软件要求"><a href="#软件要求" class="headerlink" title="软件要求"></a>软件要求</h2><ul><li><p>visual studio 2022（windwos社区版），地址：<a href="https://visualstudio.microsoft.com/vs/community/，vs需要安装的组件如下(包括了下面编译调试树莓派和安卓需要的组件)：">https://visualstudio.microsoft.com/vs/community/，vs需要安装的组件如下(包括了下面编译调试树莓派和安卓需要的组件)：</a><br><img src="https://blogimages.happyshark.cn/PC,%E6%A0%91%E8%8E%93%E6%B4%BE,%E5%AE%89%E5%8D%93%E7%9A%84miracl%E5%BA%93%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/image-20230403181612719.png" alt="image-20230403181612719"></p><p><img src="https://blogimages.happyshark.cn/PC,%E6%A0%91%E8%8E%93%E6%B4%BE,%E5%AE%89%E5%8D%93%E7%9A%84miracl%E5%BA%93%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/image-20230403181628425.png" alt="image-20230403181628425"></p></li><li><p>miracl7.0.0源代码，github地址：<a href="https://github.com/miracl/MIRACL">https://github.com/miracl/MIRACL</a></p></li></ul><h2 id="配置过程"><a href="#配置过程" class="headerlink" title="配置过程"></a>配置过程</h2><ol><li><p>下载miracl库<br>github地址：<a href="https://github.com/miracl/MIRACL">https://github.com/miracl/MIRACL</a></p></li><li><p>新建个文件夹，可以命名为<code>miracl</code>，然后把解压的所有文件都复制<code>miracl</code>中</p><blockquote><p>MIRACL-master中二级、三级目录中的文件要一块拷出来复制进去,最后<code>miracl</code>文件夹中只有文件，没有其他文件夹</p></blockquote><p><img src="https://blogimages.happyshark.cn/PC,%E6%A0%91%E8%8E%93%E6%B4%BE,%E5%AE%89%E5%8D%93%E7%9A%84miracl%E5%BA%93%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/image-20230403161607009.png" alt="image-20230403161607009"></p></li><li><p>进到vs安装目录<code>\VS\VC\Auxiliary\Build</code>中，比如我的是<code>D:\software\Microsoft Visual Studio\2022\Community\VC\Auxiliary\Build</code></p></li><li><p>shift+右键，打开cmd（管理员模式），执行<code>vcvars32.bat</code><br><img src="https://blogimages.happyshark.cn/PC,%E6%A0%91%E8%8E%93%E6%B4%BE,%E5%AE%89%E5%8D%93%E7%9A%84miracl%E5%BA%93%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/image-20230403162232003.png" alt="image-20230403162232003"></p></li><li><p>返回到<code>miracl</code>文件夹</p><p><img src="https://blogimages.happyshark.cn/PC,%E6%A0%91%E8%8E%93%E6%B4%BE,%E5%AE%89%E5%8D%93%E7%9A%84miracl%E5%BA%93%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/image-20230403162732823.png" alt="image-20230403162732823"></p></li><li><p>执行<code>ms32doit.bat</code>,运行完之后在<code>miracl</code>文件夹里面看到一个miracl.lib文件</p><p><img src="https://blogimages.happyshark.cn/PC,%E6%A0%91%E8%8E%93%E6%B4%BE,%E5%AE%89%E5%8D%93%E7%9A%84miracl%E5%BA%93%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/image-20230403163049893.png" alt="image-20230403163049893"></p></li><li><p>然后将miracl库导入vs项目，新建一个c++空项目<br><img src="https://blogimages.happyshark.cn/PC,%E6%A0%91%E8%8E%93%E6%B4%BE,%E5%AE%89%E5%8D%93%E7%9A%84miracl%E5%BA%93%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/image-20230403163610830.png" alt="image-20230403163610830"></p></li><li><p>在项目文件中创建一个cpp文件，名字随意，我这里创建了一个<code>test.cpp</code>,文件内容如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;big.h&quot;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function">Miracl <span class="title">precision</span><span class="params">(<span class="number">500</span>, <span class="number">10</span>)</span></span>; <span class="comment">// This makes sure that MIRACL</span></span><br><span class="line"><span class="comment">// is initialised before main() // is called</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123; <span class="comment">/* calculate factorial of number */</span></span><br><span class="line">    Big nf = <span class="number">1</span>;       <span class="comment">/* declare &quot;Big&quot; variable nf */</span></span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;factorial program\n&quot;</span>;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;input number n= &quot;</span>;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">while</span> (n &gt; <span class="number">1</span>)</span><br><span class="line">        nf *= (n--);  <span class="comment">/* nf=n!=n*(n-1)*(n-2)*....3*2*1  */</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;n!= &quot;</span> &lt;&lt; nf &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>移动需要的文件：</p><ul><li><p>将<code>MIRACL-master</code>中（注意不是<code>miracl</code>文件夹）的<code>include</code>文件夹里面需要的.h文件放到项目文件夹中的<code>include</code>文件夹中，比如我目前只需要以下三个文件：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">big.h //看你代码里面需不需要</span><br><span class="line">mirdef.h //必选</span><br><span class="line">miracl.h //必选</span><br></pre></td></tr></table></figure></li><li><p>将<code>MIRACL-master</code>中<code>source</code>里面需要的cpp文件拷到项目文件夹中的<code>source</code>中，我的项目文件夹里面只放了以下一个文件：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">big.cpp</span><br></pre></td></tr></table></figure></li><li><p>将<code>miracl</code>文件夹中的mircal.lib复制到项目文件夹中<br><img src="https://blogimages.happyshark.cn/PC,%E6%A0%91%E8%8E%93%E6%B4%BE,%E5%AE%89%E5%8D%93%E7%9A%84miracl%E5%BA%93%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/image-20230403175117842.png" alt="image-20230403175117842"></p></li></ul></li><li><p>右键项目-属性-配置属性-C/C++-常规-附加包含目录，添加<code>include</code><br><img src="https://blogimages.happyshark.cn/PC,%E6%A0%91%E8%8E%93%E6%B4%BE,%E5%AE%89%E5%8D%93%E7%9A%84miracl%E5%BA%93%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/image-20230403165108384.png" alt="image-20230403165108384"></p></li><li><p>同样在项目属性页面-连接器-常规-附加库目录添加<code>source</code><br><img src="https://blogimages.happyshark.cn/PC,%E6%A0%91%E8%8E%93%E6%B4%BE,%E5%AE%89%E5%8D%93%E7%9A%84miracl%E5%BA%93%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/image-20230403174039743.png" alt="image-20230403174039743"></p></li><li><p>同样在项目属性页面-连接器-输入-附加依赖添加<code>miracl.lib</code></p><p><img src="https://blogimages.happyshark.cn/PC,%E6%A0%91%E8%8E%93%E6%B4%BE,%E5%AE%89%E5%8D%93%E7%9A%84miracl%E5%BA%93%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/image-20230403174138812.png" alt="image-20230403174138812"></p></li><li><p>把对应的头文件和cpp文件还有lib文件添加到项目里，如图所示<br><img src="https://blogimages.happyshark.cn/PC,%E6%A0%91%E8%8E%93%E6%B4%BE,%E5%AE%89%E5%8D%93%E7%9A%84miracl%E5%BA%93%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/image-20230403175138383.png" alt="image-20230403175138383"></p></li><li><p>运行，结果如下图所示：<br><img src="https://blogimages.happyshark.cn/PC,%E6%A0%91%E8%8E%93%E6%B4%BE,%E5%AE%89%E5%8D%93%E7%9A%84miracl%E5%BA%93%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/image-20230403175352165.png" alt="image-20230403175352165"></p></li></ol><h1 id="树莓派环境配置（visualGDB）"><a href="#树莓派环境配置（visualGDB）" class="headerlink" title="树莓派环境配置（visualGDB）"></a>树莓派环境配置（visualGDB）</h1><p>树莓派环境配置目标是将windows的代码移植过来，分为五个部分：</p><ul><li>安装visualGDB</li><li>给树莓派安装操作系统</li><li>编译miracl.a</li><li>导入vs</li><li>运行测试代码</li></ul><h2 id="软件-硬件要求"><a href="#软件-硬件要求" class="headerlink" title="软件/硬件要求"></a>软件/硬件要求</h2><ul><li><p>visual studio 2022（windwos社区版），地址：<a href="https://visualstudio.microsoft.com/vs/community/">https://visualstudio.microsoft.com/vs/community/</a>，vs需要安装的组件如下(包括了下面编译调试安卓需要的组件)：<br><img src="https://blogimages.happyshark.cn/PC,%E6%A0%91%E8%8E%93%E6%B4%BE,%E5%AE%89%E5%8D%93%E7%9A%84miracl%E5%BA%93%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/image-20230403181612719.png" alt="image-20230403181612719"></p><p><img src="https://blogimages.happyshark.cn/PC,%E6%A0%91%E8%8E%93%E6%B4%BE,%E5%AE%89%E5%8D%93%E7%9A%84miracl%E5%BA%93%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/image-20230403181628425.png" alt="image-20230403181628425"></p></li><li><p>miracl7.0.0源代码，github地址：<a href="https://github.com/miracl/MIRACL">https://github.com/miracl/MIRACL</a></p></li><li>visualGDB，地址：<a href="https://visualgdb.com/download/">https://visualgdb.com/download/</a></li><li>树莓派操作系统和对应的交叉编译器，地址：www.gnutoolchains.com/raspberry64/</li><li>finalshell，用于ssh链接。地址：<a href="https://www.hostbuf.com">https://www.hostbuf.com</a></li><li>树莓派镜像工具，用于安装操作系统，地址：<a href="https://www.raspberrypi.com/software/">https://www.raspberrypi.com/software/</a></li></ul><h2 id="配置过程-1"><a href="#配置过程-1" class="headerlink" title="配置过程"></a>配置过程</h2><blockquote><p>使用visualGDB配置树莓派环境时必须保证树莓派系统和交叉编译版本一一对应，对于树莓派4B来说，可以直接从这个网址下载树莓派系统和交叉编译器：<br><a href="https://gnutoolchains.com/raspberry64/">https://gnutoolchains.com/raspberry64/</a></p><p>英文教程在这里：gnutoolchains.com/raspberry/tutorial/</p></blockquote><ol><li><p>安装visualGDB，这个是付费软件，可以试用，也可以破解，此处不讨论破解过程，软件安装地址：<a href="https://visualgdb.com/download/">https://visualgdb.com/download/</a>，安装完后vs应该可以新建visualGDB项目<br><img src="https://blogimages.happyshark.cn/PC,%E6%A0%91%E8%8E%93%E6%B4%BE,%E5%AE%89%E5%8D%93%E7%9A%84miracl%E5%BA%93%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/image-20230403200936747.png" alt="image-20230403200936747"></p></li><li><p>从<a href="https://gnutoolchains.com/raspberry64/下载操作系统镜像2022-01-28-raspios-bullseye-arm64.zip和交叉编译器安装包raspberry64-gcc10.2.1.exe">https://gnutoolchains.com/raspberry64/下载操作系统镜像2022-01-28-raspios-bullseye-arm64.zip和交叉编译器安装包raspberry64-gcc10.2.1.exe</a><br><img src="https://blogimages.happyshark.cn/PC,%E6%A0%91%E8%8E%93%E6%B4%BE,%E5%AE%89%E5%8D%93%E7%9A%84miracl%E5%BA%93%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/image-20230403180118138.png" alt="image-20230403180118138"></p></li><li><p>安装交叉编译器，注意安装目录不能有空格或者中文，比如我安装到了<code>D:\SysGcc</code></p></li><li><p>把树莓派的sd卡插到电脑上</p></li><li><p>下载树莓派镜像工具并安装后管理员身份运行，点击<code>选择操作系统</code>-<code>使用自定义镜像</code>-选择刚才下载的zip镜像</p></li><li><p>点击设置，配置<strong>ssh（重要，不搞这个你得自己接个显示器然后在树莓派上配置）</strong>，用户名，密码。<br><img src="https://blogimages.happyshark.cn/PC,%E6%A0%91%E8%8E%93%E6%B4%BE,%E5%AE%89%E5%8D%93%E7%9A%84miracl%E5%BA%93%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/image-20230403194130553.png" alt="image-20230403194130553"><br><img src="https://blogimages.happyshark.cn/PC,%E6%A0%91%E8%8E%93%E6%B4%BE,%E5%AE%89%E5%8D%93%E7%9A%84miracl%E5%BA%93%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/image-20230403194225575.png" alt="image-20230403194225575"></p></li><li><p>确认sd卡无误（别装错地方啦）之后就可以点<code>烧录</code>，开始安装操作系统<br><img src="https://blogimages.happyshark.cn/PC,%E6%A0%91%E8%8E%93%E6%B4%BE,%E5%AE%89%E5%8D%93%E7%9A%84miracl%E5%BA%93%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/image-20230403181028275.png" alt="image-20230403181028275"></p></li><li><p>安装完后树莓派开机，配置ssh，记下树莓派的ip地址，用finalshell登陆root账户</p></li><li><p>接下来开始在树莓派上面编译miracl.a库，毕竟代码可以交叉编译，静态库还是要自己整一下的，先在<a href="https://github.com/HPShark/MIRACL-raspbian中下载zip包，在通过finalshell上传到树莓派里。">https://github.com/HPShark/MIRACL-raspbian中下载zip包，在通过finalshell上传到树莓派里。</a></p><p><img src="https://blogimages.happyshark.cn/PC,%E6%A0%91%E8%8E%93%E6%B4%BE,%E5%AE%89%E5%8D%93%E7%9A%84miracl%E5%BA%93%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/image-20230403195201255.png" alt="image-20230403195201255"></p></li><li><p>cd到压缩包所在位置，比如我是<code>cd /home/code</code>，新建一个miracl文件夹，一会在visualGDB中导入要用</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mkdir miracl</span><br></pre></td></tr></table></figure></li><li><p>然后在ssh终端中执行以下代码：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">apt install unzip # 安装解压软件</span><br><span class="line">cp MIRACL-raspbian-master.zip miracl/</span><br><span class="line">chmod -R 777 miracl</span><br><span class="line">cd miracl</span><br><span class="line">unzip -j -aa -L MIRACL-raspbian-master.zip # 如果有提示选[A]ll就行</span><br><span class="line">cd .. &amp;&amp; chmod -R 777 miracl &amp;&amp; cd miracl</span><br><span class="line">./linux-raspbian</span><br></pre></td></tr></table></figure><p>然后等上几分钟，就编译好了，按修改时间排下序可以找到<code>miracl.a</code>和<code>mirdef.h</code>，把这俩文件下载下来备着，下面一步要用<br><img src="https://blogimages.happyshark.cn/PC,%E6%A0%91%E8%8E%93%E6%B4%BE,%E5%AE%89%E5%8D%93%E7%9A%84miracl%E5%BA%93%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/image-20230403200752107.png" alt="image-20230403200752107"></p></li><li><p>然后接下来新建visualGDB项目</p><p><img src="https://blogimages.happyshark.cn/PC,%E6%A0%91%E8%8E%93%E6%B4%BE,%E5%AE%89%E5%8D%93%E7%9A%84miracl%E5%BA%93%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/image-20230403200936747.png" alt="image-20230403200936747"></p></li><li><p>新建一个linux Project Wizard，点击add<br><img src="https://blogimages.happyshark.cn/PC,%E6%A0%91%E8%8E%93%E6%B4%BE,%E5%AE%89%E5%8D%93%E7%9A%84miracl%E5%BA%93%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/image-20230403201217207.png" alt="image-20230403201217207"></p></li><li><p>配置如图，选择next<br><img src="https://blogimages.happyshark.cn/PC,%E6%A0%91%E8%8E%93%E6%B4%BE,%E5%AE%89%E5%8D%93%E7%9A%84miracl%E5%BA%93%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/image-20230403201232137.png" alt="image-20230403201232137"></p></li><li><p>在这个页面选择第三步安装的交叉编译器目录，并连接ssh后点finish测试链接<br><img src="https://blogimages.happyshark.cn/PC,%E6%A0%91%E8%8E%93%E6%B4%BE,%E5%AE%89%E5%8D%93%E7%9A%84miracl%E5%BA%93%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/image-20230403201456418.png" alt="image-20230403201456418"></p></li><li><p>如果提示gdb-server未安装的话，执行自动安装就行。<br>（运行太快没截上图orz）</p></li><li><p>链接树莓派上编译好的miracl.a静态库，对项目右键-<code>visualGDB Project Properties</code>-<code>MSBuild Settings</code>，点Build Tools里面右侧Synchronize sysroot<br><img src="https://blogimages.happyshark.cn/PC,%E6%A0%91%E8%8E%93%E6%B4%BE,%E5%AE%89%E5%8D%93%E7%9A%84miracl%E5%BA%93%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/image-20230403202122411.png" alt="image-20230403202122411"></p></li><li><p>点击 synchronize directories右侧的添加，然后在找到第10步键的miracl目录<br><img src="https://blogimages.happyshark.cn/PC,%E6%A0%91%E8%8E%93%E6%B4%BE,%E5%AE%89%E5%8D%93%E7%9A%84miracl%E5%BA%93%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/image-20230403202322149.png" alt="image-20230403202322149"></p></li><li><p>就会多出来一个目录，点击Synchronize<br><img src="https://blogimages.happyshark.cn/PC,%E6%A0%91%E8%8E%93%E6%B4%BE,%E5%AE%89%E5%8D%93%E7%9A%84miracl%E5%BA%93%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/image-20230403202506899.png" alt="image-20230403202506899"></p></li><li><p>因为是将windows代码移植到树莓派，所以把windows的代码（我这里直接将windows代码test.cpp替换至testArm.app内），include，source都复制过来即可，同时要把第11步中的<code>mirdef.h</code>文件替换到include中，将<code>miracl.a</code>放到根目录下，最终目录如下：<br><img src="https://blogimages.happyshark.cn/PC,%E6%A0%91%E8%8E%93%E6%B4%BE,%E5%AE%89%E5%8D%93%E7%9A%84miracl%E5%BA%93%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/image-20230403204156212.png" alt="image-20230403204156212"></p></li><li><p>对项目右键-<code>visualGDB Project Properties</code>-<code>MSBuild Settings</code>，需要填一些额外配置信息：</p><ul><li>在Common Build Settings 中的 Include Directories内填<code>include</code></li><li>在Common Build Settings 中的Library Names内填<code>source</code></li><li>在Common Build Settings 中的Additional Linker Inputs填写miracl.a的绝对地址</li></ul><p><img src="https://blogimages.happyshark.cn/PC,%E6%A0%91%E8%8E%93%E6%B4%BE,%E5%AE%89%E5%8D%93%E7%9A%84miracl%E5%BA%93%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/image-20230403204327514.png" alt="image-20230403204327514"></p></li><li><p>运行代码，结果如下图所示：<br><img src="https://blogimages.happyshark.cn/PC,%E6%A0%91%E8%8E%93%E6%B4%BE,%E5%AE%89%E5%8D%93%E7%9A%84miracl%E5%BA%93%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/image-20230403204612829.png" alt="image-20230403204612829"></p></li></ol><h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2><ul><li><p>如果有其他输入输出文件，需要把文件拷至二进制文件所在目录。</p><blockquote><p>比如windows上的代码需要读取<code>pubilc.key</code>文件，那得把<code>pubilc.key</code>文件拷贝到树莓派二进制文件存放地址，这个地址得看第15步中的folder，比如我的是/tmp，那就说明交叉编译的二进制文件存放在树莓派的/tmp文件夹下，然后得手动<code>pubilc.key</code>文件拷过去才能正常运行。如果有权限问题还需要手动赋权</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chmod 777 public.key</span><br></pre></td></tr></table></figure><p><img src="https://blogimages.happyshark.cn/PC,%E6%A0%91%E8%8E%93%E6%B4%BE,%E5%AE%89%E5%8D%93%E7%9A%84miracl%E5%BA%93%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/image-20230403231308155.png" alt="image-20230403231308155"></p></blockquote></li><li><p>如果运行出现错误，多半是因为miracl文件夹的绝对位置与树莓派不一致，或者windows上的代码运行时需要读取的文件没加进来。</p></li></ul><h1 id="安卓环境配置（visualGDB）"><a href="#安卓环境配置（visualGDB）" class="headerlink" title="安卓环境配置（visualGDB）"></a>安卓环境配置（visualGDB）</h1><p>安卓的环境配置目标同样是将windows的代码移植过来，但我的手机（红米K30U）和树莓派都是armv8的，所以就把树莓派上的二进制文件移植过去就好，分为五个部分：</p><ul><li>手机安装termux，anlinux</li><li>电脑adb调试连接手机</li><li>把树莓派的miracl库拷贝到手机上的相同位置</li><li>拷贝树莓派内编译好的二进制文件到手机内，赋予+x权限并执行</li></ul><h2 id="软件-硬件要求-1"><a href="#软件-硬件要求-1" class="headerlink" title="软件/硬件要求"></a>软件/硬件要求</h2><ul><li><p>安卓手机需要通过google play安装termux， anlinux</p><blockquote><p>需要梯子，其他下载来源不保证测试通过</p></blockquote></li><li><p>电脑上准备adb调试软件，我是直接用了QtScrcpy，地址：<a href="https://github.com/barry-ran/QtScrcpy">https://github.com/barry-ran/QtScrcpy</a></p><blockquote><p>会adb链接指令可以直接用adb自己链接，这个软件可以一建链接，只需要adb push就行。</p></blockquote></li></ul><h2 id="配置过程-2"><a href="#配置过程-2" class="headerlink" title="配置过程"></a>配置过程</h2><ol><li><p>手机安装好temux后进入软件，第一次可能需要初始化，进入终端后退出，然后打开anlinux，会显示仪表板，然后选择系统</p><p><img src="https://blogimages.happyshark.cn/PC,%E6%A0%91%E8%8E%93%E6%B4%BE,%E5%AE%89%E5%8D%93%E7%9A%84miracl%E5%BA%93%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/image-20230403232739125.png" alt="image-20230403232739125"></p></li><li><p>选择第一个ubuntu，点确定。</p><p><img src="https://blogimages.happyshark.cn/PC,%E6%A0%91%E8%8E%93%E6%B4%BE,%E5%AE%89%E5%8D%93%E7%9A%84miracl%E5%BA%93%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/image-20230403232817983.png" alt="image-20230403232817983"></p></li><li><p>点击复制，然后切换回termux，粘贴命令并回车执行。<br><img src="https://blogimages.happyshark.cn/PC,%E6%A0%91%E8%8E%93%E6%B4%BE,%E5%AE%89%E5%8D%93%E7%9A%84miracl%E5%BA%93%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/image-20230403233151085.png" alt="image-20230403233151085"></p></li><li><p>运行完后在termux执行以下代码获取系统文件权限</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">termux-setup-storage # 申请获取系统文件权限</span><br></pre></td></tr></table></figure></li><li><p>编辑<code>start-ubuntu.sh</code>文件，将<code>#command+=&quot; -b /sdcard&quot;</code>取消注释</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">vim start-ubuntu.sh</span><br><span class="line"># 按 i 进入编辑模式</span><br><span class="line"># 删除＃号</span><br><span class="line">command+=&quot; -b /sdcard</span><br><span class="line"># 按esc退出编辑模式</span><br><span class="line">输入:wq保存退出（如果改错了输入:q!强制退出）</span><br></pre></td></tr></table></figure><p><img src="https://blogimages.happyshark.cn/PC,%E6%A0%91%E8%8E%93%E6%B4%BE,%E5%AE%89%E5%8D%93%E7%9A%84miracl%E5%BA%93%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/image-20240307210615907.png" alt="image-20240307210615907"><br><img src="https://blogimages.happyshark.cn/PC,%E6%A0%91%E8%8E%93%E6%B4%BE,%E5%AE%89%E5%8D%93%E7%9A%84miracl%E5%BA%93%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/image-20240307210734520.png" alt="image-20240307210734520"><br><img src="https://blogimages.happyshark.cn/PC,%E6%A0%91%E8%8E%93%E6%B4%BE,%E5%AE%89%E5%8D%93%E7%9A%84miracl%E5%BA%93%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/image-20240307210854699.png" alt="image-20240307210854699"></p></li></ol><ol><li><p>继续执以下代码，进入root@ubuntu环境</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./start-ubuntu.sh</span><br></pre></td></tr></table></figure><p><img src="https://blogimages.happyshark.cn/PC,%E6%A0%91%E8%8E%93%E6%B4%BE,%E5%AE%89%E5%8D%93%E7%9A%84miracl%E5%BA%93%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/image-20230403233818218.png" alt="image-20230403233818218"></p></li><li><p>继续执行以下代码，将系统存储的Download文件夹映射至ubuntu 的share文件夹中</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ln -s /sdcard/Downloads ./share</span><br></pre></td></tr></table></figure><p><img src="https://blogimages.happyshark.cn/PC,%E6%A0%91%E8%8E%93%E6%B4%BE,%E5%AE%89%E5%8D%93%E7%9A%84miracl%E5%BA%93%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/image-20230403235230885.png" alt="image-20230403235230885"></p></li><li><p>下面把miracl库导入Ubuntu系统。通过finalshell把miracl文件夹（第二部分第十步）下载下来<br><img src="https://blogimages.happyshark.cn/PC,%E6%A0%91%E8%8E%93%E6%B4%BE,%E5%AE%89%E5%8D%93%E7%9A%84miracl%E5%BA%93%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/image-20230403234020128.png" alt="image-20230403234020128"></p></li><li><p>右键-复制文件地址<br><img src="https://blogimages.happyshark.cn/PC,%E6%A0%91%E8%8E%93%E6%B4%BE,%E5%AE%89%E5%8D%93%E7%9A%84miracl%E5%BA%93%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/image-20230403234146184.png" alt="image-20230403234146184"></p></li><li><p>下载好QtScrcpy，打开先连接手机<br>  <img src="https://blogimages.happyshark.cn/PC,%E6%A0%91%E8%8E%93%E6%B4%BE,%E5%AE%89%E5%8D%93%E7%9A%84miracl%E5%BA%93%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/image-20230403234326772.png" alt="image-20230403234326772"></p></li><li><p>然后直接关掉，在Qtscrcpy文件夹里右键-在终端中打开，输入以下代码将miracl文件夹存入手机系统存储的Download文件夹中，其中miracl地址是第8步中复制的地址</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">adb push &quot;C:\Users\CrazyBoomYangcong\Desktop\fsdownload\miracl&quot; /sdcard/Download</span><br></pre></td></tr></table></figure><p><img src="https://blogimages.happyshark.cn/PC,%E6%A0%91%E8%8E%93%E6%B4%BE,%E5%AE%89%E5%8D%93%E7%9A%84miracl%E5%BA%93%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/image-20230403234806101.png" alt="image-20230403234806101"></p></li><li><p>返回手机，继续输入以下命令将share文件夹中的miracl文件夹拷贝至/home/code文件夹中，然后在赋权</p><blockquote><p>/home/code这个绝对路径必须和第二部分第10步保持一致</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">midir /home/code</span><br><span class="line">cp -r share/miracl /home/code/</span><br><span class="line">chmod -R 777 /home/code/miracl</span><br><span class="line">ls /home/code</span><br></pre></td></tr></table></figure><p><img src="https://blogimages.happyshark.cn/PC,%E6%A0%91%E8%8E%93%E6%B4%BE,%E5%AE%89%E5%8D%93%E7%9A%84miracl%E5%BA%93%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/image-20230404000116918.png" alt="image-20230404000116918"></p></li><li><p>以上步骤就将手机Ubuntu的环境配置好了，下面将树莓派里的二进制文件拷贝到手机中运行，在finalshell中定位至/tmp文件夹，把里面的二进制文件还有所有的引用文件全下载下来</p><p><img src="https://blogimages.happyshark.cn/PC,%E6%A0%91%E8%8E%93%E6%B4%BE,%E5%AE%89%E5%8D%93%E7%9A%84miracl%E5%BA%93%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/image-20230404000552572.png" alt="image-20230404000552572"></p></li><li><p>然后同第10步一致，把所有文件复制到手机存储中的Download文件夹中<br><img src="https://blogimages.happyshark.cn/PC,%E6%A0%91%E8%8E%93%E6%B4%BE,%E5%AE%89%E5%8D%93%E7%9A%84miracl%E5%BA%93%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/image-20230404000724635.png" alt="image-20230404000724635"></p></li><li><p>在手机的Ubuntu终端上使用cp命令将所有文件从share文件夹拷贝至本地，并赋权。这里我只有一个二进制文件testArm和一个引用文件public.key</p><blockquote><p>不可以直接在share文件夹中运行，会报错</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">cp share/testArm .</span><br><span class="line">cp share/public.key .</span><br><span class="line">chmod 777 testArm</span><br><span class="line">chmod 777 public.key</span><br></pre></td></tr></table></figure></li><li><p>运行以下命令执行二进制文件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./testArm</span><br></pre></td></tr></table></figure><p><img src="https://blogimages.happyshark.cn/PC,%E6%A0%91%E8%8E%93%E6%B4%BE,%E5%AE%89%E5%8D%93%E7%9A%84miracl%E5%BA%93%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/image-20230404001248816.png" alt="image-20230404001248816"></p></li></ol><h2 id="注意事项-1"><a href="#注意事项-1" class="headerlink" title="注意事项"></a>注意事项</h2><ul><li>如果手机root那么可以直接adb shell执行二进制文件，我的手机没有root所以只能通过termux曲线救国。</li><li><p>因为使用了miracl库，所以得把visualGDB在树莓派上引用的miracl库的目录（第二部分第10步）位置拷到手机的相同位置上。比如树莓派上我的miracl库位置是<code>/home/code/miracl</code>,那我就得把这个文件夹拷到手机上绝对路径相同的地方，同样得是<code>/home/code/miracl</code>。</p></li><li><p>如果有其他输入输出文件，连同二进制文件一起拷到手机上,方法同树莓派环境配置注意事项第一条一致。</p></li><li><p>如果运行出现错误，多半是因为miracl文件夹的绝对位置与树莓派不一致，或者windows上的代码运行时需要读取的文件没加进来。</p></li></ul><h1 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h1><p>所有配置过程不一定是最简洁的，我在配置的过程中也是磕磕绊绊，除了以上的方案其实还有其他办法可以达到相同的效果，所以我的过程仅供参考~如果有问题欢迎留言讨论，文章如果可以有效帮助新入坑miracl的萌新希望可以给你的导师美言几句<strong>snnu的禹勇老师手下的娃文档写的不错</strong>，如果能传到我导的耳朵里说不定他可以在疯狂星期四v我50吃两个奥尔良鸡腿堡<br><img src="https://blogimages.happyshark.cn/PC,%E6%A0%91%E8%8E%93%E6%B4%BE,%E5%AE%89%E5%8D%93%E7%9A%84miracl%E5%BA%93%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/qqpyimg1680538830.png" alt="img"></p><h1 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h1><p><a href="https://www.aflyingfish.top/articles/407987f7a995/">https://www.aflyingfish.top/articles/407987f7a995/</a><br><a href="https://blog.csdn.net/leapoo/article/details/108260941">https://blog.csdn.net/leapoo/article/details/108260941</a><br><a href="https://blog.csdn.net/leapoo/article/details/122927101">https://blog.csdn.net/leapoo/article/details/122927101</a><br><a href="https://blog.csdn.net/hello_baby6/article/details/117407705">https://blog.csdn.net/hello_baby6/article/details/117407705</a><br><a href="https://blog.csdn.net/langshanglibie/article/details/119788253">https://blog.csdn.net/langshanglibie/article/details/119788253</a><br><a href="https://zhuanlan.zhihu.com/p/441333966">https://zhuanlan.zhihu.com/p/441333966</a><br><a href="https://learn.microsoft.com/zh-cn/cpp/linux/deploy-run-and-debug-your-linux-project?view=msvc-170">https://learn.microsoft.com/zh-cn/cpp/linux/deploy-run-and-debug-your-linux-project?view=msvc-170</a><br><a href="https://zhuanlan.zhihu.com/p/433896930">https://zhuanlan.zhihu.com/p/433896930</a><br><a href="https://www.cpp-prog.com/%E7%BC%96%E7%A8%8B/Cross-Compile-Raspberry-Pi/">https://www.cpp-prog.com/%E7%BC%96%E7%A8%8B/Cross-Compile-Raspberry-Pi/</a><br><a href="https://crosstool-ng.github.io/">https://crosstool-ng.github.io/</a><br><a href="https://blog.csdn.net/qq_32312307/article/details/114907522">https://blog.csdn.net/qq_32312307/article/details/114907522</a><br><a href="https://gist.github.com/AndySze/5434903#1%E4%B8%8B%E8%BD%BDct-ng%E6%BA%90%E7%A0%81">https://gist.github.com/AndySze/5434903#1%E4%B8%8B%E8%BD%BDct-ng%E6%BA%90%E7%A0%81</a><br><a href="https://blog.csdn.net/Jymman/article/details/105105570">https://blog.csdn.net/Jymman/article/details/105105570</a><br><a href="https://www.leoxiaofei.com/build-arm-windows.html">https://www.leoxiaofei.com/build-arm-windows.html</a><br><a href="https://gnutoolchains.com/raspberry/tutorial/">https://gnutoolchains.com/raspberry/tutorial/</a><br><a href="https://gnutoolchains.com/raspberry/tutorial/sysroot">https://gnutoolchains.com/raspberry/tutorial/sysroot</a><br><a href="https://visualgdb.com/tutorials/raspberry/">https://visualgdb.com/tutorials/raspberry/</a><br><a href="https://visualgdb.com/tutorials/raspberry/crosscompiler/">https://visualgdb.com/tutorials/raspberry/crosscompiler/</a><br><a href="https://zhuanlan.zhihu.com/p/58949515">https://zhuanlan.zhihu.com/p/58949515</a><br><a href="https://zhuanlan.zhihu.com/p/56030172">https://zhuanlan.zhihu.com/p/56030172</a><br><a href="https://zhuanlan.zhihu.com/p/58920282">https://zhuanlan.zhihu.com/p/58920282</a><br><a href="https://ilyas-hamadouche.medium.com/build-your-c-projects-faster-using-ninja-3d7af9b418fc">https://ilyas-hamadouche.medium.com/build-your-c-projects-faster-using-ninja-3d7af9b418fc</a><br><a href="https://zhuanlan.zhihu.com/p/157362239">https://zhuanlan.zhihu.com/p/157362239</a><br><a href="https://zhuanlan.zhihu.com/p/66735155">https://zhuanlan.zhihu.com/p/66735155</a><br><a href="https://cloud.tencent.com/developer/article/1592277">https://cloud.tencent.com/developer/article/1592277</a><br><a href="https://github.com/miracl/MIRACL/issues/97">https://github.com/miracl/MIRACL/issues/97</a><br><a href="https://zhuanlan.zhihu.com/p/336980673">https://zhuanlan.zhihu.com/p/336980673</a><br><a href="https://www.cnblogs.com/robinex/p/7858410.html">https://www.cnblogs.com/robinex/p/7858410.html</a><br><a href="https://blog.csdn.net/wangzhiyu1980/article/details/16972937">https://blog.csdn.net/wangzhiyu1980/article/details/16972937</a><br><a href="https://github.com/Innovativaltd/RiskAdjustedReturn">https://github.com/Innovativaltd/RiskAdjustedReturn</a><br><a href="https://zhuanlan.zhihu.com/p/56530788">https://zhuanlan.zhihu.com/p/56530788</a><br><a href="https://blog.csdn.net/afei__/article/details/80719691">https://blog.csdn.net/afei__/article/details/80719691</a><br><a href="https://blog.csdn.net/hdanbang/article/details/49403137">https://blog.csdn.net/hdanbang/article/details/49403137</a><br><a href="https://blog.csdn.net/afei__/article/details/80720602">https://blog.csdn.net/afei__/article/details/80720602</a><br><a href="https://visualgdb.com/android/tools">https://visualgdb.com/android/tools</a><br><a href="https://blog.csdn.net/u010144805/article/details/78767694">https://blog.csdn.net/u010144805/article/details/78767694</a><br><a href="https://visualgdb.com/tutorials/android/tests/">https://visualgdb.com/tutorials/android/tests/</a><br><a href="https://visualgdb.com/KB/?ProblemID=host64">https://visualgdb.com/KB/?ProblemID=host64</a><br><a href="https://blog.csdn.net/qq_34508943/article/details/113032733">https://blog.csdn.net/qq_34508943/article/details/113032733</a><br><a href="https://blog.csdn.net/u010801248/article/details/73331484">https://blog.csdn.net/u010801248/article/details/73331484</a><br><a href="https://www.jianshu.com/p/c5b59cbe65f7">https://www.jianshu.com/p/c5b59cbe65f7</a><br><a href="https://stackoverflow.com/questions/9721856/unable-to-include-iostream-in-android-why">https://stackoverflow.com/questions/9721856/unable-to-include-iostream-in-android-why</a><br><a href="https://learn.microsoft.com/zh-cn/xamarin/android/get-started/installation/android-emulator/device-manager?tabs=windows&amp;pivots=windows">https://learn.microsoft.com/zh-cn/xamarin/android/get-started/installation/android-emulator/device-manager?tabs=windows&amp;pivots=windows</a><br><a href="https://learn.microsoft.com/zh-cn/xamarin/android/deploy-test/debugging/debug-on-emulator?tabs=windows">https://learn.microsoft.com/zh-cn/xamarin/android/deploy-test/debugging/debug-on-emulator?tabs=windows</a><br><a href="https://www.fity.cn/post/509.html">https://www.fity.cn/post/509.html</a><br><a href="https://cloud.tencent.com/developer/article/1736604">https://cloud.tencent.com/developer/article/1736604</a><br><a href="https://blog.csdn.net/sinat_28442665/article/details/84136133">https://blog.csdn.net/sinat_28442665/article/details/84136133</a><br><a href="https://wiki.termux.com/wiki/PRoot#Installing_Linux_distributions">https://wiki.termux.com/wiki/PRoot#Installing_Linux_distributions</a><br><a href="https://zhuanlan.zhihu.com/p/95865982">https://zhuanlan.zhihu.com/p/95865982</a><br><a href="https://github.com/kimud6003/MIRACL-raspbian/tree/Raspbian">https://github.com/kimud6003/MIRACL-raspbian/tree/Raspbian</a></p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 技术 </tag>
            
            <tag> miracl </tag>
            
            <tag> 交叉编译 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ubuntu流量统计工具——vnstat</title>
      <link href="/2022/07/10/ubuntu%E6%B5%81%E9%87%8F%E7%BB%9F%E8%AE%A1%E5%B7%A5%E5%85%B7%E2%80%94%E2%80%94vnstat/"/>
      <url>/2022/07/10/ubuntu%E6%B5%81%E9%87%8F%E7%BB%9F%E8%AE%A1%E5%B7%A5%E5%85%B7%E2%80%94%E2%80%94vnstat/</url>
      
        <content type="html"><![CDATA[<h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><h2 id="官网下载"><a href="#官网下载" class="headerlink" title="官网下载"></a>官网下载</h2><p>vnstat tracker：<a href="https://tracker.debian.org/pkg/vnstat">https://tracker.debian.org/pkg/vnstat</a></p><p>编译安装</p><ul><li><p>下载</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 也可以下载对应的tag的源文件</span><br><span class="line">git clone https://github.com/vergoh/vnstat.git</span><br></pre></td></tr></table></figure></li><li><p>安装环境</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install gcc sqlite sqlite-devel make</span><br></pre></td></tr></table></figure></li><li><p>编译&amp;安装</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">cd vnstat &amp;&amp; ./configure --prefix=/usr --sysconfdir=/etc &amp;&amp; make</span><br><span class="line"></span><br><span class="line"># 安装</span><br><span class="line">make install</span><br></pre></td></tr></table></figure></li></ul><h2 id="Debian-Ubuntu"><a href="#Debian-Ubuntu" class="headerlink" title="Debian/Ubuntu"></a>Debian/Ubuntu</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">apt install vnstat</span><br></pre></td></tr></table></figure><h2 id="2-Centos"><a href="#2-Centos" class="headerlink" title="2.Centos"></a>2.Centos</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install vnstat</span><br></pre></td></tr></table></figure><h1 id="初始化设置"><a href="#初始化设置" class="headerlink" title="初始化设置"></a>初始化设置</h1><h2 id="创建开机自启动"><a href="#创建开机自启动" class="headerlink" title="创建开机自启动"></a>创建开机自启动</h2><ul><li><p>复制service</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cp examples/systemd/vnstat.service /etc/systemd/system/</span><br></pre></td></tr></table></figure></li><li><p>设置开机自启</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl enable vnstat</span><br></pre></td></tr></table></figure></li></ul><h2 id="查找网卡"><a href="#查找网卡" class="headerlink" title="查找网卡"></a>查找网卡</h2><ul><li><p>KVM/XEN -&gt;eth0/ens3</p></li><li><p>OpenVZ -&gt;venet0</p></li></ul><blockquote><p>根据自己的实际情况查找到网卡命令：ifconfig</p></blockquote><h2 id="修改配置文件"><a href="#修改配置文件" class="headerlink" title="修改配置文件"></a>修改配置文件</h2><ul><li><p>配置文件默认为月统计,为每月流量结算日期,默认为每月1日</p></li><li><p>网卡默认为eth0,这里需要根据自己的实际情况修改</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">vim /etc/vnstat.conf</span><br><span class="line"></span><br><span class="line"># default interface (leave empty for automatic selection)</span><br><span class="line">Interface &quot;eth0&quot;</span><br><span class="line"></span><br><span class="line"># on which day should months change</span><br><span class="line">MonthRotate 1 </span><br><span class="line">MonthRotateAffectsYears 0</span><br></pre></td></tr></table></figure></li></ul><h2 id="初始化数据库"><a href="#初始化数据库" class="headerlink" title="初始化数据库"></a>初始化数据库</h2><blockquote><p>vnstat新版本已经移除了-u参数,如果是新版本直接进行下一部重启即可</p></blockquote><ul><li><p>KVM/XEN</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vnstat -u -i eth0/ens3</span><br></pre></td></tr></table></figure></li><li><p>OpenVZ</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vnstat -u -i venet0</span><br></pre></td></tr></table></figure></li><li><p>数据库路径</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/var/lib/vnstat/</span><br></pre></td></tr></table></figure></li><li><p>删除数据库</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vnstat --delete --force -i eth0/ens3</span><br></pre></td></tr></table></figure></li></ul><h2 id="4-重启"><a href="#4-重启" class="headerlink" title="4.重启"></a>4.重启</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl restart vnstat</span><br></pre></td></tr></table></figure><h1 id="其余命令"><a href="#其余命令" class="headerlink" title="其余命令"></a>其余命令</h1><h2 id="流量统计查询"><a href="#流量统计查询" class="headerlink" title="流量统计查询"></a>流量统计查询</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">vnstat -l    #实时统计</span><br><span class="line">vnstat -h    #按小时查询</span><br><span class="line">vnstat -d    #按天数查询</span><br><span class="line">vnstat -m    #按月数查询</span><br><span class="line">vnstat -w    #按周数查询</span><br><span class="line">vnstat -t    #查询TOP10</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 技术 </tag>
            
            <tag> v2ray </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>习近平总书记在庆祝中国共产党成立100周年大会上的讲话 Part.23</title>
      <link href="/2022/06/21/%E4%B9%A0%E8%BF%91%E5%B9%B3%E6%80%BB%E4%B9%A6%E8%AE%B0%E5%9C%A8%E5%BA%86%E7%A5%9D%E4%B8%AD%E5%9B%BD%E5%85%B1%E4%BA%A7%E5%85%9A%E6%88%90%E7%AB%8B100%E5%91%A8%E5%B9%B4%E5%A4%A7%E4%BC%9A%E4%B8%8A%E7%9A%84%E8%AE%B2%E8%AF%9D%20Part.23/"/>
      <url>/2022/06/21/%E4%B9%A0%E8%BF%91%E5%B9%B3%E6%80%BB%E4%B9%A6%E8%AE%B0%E5%9C%A8%E5%BA%86%E7%A5%9D%E4%B8%AD%E5%9B%BD%E5%85%B1%E4%BA%A7%E5%85%9A%E6%88%90%E7%AB%8B100%E5%91%A8%E5%B9%B4%E5%A4%A7%E4%BC%9A%E4%B8%8A%E7%9A%84%E8%AE%B2%E8%AF%9D%20Part.23/</url>
      
        <content type="html"><![CDATA[<h1 id="习近平总书记在庆祝中国共产党成立100周年大会上的讲话-Part-23"><a href="#习近平总书记在庆祝中国共产党成立100周年大会上的讲话-Part-23" class="headerlink" title="习近平总书记在庆祝中国共产党成立100周年大会上的讲话 Part.23"></a>习近平总书记在庆祝中国共产党成立100周年大会上的讲话 Part.23</h1><hr><p>同志们、朋友们！</p><p>Comrades and friends,</p><hr><p>一百年前，中国共产党成立时只有50多名党员，今天已经成为拥有9500多万名党员、领导着14亿多人口大国、具有<code>重大全球影响力</code>的<code>世界第一大执政党</code>。</p><p>A century ago, at the time of its founding, the Communist Party of China had just over 50 members. Today, with more than 95 million members in a country of more than 1.4 billion people, it is <code>the largest governing party</code> in the world and enjoys <code>tremendous international influence</code>.</p><ul><li>重大全球影响力 tremendous international influence</li><li>第一大执政党 the largest governing party</li></ul><hr><p>一百年前，中华民族呈现在世界面前的是一派<code>衰败凋零</code>的景象。今天，中华民族向世界展现的是一派<code>欣欣向荣</code>的气象，正以不可阻挡的步伐迈向伟大复兴。</p><p>A century ago, China <code>was in decline and withering away</code> in the eyes of the world. Today, the image it presents to the world is one of a <code>thriving</code>nation that is advancing with <code>unstoppable momentum</code> toward rejuvenation.</p><ul><li>衰败凋零 be in decline and withering away</li><li>欣欣向荣 thriving</li><li>不可阻挡的步伐 unstoppable momentum</li></ul><blockquote><p>中华民族伟大复兴 National rejuvenation</p></blockquote><hr><p>过去一百年，中国共产党向人民、向历史交出了一份优异的答卷。现在，中国共产党团结带领中国人民又踏上了实现第二个百年奋斗目标新的赶考之路。</p><p>Over the past century, the Communist Party of China has secured extraordinary historical achievements on behalf of the people. Today, it is rallying and leading the Chinese people on a new journey toward realizing the second centenary goal.</p><hr><p>全体中国共产党员！党中央号召你们，牢记初心使命，坚定理想信念，践行党的宗旨，永远保持同人民群众的血肉联系，始终同人民想在一起、干在一起，风雨同舟、同甘共苦，继续为实现人民对美好生活的向往不懈努力，努力为党和人民争取更大光荣！</p><p>To all Party members, The Central Committee calls on every one of you to stay true to our Party’s founding mission and <code>stand firm in your ideals and convictions</code>. <code>Acting on the purpose of the Party</code>, you should always <code>maintain close ties with the people</code>, empathize and work with them, <code>stand with them through good times and bad</code>, and continue <code>working tirelessly</code> to realize their aspirations for a better life and to bring still <code>greater glory</code> to the Party and the people.</p><ul><li>坚定理想信念 stand firm in ideals and convictions</li><li>践行党的宗旨 act on the purpose of the Party</li><li>保持同人民群众的血肉联系 maintain close ties with the people</li><li>风雨同舟、同甘共苦 stand with them through goods times and bad</li><li>不懈努力 work tirelessly</li><li>更大光荣 greater glory</li></ul><blockquote><p>全心全意为人民服务根本宗旨 the fundamental purpose of serving the people wholeheartedly/ the principle of serving the people wholeheartedly</p><p>立党为公、执政为民 (the Party’s commitment to) building itself for the public good and exercising power for the people/ (the Party’s commitment to) serving the public good and exercising power in the interests of the people</p><p>全体人民共同富裕 shared prosperity for everyone/ common prosperity for all</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 英语作业 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 英语 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>jsdelivr被墙解决方案——使用自己的域名解析github图床防止被dns污染</title>
      <link href="/2022/05/31/jsdelivr%E8%A2%AB%E5%A2%99%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88%E2%80%94%E2%80%94%E4%BD%BF%E7%94%A8%E8%87%AA%E5%B7%B1%E7%9A%84%E5%9F%9F%E5%90%8D%E8%A7%A3%E6%9E%90github%E5%9B%BE%E5%BA%8A%E9%98%B2%E6%AD%A2%E8%A2%ABdns%E6%B1%A1%E6%9F%93/"/>
      <url>/2022/05/31/jsdelivr%E8%A2%AB%E5%A2%99%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88%E2%80%94%E2%80%94%E4%BD%BF%E7%94%A8%E8%87%AA%E5%B7%B1%E7%9A%84%E5%9F%9F%E5%90%8D%E8%A7%A3%E6%9E%90github%E5%9B%BE%E5%BA%8A%E9%98%B2%E6%AD%A2%E8%A2%ABdns%E6%B1%A1%E6%9F%93/</url>
      
        <content type="html"><![CDATA[<h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>2021年底jsdelivr被取消备案，2022年5月份开始出现dns污染的情况，前两天打开博客图片全都裂了，为了保险起见防止后面cdn永久被墙决定修改图片访问方式，使用自己的备案域名解析到github图片仓库防止被dns污染。</p><h1 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h1><ul><li>已经解析到github的github.io下的域名一个</li><li>博客图床的仓库必须在同一个账号下</li><li>不会被墙的dns解析服务（我使用的是腾讯的dnspod）</li></ul><h1 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h1><ol><li><p>打开github图床仓库，添加一个readme.md文件，随便写几句</p><blockquote><p>这个文件是作为首页使用的，如果想自己设计一个index.html的静态页面也可以，但是不能没有，如果没有的话后面启用https的那个步骤可能 不会成功</p></blockquote><p><img src="https://blogimages.happyshark.cn/jsdelivr被墙解决方案——使用自己的域名解析github图床防止被dns污染/image-20220531170230329.png" alt="image-20220531170230329"></p></li><li><p>登陆你的域名解析控制台，添加以下cname值：</p><ul><li>主机记录：可以自己定义，我这里设置成<code>blogimages</code></li><li>记录值：填写解析到你github.io那个仓库的域名，我是把<code>happyshark.cn</code>解析到了<code>HPShark.github.io</code>,所以这里的记录值填<code>hapyshark.cn</code></li></ul><p><img src="https://blogimages.happyshark.cn/jsdelivr%E8%A2%AB%E5%A2%99%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88%E2%80%94%E2%80%94%E4%BD%BF%E7%94%A8%E8%87%AA%E5%B7%B1%E7%9A%84%E5%9F%9F%E5%90%8D%E8%A7%A3%E6%9E%90github%E5%9B%BE%E5%BA%8A%E9%98%B2%E6%AD%A2%E8%A2%ABdns%E6%B1%A1%E6%9F%93/image-20220531171159648.png" alt="image-20220531171159648"></p></li><li><p>返回图床仓库顶部，点击<code>Settings</code>——<code>Pages</code></p><ul><li>在Source下选择你的图床分支，我的是默认master就选择master。</li><li>Theme Chooser这里如果你在第一步生成的md文件，那就选择一个主题他会帮你把md文件渲染成首页，如果第一步使用的是你自己的index.html静态网页那就不用管这个。</li><li>Custom domain这里填写你的解析域名，也就是第二步中的内容，我这里填的是<code>blogimages.happyshark.cn</code>，填写完点击save，会自动检测解析是否成功</li><li>解析成功后可以勾选下面的Enforce HTTPS，开启https（免费自动续期，不用操心隔一段时间要去续期）</li></ul><p>填写完之后就可以把<code>blogimages.happyshark.cn</code>解析到github图床仓库了</p><p><img src="https://blogimages.happyshark.cn/jsdelivr%E8%A2%AB%E5%A2%99%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88%E2%80%94%E2%80%94%E4%BD%BF%E7%94%A8%E8%87%AA%E5%B7%B1%E7%9A%84%E5%9F%9F%E5%90%8D%E8%A7%A3%E6%9E%90github%E5%9B%BE%E5%BA%8A%E9%98%B2%E6%AD%A2%E8%A2%ABdns%E6%B1%A1%E6%9F%93/image-20220531171918953.png" alt="image-20220531171918953"></p></li></ol><p>配置完成之后随便打开一张图片，比如要访问我的图床<code>仓库</code>-<code>hello-world</code>-<code>20200324151821.png</code>这个文件<br><img src="https://blogimages.happyshark.cn/jsdelivr%E8%A2%AB%E5%A2%99%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88%E2%80%94%E2%80%94%E4%BD%BF%E7%94%A8%E8%87%AA%E5%B7%B1%E7%9A%84%E5%9F%9F%E5%90%8D%E8%A7%A3%E6%9E%90github%E5%9B%BE%E5%BA%8A%E9%98%B2%E6%AD%A2%E8%A2%ABdns%E6%B1%A1%E6%9F%93/image-20220531172430163.png" alt="image-20220531172430163"></p><p>那浏览器中应该输入的地址应该如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://blogimages.happyshark.cn/hello-world/20200324151821.png</span><br></pre></td></tr></table></figure><p>可以看到成功访问了该图片：</p><p><img src="https://blogimages.happyshark.cn/jsdelivr%E8%A2%AB%E5%A2%99%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88%E2%80%94%E2%80%94%E4%BD%BF%E7%94%A8%E8%87%AA%E5%B7%B1%E7%9A%84%E5%9F%9F%E5%90%8D%E8%A7%A3%E6%9E%90github%E5%9B%BE%E5%BA%8A%E9%98%B2%E6%AD%A2%E8%A2%ABdns%E6%B1%A1%E6%9F%93/image-20220531172737655.png" alt="image-20220531172737655"></p><h1 id="如何批量替换老域名"><a href="#如何批量替换老域名" class="headerlink" title="如何批量替换老域名"></a>如何批量替换老域名</h1><p>使用python脚本一键替换即可，代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># coding=utf-8</span></span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> re</span><br><span class="line"></span><br><span class="line">OLD = <span class="string">&quot;https://cdn.jsdelivr.net/gh/HPShark/blogimages@master/&quot;</span> <span class="comment">#原来的cdn加速地址前缀</span></span><br><span class="line">NEW = <span class="string">&quot;https://blogimages.happyshark.cn/&quot;</span> <span class="comment">#修改为你解析域名地址前缀</span></span><br><span class="line">path = <span class="string">&quot;_posts&quot;</span> <span class="comment"># 修改为博文存放的目录</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span>(<span class="params">path</span>):</span></span><br><span class="line">    file_list = [os.path.abspath(os.path.join(root, file)) <span class="keyword">for</span> root, _, files <span class="keyword">in</span> os.walk(path) <span class="keyword">for</span> file <span class="keyword">in</span> files]</span><br><span class="line">    <span class="built_in">print</span>(file_list)</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;start ..\n&quot;</span>)</span><br><span class="line">    <span class="keyword">for</span> f <span class="keyword">in</span> file_list:</span><br><span class="line">        content = <span class="string">&quot;&quot;</span></span><br><span class="line">        <span class="keyword">with</span> <span class="built_in">open</span>(f, <span class="string">&quot;rb&quot;</span>) <span class="keyword">as</span> fp:</span><br><span class="line">            file_content = fp.read()</span><br><span class="line">            content = re.sub(OLD, NEW, file_content.decode(<span class="string">&#x27;utf-8&#x27;</span>))</span><br><span class="line">        <span class="keyword">with</span> <span class="built_in">open</span>(f, <span class="string">&quot;wb&quot;</span>) <span class="keyword">as</span> fp:</span><br><span class="line">            fp.write(content.encode(<span class="string">&#x27;utf-8&#x27;</span>))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    main(path)</span><br></pre></td></tr></table></figure><blockquote><p>放文章的文件夹<code>_posts</code>和python脚本需要放在同一目录下<br><img src="https://blogimages.happyshark.cn/jsdelivr%E8%A2%AB%E5%A2%99%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88%E2%80%94%E2%80%94%E4%BD%BF%E7%94%A8%E8%87%AA%E5%B7%B1%E7%9A%84%E5%9F%9F%E5%90%8D%E8%A7%A3%E6%9E%90github%E5%9B%BE%E5%BA%8A%E9%98%B2%E6%AD%A2%E8%A2%ABdns%E6%B1%A1%E6%9F%93/image-20220531173818414.png" alt="image-20220531173818414"></p></blockquote><p>以上代码会把<code>_posts</code>文件夹下的所有文件中的图片一次性修改，比如将某条博文中图片的url</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://cdn.jsdelivr.net/gh/HPShark/blogimages@master/hello-world/20220513103605.png</span><br></pre></td></tr></table></figure><p>替换为</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://blogimages.happyshark.cn/hello-world/20220513103605.png</span><br></pre></td></tr></table></figure><h1 id="如何在博文中插入用新域名解析的图片"><a href="#如何在博文中插入用新域名解析的图片" class="headerlink" title="如何在博文中插入用新域名解析的图片"></a>如何在博文中插入用新域名解析的图片</h1><p>以PicGo为例，在github图床的设置界面按以下方式设置即可：</p><p><img src="https://blogimages.happyshark.cn/jsdelivr%E8%A2%AB%E5%A2%99%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88%E2%80%94%E2%80%94%E4%BD%BF%E7%94%A8%E8%87%AA%E5%B7%B1%E7%9A%84%E5%9F%9F%E5%90%8D%E8%A7%A3%E6%9E%90github%E5%9B%BE%E5%BA%8A%E9%98%B2%E6%AD%A2%E8%A2%ABdns%E6%B1%A1%E6%9F%93/image-20220531173113105.png" alt="image-20220531173113105"></p><h1 id="存在的bug"><a href="#存在的bug" class="headerlink" title="存在的bug"></a>存在的bug</h1><ul><li><p>使用这种方式后每上传一张图片都会触发一次该仓库的action，所以上传完图片的几分钟内所有图片依然看不了（action正在渲染），这个时间一般在1~2分钟左右，高峰期可能会更慢。渲染完成之后就可以正常解析图片了。</p><p><img src="https://blogimages.happyshark.cn/jsdelivr%E8%A2%AB%E5%A2%99%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88%E2%80%94%E2%80%94%E4%BD%BF%E7%94%A8%E8%87%AA%E5%B7%B1%E7%9A%84%E5%9F%9F%E5%90%8D%E8%A7%A3%E6%9E%90github%E5%9B%BE%E5%BA%8A%E9%98%B2%E6%AD%A2%E8%A2%ABdns%E6%B1%A1%E6%9F%93/image-20220531174115766.png" alt="image-20220531174115766"></p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 技术 </tag>
            
            <tag> 网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SNNU校园网白嫖&amp;校园网nas搭建指南</title>
      <link href="/2022/05/10/SNNU%E6%A0%A1%E5%9B%AD%E7%BD%91%E7%99%BD%E5%AB%96&amp;%E6%A0%A1%E5%9B%AD%E7%BD%91nas%E6%90%AD%E5%BB%BA%E6%8C%87%E5%8D%97/"/>
      <url>/2022/05/10/SNNU%E6%A0%A1%E5%9B%AD%E7%BD%91%E7%99%BD%E5%AB%96&amp;%E6%A0%A1%E5%9B%AD%E7%BD%91nas%E6%90%AD%E5%BB%BA%E6%8C%87%E5%8D%97/</url>
      
        <content type="html"><![CDATA[<hr><h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>12月份和3月份的疫情封宿舍导致只能在宿舍学（mo）习（yu），校园网的免费额度严重不够用，听闻办公区（包括且不限于教室、实验室、图书馆）校园网是免费的，所以有了这篇如果在宿舍区实现校园网免流指南和一些进阶技巧。</p><h1 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h1><p>SNNU校园网的收费原理如下：</p><p><img src="https://blogimages.happyshark.cn/SNNU校园网白嫖&amp;校园网nas搭建指南/%E7%BB%93%E6%9E%84.png" alt=""></p><ul><li>如果你的设备是处在宿舍区（黄色部分），那在这个区域产生的外网流量（经由中央网关发送至互联网产生的流量）会经过计费网关进行计费，在校园宽带自助服务系统的黑色部分就是计费流量<br><img src="https://blogimages.happyshark.cn/SNNU%E6%A0%A1%E5%9B%AD%E7%BD%91%E7%99%BD%E5%AB%96&amp;%E6%A0%A1%E5%9B%AD%E7%BD%91nas%E6%90%AD%E5%BB%BA%E6%8C%87%E5%8D%97/image-20220510235206802.png" alt="image-20220510235206802"></li><li><p>如果你的设备在办公区（绿色部分），那在那在这个区域产生的外网流量（经由中央网关发送至互联网产生的流量）不会产生任何费用，在校园宽带自助服务系统中的流量详情都是绿色的<img src="https://blogimages.happyshark.cn/SNNU%E6%A0%A1%E5%9B%AD%E7%BD%91%E7%99%BD%E5%AB%96&amp;%E6%A0%A1%E5%9B%AD%E7%BD%91nas%E6%90%AD%E5%BB%BA%E6%8C%87%E5%8D%97/image-20220510235546091.png" alt="image-20220510235546091"></p></li><li><p>如果如果你的设备在宿舍区（黄色部分），那在那在这个区域连接办公区（绿色部分）设备产生的内网流量（经由中央网关发送至办公区的流量）不会产生任何费用，在校园宽带自助服务系统中的流量详情中校内流量就属于这种<br><img src="https://blogimages.happyshark.cn/SNNU%E6%A0%A1%E5%9B%AD%E7%BD%91%E7%99%BD%E5%AB%96&amp;%E6%A0%A1%E5%9B%AD%E7%BD%91nas%E6%90%AD%E5%BB%BA%E6%8C%87%E5%8D%97/image-20220510235809299.png" alt="image-20220510235809299"></p></li><li>*如果你的设备在任意区域，那通过校园网ipv6访问外网产生的流量是免费的，在校园宽带自助服务系统中的流量详情中教育网流量就属于这种<br><img src="https://blogimages.happyshark.cn/SNNU%E6%A0%A1%E5%9B%AD%E7%BD%91%E7%99%BD%E5%AB%96&amp;%E6%A0%A1%E5%9B%AD%E7%BD%91nas%E6%90%AD%E5%BB%BA%E6%8C%87%E5%8D%97/image-20220510235956347.png" alt="image-20220510235956347"></li></ul><h1 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h1><ul><li>我们就可以根据原理1、2、3在办公区可以连外网的域内搭一个vpn服务器，让宿舍区的电脑走校内流量（原理3）链接vpn服务器（上图的路线1），在通过vpn服务器将数据包转发到外网（原理2）实现免流（路线2），下面详细介绍这种方法</li><li>*也可以在外网搭一个ipv6的服务器，通过将所有数据包走ipv6转发给公网服务器（原理4）实现免流，这个方法按下不表</li></ul><h1 id="搭建过程"><a href="#搭建过程" class="headerlink" title="搭建过程"></a>搭建过程</h1><h2 id="VPN服务器搭建"><a href="#VPN服务器搭建" class="headerlink" title="VPN服务器搭建"></a>VPN服务器搭建</h2><h3 id="linux（部署到路由器上）"><a href="#linux（部署到路由器上）" class="headerlink" title="linux（部署到路由器上）"></a>linux（部署到路由器上）</h3><p>linux的话github上面有很多一键安装脚本，安装就略过了，以华硕老毛子固件配置为例：</p><ol><li><p>办公区网络搭建vpn服务器，我的路由器（斐讯k2）刷的华硕老毛子自带<code>vpn服务器</code>功能可以直接用，如果是在路由下级建的vpn服务器要在路由器做好端口转发（或者直接dmz主机也行）</p><p><img src="https://blogimages.happyshark.cn/SNNU%E6%A0%A1%E5%9B%AD%E7%BD%91%E7%99%BD%E5%AB%96&amp;%E6%A0%A1%E5%9B%AD%E7%BD%91nas%E6%90%AD%E5%BB%BA%E6%8C%87%E5%8D%97/image-20220511000846748.png" alt="image-20220511000846748"></p></li><li><p>在<code>客户端账号</code>中配置用户名和密码，然后点<code>+</code>确定<br><img src="https://blogimages.happyshark.cn/SNNU%E6%A0%A1%E5%9B%AD%E7%BD%91%E7%99%BD%E5%AB%96&amp;%E6%A0%A1%E5%9B%AD%E7%BD%91nas%E6%90%AD%E5%BB%BA%E6%8C%87%E5%8D%97/image-20220511001047914.png" alt="image-20220511001047914"></p></li></ol><h3 id="windows（如果实验室没有路由器网线直接链接到电脑上的话可以使用这种方案）"><a href="#windows（如果实验室没有路由器网线直接链接到电脑上的话可以使用这种方案）" class="headerlink" title="windows（如果实验室没有路由器网线直接链接到电脑上的话可以使用这种方案）"></a>windows（如果实验室没有路由器网线直接链接到电脑上的话可以使用这种方案）</h3><h4 id="使用SoftEther-VPN-搭建l2tp服务器"><a href="#使用SoftEther-VPN-搭建l2tp服务器" class="headerlink" title="使用SoftEther VPN 搭建l2tp服务器"></a>使用SoftEther VPN 搭建l2tp服务器</h4><p>SoftEther VPN是日本筑波大学的一个研究项目，它包括服务器端、客户端、服务器端管理工具等数个软件，支持 SSL-VPN (SoftEther VPN) 协议、 L2TP/IPsec 协议、 OpenVPN 协议和 Microsoft SSTP 协议，Windows、Linux、Android和IOS等操作系统都可以连接到SoftEther VPN服务器。</p><ol><li><p>访问 <a href="https://www.softether-download.com/cn.aspx">https://www.softether-download.com/cn.aspx</a> 下载服务端，server里面继承了管理工具所以就不用在额外下载manager工具了<br><img src="https://blogimages.happyshark.cn/SNNU%E6%A0%A1%E5%9B%AD%E7%BD%91%E7%99%BD%E5%AB%96&amp;%E6%A0%A1%E5%9B%AD%E7%BD%91nas%E6%90%AD%E5%BB%BA%E6%8C%87%E5%8D%97/image-20220530214102365.png" alt="image-20220530214102365"></p><blockquote><p>当然服务端也可以下载linux版本的，这里只介绍windows版本安装</p></blockquote></li><li><p>下载完后安装，目录选择自己装软件的目录即可，语言选择<code>中文</code>，安装种类选择<code>SoftEther VPN Server</code><br><img src="https://blogimages.happyshark.cn/SNNU%E6%A0%A1%E5%9B%AD%E7%BD%91%E7%99%BD%E5%AB%96&amp;%E6%A0%A1%E5%9B%AD%E7%BD%91nas%E6%90%AD%E5%BB%BA%E6%8C%87%E5%8D%97/=7-2-6.jpg" alt="7-2-6.jpg"></p></li><li><p>安装完成后管理工具就在桌面上了，运行<code>SE-VPN Server Manager (Tools)</code>，选择<code>新设置</code>，在新面板中填写<code>设置名(自定义即可)</code>和<code>主机名（直接勾选下面的链接到本地主机）</code>，点击<code>确定</code>保存配置信息；<br><img src="https://blogimages.happyshark.cn/SNNU%E6%A0%A1%E5%9B%AD%E7%BD%91%E7%99%BD%E5%AB%96&amp;%E6%A0%A1%E5%9B%AD%E7%BD%91nas%E6%90%AD%E5%BB%BA%E6%8C%87%E5%8D%97/image-20220530215127171.png" alt="image-20220530215127171"></p></li><li><p>点击<code>连接</code>，连接到vpn server，首次登陆会让设置一个管理员密码<br><img src="https://blogimages.happyshark.cn/SNNU%E6%A0%A1%E5%9B%AD%E7%BD%91%E7%99%BD%E5%AB%96&amp;%E6%A0%A1%E5%9B%AD%E7%BD%91nas%E6%90%AD%E5%BB%BA%E6%8C%87%E5%8D%97/image-20220530215229299.png" alt="image-20220530215229299"></p></li><li><p>执行简易设置向导，选择<code>远程访问VPN Server</code>后点<code>下一步</code><br><img src="https://blogimages.happyshark.cn/SNNU%E6%A0%A1%E5%9B%AD%E7%BD%91%E7%99%BD%E5%AB%96&amp;%E6%A0%A1%E5%9B%AD%E7%BD%91nas%E6%90%AD%E5%BB%BA%E6%8C%87%E5%8D%97/image-20220530215538281.png" alt="image-20220530215538281"></p></li><li><p>ddns设置页面不用管，直接点下一步<br><img src="https://blogimages.happyshark.cn/SNNU%E6%A0%A1%E5%9B%AD%E7%BD%91%E7%99%BD%E5%AB%96&amp;%E6%A0%A1%E5%9B%AD%E7%BD%91nas%E6%90%AD%E5%BB%BA%E6%8C%87%E5%8D%97/image-20220530215713306.png" alt="image-20220530215713306"></p></li><li><p>此时会提示“此VPN Server已具有支持兼容IPSec/L2TP/EtherIP/L2TPv3协议的VPN Client或VPN路由器的新功能……您要设置IPSec吗？”，选择”是“。勾选以下两个选项，<code>填写“IPsec预共享密钥</code>，确定<br><img src="https://blogimages.happyshark.cn/SNNU%E6%A0%A1%E5%9B%AD%E7%BD%91%E7%99%BD%E5%AB%96&amp;%E6%A0%A1%E5%9B%AD%E7%BD%91nas%E6%90%AD%E5%BB%BA%E6%8C%87%E5%8D%97/image-20220530215916874.png" alt="image-20220530215916874"></p></li><li><p>如果不需要内网穿透那就直接<code>禁用VPN Azure</code><br><img src="https://blogimages.happyshark.cn/SNNU%E6%A0%A1%E5%9B%AD%E7%BD%91%E7%99%BD%E5%AB%96&amp;%E6%A0%A1%E5%9B%AD%E7%BD%91nas%E6%90%AD%E5%BB%BA%E6%8C%87%E5%8D%97/image-20220530220032506.png" alt="image-20220530220032506"></p></li><li><p>添加认证用户<br>点击这个hub-<code>管理虚拟hub-管理用户</code>-<code>新增</code>-在这里填写用户名和密码，认证方式选择密钥认证</p><blockquote><p>这里的密码和上面的预共享密钥不是一个密码</p></blockquote><p><img src="https://blogimages.happyshark.cn/SNNU%E6%A0%A1%E5%9B%AD%E7%BD%91%E7%99%BD%E5%AB%96&amp;%E6%A0%A1%E5%9B%AD%E7%BD%91nas%E6%90%AD%E5%BB%BA%E6%8C%87%E5%8D%97/image-20220530220317856.png" alt="image-20220530220317856"></p></li><li><p>开启NAT转换和DHCP服务<br>点击这个hub-<code>管理虚拟hub</code>-<code>虚拟AT和虚拟 DHCF服务器</code>-<code>启用SecureHAT</code></p><p><img src="https://blogimages.happyshark.cn/SNNU校园网白嫖&amp;校园网nas搭建指南/image-20220530220549599.png" alt="image-20220530220549599"></p></li><li><p>开启tcp1701.500,4500端口和udp1701.500,4500端口：<br>打开<code>控制面板</code>-<code>系统和安全</code>-<code>windows Defender防火墙</code>-点击左侧的<code>高级设置</code>-点击左侧的<code>入站规则</code>-在点击右侧的<code>新建规则</code>,添加以下<strong>两个</strong>协议，注意每个端口用<strong>英文逗号</strong>隔开：</p><ul><li>端口-选择<code>tcp</code>协议，特定本地端口处填1701,500,4500。名称填tcp1701,500,4500，其他默认。<br><img src="https://blogimages.happyshark.cn/SNNU%E6%A0%A1%E5%9B%AD%E7%BD%91%E7%99%BD%E5%AB%96&amp;%E6%A0%A1%E5%9B%AD%E7%BD%91nas%E6%90%AD%E5%BB%BA%E6%8C%87%E5%8D%97/image-20220530221341773.png" alt="image-20220530221341773"></li><li>端口-选择<code>udp</code>协议，特定本地端口处填1701,500,4500。名称填udp1701,500,4500，其他默认。<br><img src="https://blogimages.happyshark.cn/SNNU%E6%A0%A1%E5%9B%AD%E7%BD%91%E7%99%BD%E5%AB%96&amp;%E6%A0%A1%E5%9B%AD%E7%BD%91nas%E6%90%AD%E5%BB%BA%E6%8C%87%E5%8D%97/image-20220530221424007.png" alt="image-20220530221424007"></li></ul></li></ol><p>至此服务器端设置完成。</p><h4 id="通过系统自带的vpn接入点配置server（不建议在除了windows-server的其他windows版本上面使用这种方法，因为无法解决nat问题会导致客户端能访问vpn服务器却无法访问互联网）"><a href="#通过系统自带的vpn接入点配置server（不建议在除了windows-server的其他windows版本上面使用这种方法，因为无法解决nat问题会导致客户端能访问vpn服务器却无法访问互联网）" class="headerlink" title="通过系统自带的vpn接入点配置server（不建议在除了windows server的其他windows版本上面使用这种方法，因为无法解决nat问题会导致客户端能访问vpn服务器却无法访问互联网）"></a><del>通过系统自带的vpn接入点配置server（不建议在除了windows server的其他windows版本上面使用这种方法，因为无法解决nat问题会导致客户端能访问vpn服务器却无法访问互联网）</del></h4><ol><li><p><del>桌面按win+R键打开运行，输入”ncpa.cpl”回车打开改适配器设置界面，点击文件-新建传入连接（如果没有文件选项卡的话请按Alt+F）</del></p><p><del><img src="https://blogimages.happyshark.cn/SNNU%E6%A0%A1%E5%9B%AD%E7%BD%91%E7%99%BD%E5%AB%96&amp;%E6%A0%A1%E5%9B%AD%E7%BD%91nas%E6%90%AD%E5%BB%BA%E6%8C%87%E5%8D%97/image-20220512182152910.png" alt="image-20220512182152910"></del></p></li><li><p><del>添加用户，自定义用户名和密码（这里的用户名和密码就是客户端链接的时候需要输入的用户名和密码）,点击下一步</del><br><del><img src="https://blogimages.happyshark.cn/SNNU%E6%A0%A1%E5%9B%AD%E7%BD%91%E7%99%BD%E5%AB%96&amp;%E6%A0%A1%E5%9B%AD%E7%BD%91nas%E6%90%AD%E5%BB%BA%E6%8C%87%E5%8D%97/image-20220512182551894.png" alt="image-20220512182551894"></del></p></li><li><p><del>勾选<code>通过internet</code>选项，点击下一步</del><br><del><img src="https://blogimages.happyshark.cn/SNNU%E6%A0%A1%E5%9B%AD%E7%BD%91%E7%99%BD%E5%AB%96&amp;%E6%A0%A1%E5%9B%AD%E7%BD%91nas%E6%90%AD%E5%BB%BA%E6%8C%87%E5%8D%97/image-20220512182646078.png" alt="image-20220512182646078"></del></p></li><li><p><del>选择ipv4，然后选择属性，指定ip地址（如果没有全局梯子/nas的需求也可以直接使用DHCP分配），点击允许访问</del><br><del><img src="https://blogimages.happyshark.cn/SNNU%E6%A0%A1%E5%9B%AD%E7%BD%91%E7%99%BD%E5%AB%96&amp;%E6%A0%A1%E5%9B%AD%E7%BD%91nas%E6%90%AD%E5%BB%BA%E6%8C%87%E5%8D%97/image-20220512182954851.png" alt="image-20220512182954851"></del></p><blockquote><p><del>下面还需要放行1723端口和gre协议，如果电脑上级接了路由器那这一步需要在路由器里设置端口转发，如果是网线直接连的电脑那按下面的步骤设置</del></p></blockquote></li><li><p><del>打开<code>控制面板</code>-<code>系统和安全</code>-<code>windows Defender防火墙</code>-点击左侧的<code>高级设置</code>-点击左侧的<code>入站规则</code>-在点击右侧的<code>新建规则</code>,添加以下两个协议：</del></p><ul><li><del>端口-选择tcp协议，特定本地端口处填1723-名称填pptp1723，其他默认。</del><br><del><img src="https://blogimages.happyshark.cn/SNNU%E6%A0%A1%E5%9B%AD%E7%BD%91%E7%99%BD%E5%AB%96&amp;%E6%A0%A1%E5%9B%AD%E7%BD%91nas%E6%90%AD%E5%BB%BA%E6%8C%87%E5%8D%97/image-20220512183536178.png" alt="image-20220512183536178"></del></li><li><del>自定义-协议选择GRE-名称填gre，其他默认</del><br><del><img src="https://blogimages.happyshark.cn/SNNU%E6%A0%A1%E5%9B%AD%E7%BD%91%E7%99%BD%E5%AB%96&amp;%E6%A0%A1%E5%9B%AD%E7%BD%91nas%E6%90%AD%E5%BB%BA%E6%8C%87%E5%8D%97/image-20220512183506585.png" alt="image-20220512183506585"></del></li></ul></li></ol><blockquote><p><del>到这一步vpn服务就配置完了，目前有个已知的问题如果电脑上开了杀毒软件会导致后面客户端连接失败，建议关掉用windows defender就好。</del></p></blockquote><h2 id="客户端配置"><a href="#客户端配置" class="headerlink" title="客户端配置"></a>客户端配置</h2><ol><li><p>宿舍区电脑（windows）打开设置-网络和Internet-vpn-添加vpn链接，添加配置信息后保存</p><ul><li>vpn提供商：windows内置</li><li>链接名称：自己填就好，这是个备注名</li><li>服务器名称或地址：vpn服务器所在域的ip地址，一般是10.xxx.xxx.xxx</li><li>vpn类型：根据服务器选择<ul><li>如果服务端是pptp那就选pptp服务器（上面教程使用windows 自带接入点配置的服务就是pptp）<br><img src="https://blogimages.happyshark.cn/SNNU%E6%A0%A1%E5%9B%AD%E7%BD%91%E7%99%BD%E5%AB%96&amp;%E6%A0%A1%E5%9B%AD%E7%BD%91nas%E6%90%AD%E5%BB%BA%E6%8C%87%E5%8D%97/image-20220530221945124.png" alt="image-20220530221945124"></li><li>如果服务端是l2tp那就选l2tp服务器（共享密钥，上面教程使用SoftEther VPN配置的就是<strong>预共享密钥</strong>的l2tp）<br><img src="https://blogimages.happyshark.cn/SNNU%E6%A0%A1%E5%9B%AD%E7%BD%91%E7%99%BD%E5%AB%96&amp;%E6%A0%A1%E5%9B%AD%E7%BD%91nas%E6%90%AD%E5%BB%BA%E6%8C%87%E5%8D%97/image-20220530222021123.png" alt="image-20220530222021123"></li></ul></li><li>*（可选）：如果选择预共享密钥的l2tp，那还需要输入预共享密钥</li><li>登录信息类型：用户名和密码</li><li>用户名：在vpn服务器中设置的用户名</li><li>密码：在vpn服务器中设置的密码</li></ul></li><li><p>宿舍区电脑通过web网关认证登陆校园网</p></li><li><p>链接vpn</p></li><li><p>最终效果，网络和vpn应该都是已连接状态<br><img src="https://blogimages.happyshark.cn/SNNU%E6%A0%A1%E5%9B%AD%E7%BD%91%E7%99%BD%E5%AB%96&amp;%E6%A0%A1%E5%9B%AD%E7%BD%91nas%E6%90%AD%E5%BB%BA%E6%8C%87%E5%8D%97/image-20220511001631003.png" alt="image-20220511001631003"></p></li></ol><blockquote><p>如果可以浏览网页但是UWP应用（比如Microsoft store，天气app）无法联网的情况需要解除UWP回环代理限制</p></blockquote><ol><li><p>打开管理员模式powershell或者cmd，输入以下内容回车解除UWP应用代理限制：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">FOR /F &quot;tokens=11 delims=\&quot; %p IN (&#x27;REG QUERY &quot;HKCU\Software\Classes\Local Settings\Software\Microsoft\Windows\CurrentVersion\AppContainer\Mappings&quot;&#x27;) DO CheckNetIsolation.exe LoopbackExempt -a -p=%p</span><br></pre></td></tr></table></figure></li></ol><blockquote><p>如果出现连接成功无法上网或者希望vpn域内流量走vpn服务器，正常访问Internet的流量直连，可以进行以下配置。<strong>但是这种配置会使正常访问Internet的流量被计费，按需选择慎用</strong>桌面按win+R键打开运行，输入”ncpa.cpl”回车打开改适配器设置界面，右键vpn链接-<code>属性</code>-<code>网络</code>-点击<code>ipv4</code>-<code>属性</code>-<code>高级</code>-关闭<code>在远程网络上使用默认网关</code>，点确定<br><img src="https://blogimages.happyshark.cn/SNNU%E6%A0%A1%E5%9B%AD%E7%BD%91%E7%99%BD%E5%AB%96&amp;%E6%A0%A1%E5%9B%AD%E7%BD%91nas%E6%90%AD%E5%BB%BA%E6%8C%87%E5%8D%97/image-20220512190801340.png" alt="image-20220512190801340"></p><p>客户端到这里配置就结束了，连接成功后就可以走校内流量免流，如果不放心可以用一下然后登陆校园宽带自助服务系统<a href="http://202.117.144.205/zili/online_list.php">http://202.117.144.205/zili/online_list.php</a> 查看流量使用情况，正常的情况应该是收费流量很少校内流量很多<br><img src="https://blogimages.happyshark.cn/SNNU%E6%A0%A1%E5%9B%AD%E7%BD%91%E7%99%BD%E5%AB%96&amp;%E6%A0%A1%E5%9B%AD%E7%BD%91nas%E6%90%AD%E5%BB%BA%E6%8C%87%E5%8D%97/image-20220511001954532.png" alt="image-20220511001954532"></p></blockquote><h1 id="进阶"><a href="#进阶" class="headerlink" title="进阶"></a>进阶</h1><h2 id="nas映射，远程桌面"><a href="#nas映射，远程桌面" class="headerlink" title="nas映射，远程桌面"></a>nas映射，远程桌面</h2><p>上一步配置成功后所有的流量应该就被转发至vpn服务器了，宿舍的电脑，办公区vpn服务器所在域内其他设备都处于一个局域网中，比如实验室nas的ip为192.168.123.1，实验室电脑的ip为192.168.123.3，宿舍电脑链接vpn后在其所在域的ip地址是192.168.123.2，那就可以把实验室的nas映射到宿舍的电脑上，或者通过实验室电脑内网远控宿舍电脑（高速低延迟稳定性极高）</p><h3 id="nas映射配置"><a href="#nas映射配置" class="headerlink" title="nas映射配置"></a>nas映射配置</h3><ol><li>宿舍电脑打开文件管理器，在最上面输入<code>\\+nas的ip</code>，输入用户名和密码即可链接nas<br><img src="https://blogimages.happyshark.cn/SNNU%E6%A0%A1%E5%9B%AD%E7%BD%91%E7%99%BD%E5%AB%96&amp;%E6%A0%A1%E5%9B%AD%E7%BD%91nas%E6%90%AD%E5%BB%BA%E6%8C%87%E5%8D%97/image-20220511085042144.png" alt="image-20220511085042144"></li><li>然后选择任意一个文件夹，右键-映射网络驱动器即可将这个文件夹映射到本地</li></ol><h3 id="远程桌面"><a href="#远程桌面" class="headerlink" title="远程桌面"></a>远程桌面</h3><p>实验室电脑打开<code>远程桌面</code>ip输入宿舍电脑的局域网ip（192.168.123.2），用户名和密码是宿舍电脑。点击链接即可进行远程控制<br><img src="https://blogimages.happyshark.cn/SNNU%E6%A0%A1%E5%9B%AD%E7%BD%91%E7%99%BD%E5%AB%96&amp;%E6%A0%A1%E5%9B%AD%E7%BD%91nas%E6%90%AD%E5%BB%BA%E6%8C%87%E5%8D%97/image-20220511003138324.png" alt="image-20220511003138324"></p><h2 id="统一梯子服务"><a href="#统一梯子服务" class="headerlink" title="统一梯子服务"></a>统一梯子服务</h2><p>当然既然一个域内都有这么多设备了，那也可以在其中一台电脑上搭一个梯子服务，挂好局域网链接配置之后在其他电脑上配置梯子所在的局域网ip+端口即可让域内所有设备都获得科学上网的能力。以chrome插件switchyOmega为例：</p><p><img src="https://blogimages.happyshark.cn/SNNU%E6%A0%A1%E5%9B%AD%E7%BD%91%E7%99%BD%E5%AB%96&amp;%E6%A0%A1%E5%9B%AD%E7%BD%91nas%E6%90%AD%E5%BB%BA%E6%8C%87%E5%8D%97/image-20220511003509676.png" alt="image-20220511003509676"></p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 技术 </tag>
            
            <tag> 网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>安全规约第五讲——安全规约的困难性</title>
      <link href="/2022/03/05/%E5%AE%89%E5%85%A8%E8%A7%84%E7%BA%A6%E7%AC%AC%E4%BA%94%E8%AE%B2%E2%80%94%E2%80%94%E5%AE%89%E5%85%A8%E8%A7%84%E7%BA%A6%E7%9A%84%E5%9B%B0%E9%9A%BE%E6%80%A7/"/>
      <url>/2022/03/05/%E5%AE%89%E5%85%A8%E8%A7%84%E7%BA%A6%E7%AC%AC%E4%BA%94%E8%AE%B2%E2%80%94%E2%80%94%E5%AE%89%E5%85%A8%E8%A7%84%E7%BA%A6%E7%9A%84%E5%9B%B0%E9%9A%BE%E6%80%A7/</url>
      
        <content type="html"><![CDATA[<h1 id="安全规约所涉及到的问题"><a href="#安全规约所涉及到的问题" class="headerlink" title="安全规约所涉及到的问题"></a>安全规约所涉及到的问题</h1><p><img src="https://blogimages.happyshark.cn/%E5%AE%89%E5%85%A8%E8%A7%84%E7%BA%A6%E7%AC%AC%E4%BA%94%E8%AE%B2/16345598490425.jpg" alt=""><br>矛盾点：</p><ol><li>敌手可以攻破一个真实方案（real）</li><li>但是我们要求敌手要攻破一个模拟方案（simulated）</li></ol><p><img src="https://blogimages.happyshark.cn/%E5%AE%89%E5%85%A8%E8%A7%84%E7%BA%A6%E7%AC%AC%E4%BA%94%E8%AE%B2/16345598712532.jpg" alt=""></p><ul><li>当given scheme不像real scheme的时候我们不知道敌手的攻击态度</li><li>当given scheme 看起来像real scheme的时候我们不知道敌手的具体攻击过程</li></ul><p><img src="https://blogimages.happyshark.cn/%E5%AE%89%E5%85%A8%E8%A7%84%E7%BA%A6%E7%AC%AC%E4%BA%94%E8%AE%B2/16345600638754.jpg" alt=""><br>形象的说，我们的目标和敌手的目标不一致</p><h1 id="模拟-amp-模拟之后发生的事情（simulated）"><a href="#模拟-amp-模拟之后发生的事情（simulated）" class="headerlink" title="模拟&amp;模拟之后发生的事情（simulated）"></a>模拟&amp;模拟之后发生的事情（simulated）</h1><p><img src="https://blogimages.happyshark.cn/%E5%AE%89%E5%85%A8%E8%A7%84%E7%BA%A6%E7%AC%AC%E4%BA%94%E8%AE%B2/16345601286032.jpg" alt=""></p><h2 id="成功的模拟（successful-simulation）"><a href="#成功的模拟（successful-simulation）" class="headerlink" title="成功的模拟（successful simulation）"></a>成功的模拟（successful simulation）</h2><p><img src="https://blogimages.happyshark.cn/%E5%AE%89%E5%85%A8%E8%A7%84%E7%BA%A6%E7%AC%AC%E4%BA%94%E8%AE%B2/16345602176238.jpg" alt=""></p><ul><li>模拟必须要定义什么时候abort：比如在面对敌手询问签名时不知道如何回答的情况下就必须abort</li></ul><p>一个成功的模拟，整个过程中不应该出现abort，而且对于所有来自敌手的response都应该是正确的</p><p><img src="https://blogimages.happyshark.cn/%E5%AE%89%E5%85%A8%E8%A7%84%E7%BA%A6%E7%AC%AC%E4%BA%94%E8%AE%B2/16345604793648.jpg" alt=""></p><ul><li>区分real scheme和simulated scheme一般通过正确性和随机性两种方法，一般不考虑第三种方法（response时间等等）</li><li>randomness：随机数，必须符合随机规律，否则可能会被敌手识别出时simulated scheme</li><li>correctness同理</li></ul><h2 id="敌手的攻击（attack）"><a href="#敌手的攻击（attack）" class="headerlink" title="敌手的攻击（attack）"></a>敌手的攻击（attack）</h2><p><img src="https://blogimages.happyshark.cn/%E5%AE%89%E5%85%A8%E8%A7%84%E7%BA%A6%E7%AC%AC%E4%BA%94%E8%AE%B2/16345606842841.jpg" alt=""><br>对于最后两种，根据能否转化为解决困难问题可以分为两大类：useless attack 和 useful attack</p><ul><li>useless attack：不能用敌手的攻击解决困难问题。</li><li>useful attack：敌手的攻击可以转化为解决困难问题。</li></ul><blockquote><p>卧报的某一期有更详细的解释</p></blockquote><p>例子：</p><p><img src="https://blogimages.happyshark.cn/安全规约第五讲/16345608249863.jpg" alt=""><br><img src="https://blogimages.happyshark.cn/%E5%AE%89%E5%85%A8%E8%A7%84%E7%BA%A6%E7%AC%AC%E4%BA%94%E8%AE%B2/16345611736435.jpg" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> 密码学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 安全规约 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>安全规约第四讲——安全规约入门</title>
      <link href="/2022/03/04/%E5%AE%89%E5%85%A8%E8%A7%84%E7%BA%A6%E7%AC%AC%E5%9B%9B%E8%AE%B2%E2%80%94%E2%80%94%E5%AE%89%E5%85%A8%E8%A7%84%E7%BA%A6%E5%85%A5%E9%97%A8/"/>
      <url>/2022/03/04/%E5%AE%89%E5%85%A8%E8%A7%84%E7%BA%A6%E7%AC%AC%E5%9B%9B%E8%AE%B2%E2%80%94%E2%80%94%E5%AE%89%E5%85%A8%E8%A7%84%E7%BA%A6%E5%85%A5%E9%97%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="计算复杂性的规约理论"><a href="#计算复杂性的规约理论" class="headerlink" title="计算复杂性的规约理论"></a>计算复杂性的规约理论</h1><p>大致框架如下：<br><img src="https://blogimages.happyshark.cn/%E5%AE%89%E5%85%A8%E8%A7%84%E7%BA%A6%E7%AC%AC%E5%9B%9B%E8%AE%B2/16345548801794.jpg" alt=""></p><ul><li>关于不可能：源于p和np问题是否等价未证明</li><li>计算问题里的表达方式和安全问题里的表达方式是相反的</li><li>一般表达的时候描述为a比b简单 </li></ul><p><img src="https://blogimages.happyshark.cn/%E5%AE%89%E5%85%A8%E8%A7%84%E7%BA%A6%E7%AC%AC%E5%9B%9B%E8%AE%B2/16345555427447.jpg" alt=""></p><ul><li>解决b可以转化成解决a（a比b简单，故可通过解决b转化为解决a）</li></ul><blockquote><p>规约的描述是从较难到更难的过程，所谓规约就是证明我们关心的方案不比已有的方案简单，即研究一个问题困难度的下限</p></blockquote><p>一些例子：<br><img src="https://blogimages.happyshark.cn/%E5%AE%89%E5%85%A8%E8%A7%84%E7%BA%A6%E7%AC%AC%E5%9B%9B%E8%AE%B2/16345557750281.jpg" alt=""></p><ol><li>先输入problem A 的instence</li><li>想办法转化成b中的insetence</li><li>在将b的solution转化回a</li></ol><p><img src="https://blogimages.happyshark.cn/%E5%AE%89%E5%85%A8%E8%A7%84%E7%BA%A6%E7%AC%AC%E5%9B%9B%E8%AE%B2/16345559111667.jpg" alt=""></p><ul><li>proof的重点：如何构造参数使得b可以转化为a</li></ul><blockquote><p>故有时候review证明者的思路可以尝试从后往前看</p><p>只可意会不可言传</p></blockquote><p>例子2<br><img src="https://blogimages.happyshark.cn/%E5%AE%89%E5%85%A8%E8%A7%84%E7%BA%A6%E7%AC%AC%E5%9B%9B%E8%AE%B2/16345561004653.jpg" alt=""></p><p>例子3<br><img src="https://blogimages.happyshark.cn/%E5%AE%89%E5%85%A8%E8%A7%84%E7%BA%A6%E7%AC%AC%E5%9B%9B%E8%AE%B2/16345561430593.jpg" alt=""></p><p><img src="https://blogimages.happyshark.cn/%E5%AE%89%E5%85%A8%E8%A7%84%E7%BA%A6%E7%AC%AC%E5%9B%9B%E8%AE%B2/16345562172873.jpg" alt=""></p><ul><li>随机选取w（ramdomly choose）：只有这么设置，才能使得b中的instence space可以做到随机选取，具体原因和计算复杂性有关*。</li></ul><h1 id="密码中的安全规约"><a href="#密码中的安全规约" class="headerlink" title="密码中的安全规约"></a>密码中的安全规约</h1><p><img src="https://blogimages.happyshark.cn/%E5%AE%89%E5%85%A8%E8%A7%84%E7%BA%A6%E7%AC%AC%E5%9B%9B%E8%AE%B2/16345564099768.jpg" alt=""></p><p>规约：problem-&gt;problem<br>安全规约：problem-&gt;scheme</p><p>安全规约的作用：解决一个困难问题要比攻破一个安全方案简单</p><p>注：安全规约和安全分析是不一样的，安全分析更多注重于已知的攻击算法，对于未公开的安全攻击方式无能为力，而安全规约则可以囊括一整个安全模型下的所有攻击方式，即使它没有公开。</p><h2 id="证明策略"><a href="#证明策略" class="headerlink" title="证明策略"></a>证明策略</h2><p><img src="https://blogimages.happyshark.cn/%E5%AE%89%E5%85%A8%E8%A7%84%E7%BA%A6%E7%AC%AC%E5%9B%9B%E8%AE%B2/16345569503800.jpg" alt=""></p><h2 id="具体的框架-amp-解释"><a href="#具体的框架-amp-解释" class="headerlink" title="具体的框架&amp;解释"></a>具体的框架&amp;解释</h2><p>首先做出一些定义<br><img src="https://blogimages.happyshark.cn/%E5%AE%89%E5%85%A8%E8%A7%84%E7%BA%A6%E7%AC%AC%E5%9B%9B%E8%AE%B2/16345570243368.jpg" alt=""></p><p>证明开始之前需要假设一个敌手</p><ul><li>先模拟一个方案，设定允许询问什么&amp;计算什么</li><li>如何提取出yp</li><li>分析解决困难问题p的优势是不可忽略的</li></ul><p>Q：安全规约一定要分析嘛？<br>A：没有分析的安全规约一定不是完整的</p><p><img src="https://blogimages.happyshark.cn/%E5%AE%89%E5%85%A8%E8%A7%84%E7%BA%A6%E7%AC%AC%E5%9B%9B%E8%AE%B2/16345572932255.jpg" alt=""></p><blockquote><p>安全规约更多的是证明a和b的关系，至于b是否存在不考虑</p></blockquote><p><strong>一些容易混淆的概念</strong><br><img src="https://blogimages.happyshark.cn/%E5%AE%89%E5%85%A8%E8%A7%84%E7%BA%A6%E7%AC%AC%E5%9B%9B%E8%AE%B2/16345574057803.jpg" alt=""><br>real scheme VS simulated scheme<br><img src="https://blogimages.happyshark.cn/%E5%AE%89%E5%85%A8%E8%A7%84%E7%BA%A6%E7%AC%AC%E5%9B%9B%E8%AE%B2/16345574683853.jpg" alt=""></p><p>real scheme：通过运行算法得来的<br>simulated scheme：</p><p>challenger VS simulator<br><img src="https://blogimages.happyshark.cn/%E5%AE%89%E5%85%A8%E8%A7%84%E7%BA%A6%E7%AC%AC%E5%9B%9B%E8%AE%B2/16345575395508.jpg" alt=""><br>challenger：最好出现在安全模型里<br>simulator：最好出现在安全规约里</p><p>real attack VS simulation </p><p><img src="https://blogimages.happyshark.cn/%E5%AE%89%E5%85%A8%E8%A7%84%E7%BA%A6%E7%AC%AC%E5%9B%9B%E8%AE%B2/16345576404200.jpg" alt=""></p><ul><li>informations：敌手需要知道的信息，根据模型而来的</li><li>二者的区别可以粗暴的理解成两个平行世界的角色</li></ul><p><img src="https://blogimages.happyshark.cn/%E5%AE%89%E5%85%A8%E8%A7%84%E7%BA%A6%E7%AC%AC%E5%9B%9B%E8%AE%B2/16345577083721.jpg" alt=""></p><blockquote><p>有点类似于网络聊天中判队对方是人是狗</p></blockquote><ul><li>这里的规约算法只需模拟出敌手要的结果而已而不是整个算法，比如在证明cpa安全的时候我们无需把所有具体的算法都模拟出来</li></ul><h2 id="indistinguishable"><a href="#indistinguishable" class="headerlink" title="indistinguishable"></a>indistinguishable</h2><p><img src="https://blogimages.happyshark.cn/%E5%AE%89%E5%85%A8%E8%A7%84%E7%BA%A6%E7%AC%AC%E5%9B%9B%E8%AE%B2/16345579046300.jpg" alt=""><br>如果不能判断b是通过哪种方法计算的，则称indistinguishable</p><blockquote><p> 注：这里的a要随机选取，否则可能会出现可区分行，比如如果a=1的概率超级高，则在选择方法的时候就可以对结果进行区分。</p></blockquote><h2 id="breaking-to-solution"><a href="#breaking-to-solution" class="headerlink" title="breaking to solution"></a>breaking to solution</h2><p><img src="https://blogimages.happyshark.cn/%E5%AE%89%E5%85%A8%E8%A7%84%E7%BA%A6%E7%AC%AC%E5%9B%9B%E8%AE%B2/16345581246358.jpg" alt=""><br>可以通过三种方式转换</p><p><img src="https://blogimages.happyshark.cn/%E5%AE%89%E5%85%A8%E8%A7%84%E7%BA%A6%E7%AC%AC%E5%9B%9B%E8%AE%B2/16345581808667.jpg" alt=""><br>一二种比较常见<br>第三种比较特殊，是将一个判别式的规约问题转化为计算的规约问题</p><p><img src="https://blogimages.happyshark.cn/%E5%AE%89%E5%85%A8%E8%A7%84%E7%BA%A6%E7%AC%AC%E5%9B%9B%E8%AE%B2/16345584839722.jpg" alt=""><br>T=Ｏ(q)：与询问次数有关，消不掉<br>q：与安全模型相关</p><h2 id="tight-reduction-amp-Loose-Reduction"><a href="#tight-reduction-amp-Loose-Reduction" class="headerlink" title="tight reduction &amp; Loose Reduction"></a>tight reduction &amp; Loose Reduction</h2><p><img src="https://blogimages.happyshark.cn/%E5%AE%89%E5%85%A8%E8%A7%84%E7%BA%A6%E7%AC%AC%E5%9B%9B%E8%AE%B2/16345586101617.jpg" alt=""></p><ul><li>目前所有的安全规约的方案都无法消除simulation time</li></ul><p><img src="https://blogimages.happyshark.cn/%E5%AE%89%E5%85%A8%E8%A7%84%E7%BA%A6%E7%AC%AC%E5%9B%9B%E8%AE%B2/16345587245646.jpg" alt=""></p><ul><li>tight reduction：仍然比loose reduction好</li><li>tight reduction会影响计算效率，如果一个方案需要考虑效率不要用这个</li><li>投偏应用的期刊（ieee）不要用tight reduction，会很别扭</li></ul><h2 id="lower-bound-security-level"><a href="#lower-bound-security-level" class="headerlink" title="lower bound security level"></a>lower bound security level</h2><p><img src="https://blogimages.happyshark.cn/%E5%AE%89%E5%85%A8%E8%A7%84%E7%BA%A6%E7%AC%AC%E5%9B%9B%E8%AE%B2/16345589181207.jpg" alt=""></p><p>concrete security：<br><img src="https://blogimages.happyshark.cn/%E5%AE%89%E5%85%A8%E8%A7%84%E7%BA%A6%E7%AC%AC%E5%9B%9B%E8%AE%B2/16345589535483.jpg" alt=""></p><p><img src="https://blogimages.happyshark.cn/%E5%AE%89%E5%85%A8%E8%A7%84%E7%BA%A6%E7%AC%AC%E5%9B%9B%E8%AE%B2/16345591531908.jpg" alt=""></p><ul><li>l和t越小越好，似的右边的值无限接近2^k</li></ul><h2 id="完美的安全规约"><a href="#完美的安全规约" class="headerlink" title="完美的安全规约"></a>完美的安全规约</h2><p>需要满足以下四点：<br><img src="https://blogimages.happyshark.cn/%E5%AE%89%E5%85%A8%E8%A7%84%E7%BA%A6%E7%AC%AC%E5%9B%9B%E8%AE%B2/16345592681346.jpg" alt=""></p><p>但一般情况下这四点互斥，即无法达到多块好省。如下图：<br><img src="https://blogimages.happyshark.cn/%E5%AE%89%E5%85%A8%E8%A7%84%E7%BA%A6%E7%AC%AC%E5%9B%9B%E8%AE%B2/16345593422148.jpg" alt=""></p><ul><li>tradeoff：很神奇，覆盖了computer science</li></ul>]]></content>
      
      
      <categories>
          
          <category> 密码学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 安全规约 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>安全规约第三讲——困难问题和安全规约的基本解释</title>
      <link href="/2022/03/03/%E5%AE%89%E5%85%A8%E8%A7%84%E7%BA%A6%E7%AC%AC%E4%B8%89%E8%AE%B2%E2%80%94%E2%80%94%E5%9B%B0%E9%9A%BE%E9%97%AE%E9%A2%98%E5%92%8C%E5%AE%89%E5%85%A8%E8%A7%84%E7%BA%A6%E7%9A%84%E5%9F%BA%E6%9C%AC%E8%A7%A3%E9%87%8A/"/>
      <url>/2022/03/03/%E5%AE%89%E5%85%A8%E8%A7%84%E7%BA%A6%E7%AC%AC%E4%B8%89%E8%AE%B2%E2%80%94%E2%80%94%E5%9B%B0%E9%9A%BE%E9%97%AE%E9%A2%98%E5%92%8C%E5%AE%89%E5%85%A8%E8%A7%84%E7%BA%A6%E7%9A%84%E5%9F%BA%E6%9C%AC%E8%A7%A3%E9%87%8A/</url>
      
        <content type="html"><![CDATA[<p><strong>computing problem</strong></p><p><img src="https://blogimages.happyshark.cn/%E5%AE%89%E5%85%A8%E8%A7%84%E7%BA%A6%E7%AC%AC%E4%B8%89%E8%AE%B2/image-20220530225850353.png" alt="image-20220530225850353"></p><ul><li>一种定义在数学原语上的数学对象</li><li>x指问题实例，y指其解，有无限多对</li><li>大多数情况下随着x增加计算y的开销会随之变大，但不是所有情况都如此</li></ul><p>计算问题可以分为两大类：computational problems 和 decisional problems</p><p>关于computing problem：</p><p>在计算问题中，一般最大类是computing problems</p><p>在计算复杂性中一般最大类是computational peoblems</p><p>密码学中又分成computational problems 和 decisional problems</p><p>当然在其他地方会混淆</p><p>关于计算复杂性</p><p>通过计算随着x的增加y增加的速度，从而判断其增长的速度可以达到哪个层次是计算复杂性最核心的问题之一</p><p><strong>computational problem</strong></p><p><img src="https://blogimages.happyshark.cn/%E5%AE%89%E5%85%A8%E8%A7%84%E7%BA%A6%E7%AC%AC%E4%B8%89%E8%AE%B2/image-20220530225909308.png" alt="image-20220530225909308"></p><ul><li>large space：可以简单通俗的理解为y的空间与x空间数量级一致</li><li>computational problem 也可以被称为 search problem，维基百科上面也有function problem的说法</li></ul><p><strong>Decisional problem</strong></p><p><img src="https://blogimages.happyshark.cn/%E5%AE%89%E5%85%A8%E8%A7%84%E7%BA%A6%E7%AC%AC%E4%B8%89%E8%AE%B2/image-20220530225924204.png" alt="image-20220530225924204"></p><ul><li>{0,1}不一定代表数学上的0和1，也可代表true or false</li><li>formal language：</li></ul><p><img src="https://blogimages.happyshark.cn/%E5%AE%89%E5%85%A8%E8%A7%84%E7%BA%A6%E7%AC%AC%E4%B8%89%E8%AE%B2/4oYS3jZ9dDAN2Tk.jpg" alt=""></p><ul><li>formal language：可以理解为一些字符组成的集合。</li></ul><h2 id="确定性-amp-概率"><a href="#确定性-amp-概率" class="headerlink" title="确定性&amp;概率"></a>确定性&amp;概率</h2><p><img src="https://blogimages.happyshark.cn/%E5%AE%89%E5%85%A8%E8%A7%84%E7%BA%A6%E7%AC%AC%E4%B8%89%E8%AE%B2/Ae5VOGCfI6wUo8p.jpg" alt=""></p><ul><li>所有的算法都可以分为两大类：确定算法&amp;概率算法</li><li>一般认为概率算法比确定算法更有效，比如攻破一些方案的时候。</li><li>一般用（t，ε）表示一个方案在运行了t时间后返回一个正确答案的概率是ε。</li></ul><blockquote><p>做素数测试的时候会用到概率算法，而且非常有效，但目前没有办法说明其比确定算法更有效。但目前的例子说明了这一现象，故使用了believed而不是proofed</p></blockquote><h2 id="算法的分类"><a href="#算法的分类" class="headerlink" title="算法的分类"></a>算法的分类</h2><p><img src="https://blogimages.happyshark.cn/%E5%AE%89%E5%85%A8%E8%A7%84%E7%BA%A6%E7%AC%AC%E4%B8%89%E8%AE%B2/VUb6Q14HqWfoum9.jpg" alt=""></p><ul><li>方案算法：构造一种方案</li><li>攻击算法</li><li>solution algorithm</li><li>规约算法</li></ul><blockquote><p>算法的分类可以更方便的去对一些行为进行定义</p></blockquote><h2 id="ploynomial-and-exponential"><a href="#ploynomial-and-exponential" class="headerlink" title="ploynomial and exponential"></a>ploynomial and exponential</h2><p><img src="https://blogimages.happyshark.cn/%E5%AE%89%E5%85%A8%E8%A7%84%E7%BA%A6%E7%AC%AC%E4%B8%89%E8%AE%B2/2dZYPLobI73pyKW.jpg" alt=""></p><p>一下是非正式的分类</p><ul><li>ploynomial：是对f上限的定义</li><li>exponential：对f下限的定义</li></ul><p><img src="https://blogimages.happyshark.cn/%E5%AE%89%E5%85%A8%E8%A7%84%E7%BA%A6%E7%AC%AC%E4%B8%89%E8%AE%B2/iMkIPSNp34OTFtE.jpg" alt=""></p><ul><li>二者不是具体的的数值，而是反映了一种速度的趋势（二阶导）</li><li>2^160不算指数时间，因为他是确定的，只有2^λ才是</li></ul><blockquote><p>我们希望在多项式时间以内指数时间以上，通过这种方式吧合法用户和敌手分开：用户的合法计算时间很快，而敌手攻击的时间很慢</p></blockquote><h2 id="Negligible-and-Non-Negligible"><a href="#Negligible-and-Non-Negligible" class="headerlink" title="Negligible and Non-Negligible"></a>Negligible and Non-Negligible</h2><p><img src="https://blogimages.happyshark.cn/%E5%AE%89%E5%85%A8%E8%A7%84%E7%BA%A6%E7%AC%AC%E4%B8%89%E8%AE%B2/WmEoQtO17wbPZyl.jpg" alt=""><br>可忽略&amp;不可忽略</p><ul><li>关于 cannot：f是以指数级的形式快速接近0，故可以忽略</li><li>关于super- ploynomial：多项式曲线以上的东西都称之</li><li>关于speed：同上，是一种趋势</li></ul><h2 id="概率-Probability"><a href="#概率-Probability" class="headerlink" title="概率 Probability"></a>概率 Probability</h2><p><img src="https://blogimages.happyshark.cn/%E5%AE%89%E5%85%A8%E8%A7%84%E7%BA%A6%E7%AC%AC%E4%B8%89%E8%AE%B2/m8rP5d6jawoyB2h.jpg" alt=""></p><p>Q：为什么用概率算法而不用确定算法？<br>A：上文说过，概率算法更加有效</p><p><img src="https://blogimages.happyshark.cn/%E5%AE%89%E5%85%A8%E8%A7%84%E7%BA%A6%E7%AC%AC%E4%B8%89%E8%AE%B2/XvbBj3QnUrOuw4q.jpg" alt=""></p><ul><li>为啥要大于等于0:即使敌手输出一个签名在签名空间里面的概率等于0也是会发生的</li><li>在加密的时候为啥是1/2:在加密的时候敌手只有true &amp; false两种，故随机猜测的概率最少也要大于1/2</li></ul><p><img src="https://blogimages.happyshark.cn/%E5%AE%89%E5%85%A8%E8%A7%84%E7%BA%A6%E7%AC%AC%E4%B8%89%E8%AE%B2/oAhYiFdjbnZf8er.jpg" alt=""></p><p><img src="https://blogimages.happyshark.cn/%E5%AE%89%E5%85%A8%E8%A7%84%E7%BA%A6%E7%AC%AC%E4%B8%89%E8%AE%B2/CStM7oEfGF2uVyT.jpg" alt=""></p><ul><li>advantage：指在不同的事件中其概率不一致</li><li>给定一个概率值，无法区分一种攻击是否是成功or失败的攻击</li><li>advantage是一种调整后的概率来代替probability</li><li>最小值必须是0</li></ul><blockquote><p>实际上，为了给定一个概率值去区分敌手是否成功或者失败才发明了这个东西</p></blockquote><h2 id="定义advantage"><a href="#定义advantage" class="headerlink" title="定义advantage"></a>定义advantage</h2><p><img src="https://blogimages.happyshark.cn/%E5%AE%89%E5%85%A8%E8%A7%84%E7%BA%A6%E7%AC%AC%E4%B8%89%E8%AE%B2/1WYyQHBtrXJRMKj.jpg" alt=""><br>pideal：在不获得任何信息的情况下盲猜的最大概率。</p><ul><li>上图显示了probability和advantage的区别</li></ul><blockquote><p>和前面的ε类似，需要在具体的语境和问题下才能确定probability和advantage是否等价</p></blockquote><p><img src="https://blogimages.happyshark.cn/%E5%AE%89%E5%85%A8%E8%A7%84%E7%BA%A6%E7%AC%AC%E4%B8%89%E8%AE%B2/EIFNhrksUx4ARY1.jpg" alt=""></p><p>一般我们不讨论advantage多大，只讨论其是否可被忽略</p><ul><li>推荐使用第二种定义，这样可以保证统一性，比如数字签名，加密等，这样的好处是其概率都处于0和1之间。</li></ul><p><img src="https://blogimages.happyshark.cn/%E5%AE%89%E5%85%A8%E8%A7%84%E7%BA%A6%E7%AC%AC%E4%B8%89%E8%AE%B2/3zqJpNXoPkE4nm2.jpg" alt=""></p><p>通过验证advantage是否可忽略，可以轻松的确定任何一种方案是否是安全的，换句话说，如果advantage时可忽略的，则方案时安全的</p><h1 id="困难问题"><a href="#困难问题" class="headerlink" title="困难问题"></a>困难问题</h1><h2 id="计算型困难问题"><a href="#计算型困难问题" class="headerlink" title="计算型困难问题"></a>计算型困难问题</h2><p><img src="https://blogimages.happyshark.cn/%E5%AE%89%E5%85%A8%E8%A7%84%E7%BA%A6%E7%AC%AC%E4%B8%89%E8%AE%B2/cQYKh3jRFoEJw9A.jpg" alt=""></p><ul><li>关于random：涉及到了平均统计，不仅仅根据具体的x和y计算出来的，而是根据所有的x和y计算出来的</li></ul><p><img src="https://blogimages.happyshark.cn/%E5%AE%89%E5%85%A8%E8%A7%84%E7%BA%A6%E7%AC%AC%E4%B8%89%E8%AE%B2/SAWirBYXQFHNIVx.jpg" alt=""></p><p>判别式定义如上，参数解释如下：</p><ul><li>A(x)=True|x=True:当x=true的时候敌手猜中的概率</li><li>A(x)=True|x=False:猜错的的概率</li></ul><p><img src="https://blogimages.happyshark.cn/%E5%AE%89%E5%85%A8%E8%A7%84%E7%BA%A6%E7%AC%AC%E4%B8%89%E8%AE%B2/ER26WPjGIyfVlXb.jpg" alt=""></p><p>一些注解：<br><img src="https://blogimages.happyshark.cn/%E5%AE%89%E5%85%A8%E8%A7%84%E7%BA%A6%E7%AC%AC%E4%B8%89%E8%AE%B2/DUVAhndepMIW8Jy.jpg" alt=""></p><ul><li>对一些关键词不需要进行替换</li><li>weak &amp; strong 是好是坏需要结合语境和具体问题</li></ul><p><img src="https://blogimages.happyshark.cn/%E5%AE%89%E5%85%A8%E8%A7%84%E7%BA%A6%E7%AC%AC%E4%B8%89%E8%AE%B2/QoJPKFnrR9f47I6.jpg" alt=""></p><p>所有的assumption都可以分成两大类</p><blockquote><p>如果问题越难，则假设越弱<br>如果问题越弱，则假设越强</p></blockquote><p><img src="https://blogimages.happyshark.cn/%E5%AE%89%E5%85%A8%E8%A7%84%E7%BA%A6%E7%AC%AC%E4%B8%89%E8%AE%B2/eHMYiWtQb9K4JaI.jpg" alt=""></p><ul><li>只要是在安全模型下方案是安全的即可，一般来说在超出设定的场景中使用方案导致不安全的概率要大于方案本身出现不安全情况的概率</li></ul><p><img src="https://blogimages.happyshark.cn/%E5%AE%89%E5%85%A8%E8%A7%84%E7%BA%A6%E7%AC%AC%E4%B8%89%E8%AE%B2/Xhlmy3kLiTUPr9C.jpg" alt=""></p><ul><li>详见密码学报的文章</li></ul><p><img src="https://blogimages.happyshark.cn/%E5%AE%89%E5%85%A8%E8%A7%84%E7%BA%A6%E7%AC%AC%E4%B8%89%E8%AE%B2/s5bezU63Gk1wjJd.jpg" alt=""></p><p><img src="https://blogimages.happyshark.cn/%E5%AE%89%E5%85%A8%E8%A7%84%E7%BA%A6%E7%AC%AC%E4%B8%89%E8%AE%B2/jFSsMTfP8ALV7xo.jpg" alt=""></p><h2 id="困难问题的分析"><a href="#困难问题的分析" class="headerlink" title="困难问题的分析"></a>困难问题的分析</h2><p><img src="https://blogimages.happyshark.cn/%E5%AE%89%E5%85%A8%E8%A7%84%E7%BA%A6%E7%AC%AC%E4%B8%89%E8%AE%B2/YFifNSVecWTEMZv.jpg" alt=""></p><blockquote><p>虽然现在没办法证明np不等于p，但是所有的密码方案都是基于这个式子的，故使用believed-to-be<br>但是在一些情况下可以证明其困难性：比如给定另外一些条件&amp;更强的假设</p></blockquote><p><img src="https://blogimages.happyshark.cn/%E5%AE%89%E5%85%A8%E8%A7%84%E7%BA%A6%E7%AC%AC%E4%B8%89%E8%AE%B2/nLmZS8Xz5dw2PTI.jpg" alt=""></p><ul><li>通过规约的形式：基于一个困难问题上提出一个方案</li><li>通过一个更弱的安全模型：比如限制，或者弱化敌手的能力</li></ul><blockquote><p>标准计算模型即图灵机</p></blockquote><p>一种证明困难问题的技巧<br><img src="https://blogimages.happyshark.cn/%E5%AE%89%E5%85%A8%E8%A7%84%E7%BA%A6%E7%AC%AC%E4%B8%89%E8%AE%B2/rvfDl2KFex5QbkZ.jpg" alt=""></p><h1 id="安全参数"><a href="#安全参数" class="headerlink" title="安全参数"></a>安全参数</h1><h2 id="parameter"><a href="#parameter" class="headerlink" title="parameter"></a>parameter</h2><p><img src="https://blogimages.happyshark.cn/%E5%AE%89%E5%85%A8%E8%A7%84%E7%BA%A6%E7%AC%AC%E4%B8%89%E8%AE%B2/2tQiawfep83nVXL.jpg" alt=""></p><h2 id="level"><a href="#level" class="headerlink" title="level"></a>level</h2><p><img src="https://blogimages.happyshark.cn/%E5%AE%89%E5%85%A8%E8%A7%84%E7%BA%A6%E7%AC%AC%E4%B8%89%E8%AE%B2/GdC5hKuIkzP3F61.jpg" alt=""><br>security level取决于具体的方案or问题的定义。</p><ul><li>我们定义一个方案或者问题具有k bit安全，当敌手在进行2^k次计算后成功的概率为2/3时<blockquote><p>卧报 34期会有更加具体的描述</p></blockquote></li></ul><p><img src="https://blogimages.happyshark.cn/%E5%AE%89%E5%85%A8%E8%A7%84%E7%BA%A6%E7%AC%AC%E4%B8%89%E8%AE%B2/ioearghU7wSuDzZ.jpg" alt=""></p><ul><li>通过计算得出的k bit安全等级是在当前情况下的安全等级若有更强的攻击方案出现则安全等级随之下降</li></ul><p>安全等级的上限：<br><img src="https://blogimages.happyshark.cn/%E5%AE%89%E5%85%A8%E8%A7%84%E7%BA%A6%E7%AC%AC%E4%B8%89%E8%AE%B2/GOzKyHoLgd7x4Xe.jpg" alt=""></p><ul><li>如果解决一个问题b能让我我门马上攻破一个方案则该困难问题b是安全等级的上限</li></ul><p><img src="https://i.loli.net/2021/10/18/tO6zbKqogidCfXU.jpg" alt=""></p><ul><li>如果攻破一个方案可以立马解决一个困难问题a，则方案的等级高于问题a的等级，即a是方案的下限</li></ul><p>如下图所示，a是有条件的</p><p><img src="https://blogimages.happyshark.cn/%E5%AE%89%E5%85%A8%E8%A7%84%E7%BA%A6%E7%AC%AC%E4%B8%89%E8%AE%B2/R4TCuQKVo8sfHLS.jpg" alt=""></p><ul><li>目前比较容易知道第三条和第四条，第二条无法做到</li></ul><blockquote><p>目前我们只讨论下限，因为一个方案的安全必须针对所有的敌手都安全，则方案的安全性必须高于最强的那一部分敌手的能力</p></blockquote><h1 id="安全的定义"><a href="#安全的定义" class="headerlink" title="安全的定义"></a>安全的定义</h1><p><img src="https://blogimages.happyshark.cn/%E5%AE%89%E5%85%A8%E8%A7%84%E7%BA%A6%E7%AC%AC%E4%B8%89%E8%AE%B2/jyHJRqfe6clmkZQ.jpg" alt=""></p><ul><li>关于security model：作为安全和方案之间的桥梁，将各种对方案的攻击转化为计算型问题，在用复杂性理论对其进行分析。</li></ul><p><img src="https://blogimages.happyshark.cn/%E5%AE%89%E5%85%A8%E8%A7%84%E7%BA%A6%E7%AC%AC%E4%B8%89%E8%AE%B2/oErsAwPpgyQHY2d.jpg" alt=""></p><ul><li>安全定义没有用到安全等级的概念</li><li>security definition只和security parameter相关，和security level无关</li></ul><p><img src="https://blogimages.happyshark.cn/%E5%AE%89%E5%85%A8%E8%A7%84%E7%BA%A6%E7%AC%AC%E4%B8%89%E8%AE%B2/cIpKoAfS4XwWYCe.jpg" alt=""></p><ul><li>security parameter与密码相关，和computing problem无关</li></ul>]]></content>
      
      
      <categories>
          
          <category> 密码学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 安全规约 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>安全规约第二讲——有限域，群，双线性对，哈希函数</title>
      <link href="/2022/03/02/%E5%AE%89%E5%85%A8%E8%A7%84%E7%BA%A6%E7%AC%AC%E4%BA%8C%E8%AE%B2%E2%80%94%E2%80%94%E6%9C%89%E9%99%90%E5%9F%9F%EF%BC%8C%E7%BE%A4%EF%BC%8C%E5%8F%8C%E7%BA%BF%E6%80%A7%E5%AF%B9%EF%BC%8C%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0/"/>
      <url>/2022/03/02/%E5%AE%89%E5%85%A8%E8%A7%84%E7%BA%A6%E7%AC%AC%E4%BA%8C%E8%AE%B2%E2%80%94%E2%80%94%E6%9C%89%E9%99%90%E5%9F%9F%EF%BC%8C%E7%BE%A4%EF%BC%8C%E5%8F%8C%E7%BA%BF%E6%80%A7%E5%AF%B9%EF%BC%8C%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="有限域"><a href="#有限域" class="headerlink" title="有限域"></a>有限域</h1><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p><img src="https://blogimages.happyshark.cn/%E5%AE%89%E5%85%A8%E8%A7%84%E7%BA%A6%E7%AC%AC%E5%9B%9B%E8%AE%B2/WEBRESOURCEc2762979e78af3f0ba59dc88224bc149.png" alt=""></p><h2 id="有限域的运算"><a href="#有限域的运算" class="headerlink" title="有限域的运算"></a>有限域的运算</h2><p><img src="https://blogimages.happyshark.cn/%E5%AE%89%E5%85%A8%E8%A7%84%E7%BA%A6%E7%AC%AC%E5%9B%9B%E8%AE%B2/WEBRESOURCEa9570ced8bd358cd98889c19bc85a403.png" alt=""></p><p>通过乘 加 来实现 </p><ul><li><p>除：u * v的逆元</p></li><li><p>减：u + v的逆元</p></li></ul><h2 id="举个例子"><a href="#举个例子" class="headerlink" title="举个例子"></a>举个例子</h2><p><img src="https://blogimages.happyshark.cn/%E5%AE%89%E5%85%A8%E8%A7%84%E7%BA%A6%E7%AC%AC%E5%9B%9B%E8%AE%B2/WEBRESOURCE5c588860c99c22b5b9e579a3487d7f08.png" alt=""></p><ul><li><p>n为整数</p></li><li><p>q为素数</p></li><li><p>有限域中包含了q^n个元素。</p></li><li><p>有限域内每个元的长度都为n * |q|</p></li></ul><h3 id="素数域"><a href="#素数域" class="headerlink" title="素数域"></a>素数域</h3><p><img src="https://blogimages.happyshark.cn/%E5%AE%89%E5%85%A8%E8%A7%84%E7%BA%A6%E7%AC%AC%E5%9B%9B%E8%AE%B2/WEBRESOURCE1d07ffa8a8949c651ec144c2e61812c8.png" alt=""></p><h1 id="群"><a href="#群" class="headerlink" title="群"></a>群</h1><h2 id="阿贝尔群"><a href="#阿贝尔群" class="headerlink" title="阿贝尔群"></a>阿贝尔群</h2><p>定义：</p><p><img src="https://blogimages.happyshark.cn/%E5%AE%89%E5%85%A8%E8%A7%84%E7%BA%A6%E7%AC%AC%E5%9B%9B%E8%AE%B2/WEBRESOURCE817e4cedef7fefbe7e3c524a625eaa9a.png" alt=""></p><ul><li>用点号（而不用加或者乘），可以是有限域中的加号，乘号.etc</li></ul><p>Ex：</p><p><img src="https://blogimages.happyshark.cn/%E5%AE%89%E5%85%A8%E8%A7%84%E7%BA%A6%E7%AC%AC%E5%9B%9B%E8%AE%B2/WEBRESOURCE87c5bd91f34fd81f6b10a0c53d091d6a.png" alt=""></p><ul><li>可以通过H生成整个群的元素，所有的元素都可以通过h^i i=1,2,…得到</li></ul><h2 id="如何描述一个循环群？"><a href="#如何描述一个循环群？" class="headerlink" title="如何描述一个循环群？"></a>如何描述一个循环群？</h2><p><img src="https://blogimages.happyshark.cn/%E5%AE%89%E5%85%A8%E8%A7%84%E7%BA%A6%E7%AC%AC%E5%9B%9B%E8%AE%B2/WEBRESOURCEe0982072f639b0e98aff32db1bcdb48c.png" alt=""></p><ul><li><p>G：群的空间</p></li><li><p>g：生成元</p></li><li><p>p：阶数</p></li></ul><h2 id="群元素"><a href="#群元素" class="headerlink" title="群元素"></a>群元素</h2><p><img src="https://blogimages.happyshark.cn/%E5%AE%89%E5%85%A8%E8%A7%84%E7%BA%A6%E7%AC%AC%E5%9B%9B%E8%AE%B2/WEBRESOURCE2d23ebce74dace208a3cb2165bb52509.png" alt=""></p><ul><li>每个群元最少需要160bit</li></ul><blockquote><p>30期中有对安全等级做进一步解释</p></blockquote><h2 id="群中的简单问题和困难问题"><a href="#群中的简单问题和困难问题" class="headerlink" title="群中的简单问题和困难问题"></a>群中的简单问题和困难问题</h2><p><img src="https://blogimages.happyshark.cn/%E5%AE%89%E5%85%A8%E8%A7%84%E7%BA%A6%E7%AC%AC%E5%9B%9B%E8%AE%B2/WEBRESOURCE455fdcc706b2a7e5a3e74e4d2ec499ce.png" alt=""></p><ul><li><p>有些计算必须要足够简单</p></li><li><p>有些计算必须要足够困难，例如公私钥（一个基本的困难问题是离散对数问题，并且只有某些构造的比较好的群才有离散对数这样的性质）</p></li></ul><h2 id="easy-：group-exponentiation（群指数）"><a href="#easy-：group-exponentiation（群指数）" class="headerlink" title="easy ：group exponentiation（群指数）"></a>easy ：group exponentiation（群指数）</h2><p><img src="https://blogimages.happyshark.cn/%E5%AE%89%E5%85%A8%E8%A7%84%E7%BA%A6%E7%AC%AC%E5%9B%9B%E8%AE%B2/WEBRESOURCE7cb2b21769b2254f07416da610a28db1.png" alt=""></p><p>如上，定义一个运算，当x特别大的时候计算会比较困难，故采取先平方在乘的算法（square-and-multiply algorithm）</p><p><img src="https://blogimages.happyshark.cn/%E5%AE%89%E5%85%A8%E8%A7%84%E7%BA%A6%E7%AC%AC%E5%9B%9B%E8%AE%B2/WEBRESOURCEf3416a938e2b04e523400e2f39f9d3d0.png" alt=""></p><p>采用上述方法，最大只需要2^2n次运算即可</p><h2 id="hard：Discrete-Logarithm（离散对数）"><a href="#hard：Discrete-Logarithm（离散对数）" class="headerlink" title="hard：Discrete Logarithm（离散对数）"></a>hard：Discrete Logarithm（离散对数）</h2><p><img src="https://blogimages.happyshark.cn/%E5%AE%89%E5%85%A8%E8%A7%84%E7%BA%A6%E7%AC%AC%E5%9B%9B%E8%AE%B2/WEBRESOURCE2a9b46ae93dcc2def66fbcde88d8c088.png" alt=""></p><ul><li><p>如果G是一个具有素数阶的循环群，那么任意给定两个群元g h ，那么这个离散对数x必然存在，而且是唯一的，这就是为啥一般都比较喜欢具有素数阶的循环群。</p></li><li><p>如果可以很简单的解决离散对数问题，那么所有基于群对数的加密方案都会不安全。</p></li></ul><p>以下介绍离散对数问题的计算复杂性：</p><p><img src="https://blogimages.happyshark.cn/%E5%AE%89%E5%85%A8%E8%A7%84%E7%BA%A6%E7%AC%AC%E5%9B%9B%E8%AE%B2/WEBRESOURCEb7a23a84cda385f253f2cc4801f041a6.png" alt=""></p><blockquote><p>Ω代表下界，指至少需要根号p</p><p>O代表上界</p></blockquote><p><img src="https://blogimages.happyshark.cn/%E5%AE%89%E5%85%A8%E8%A7%84%E7%BA%A6%E7%AC%AC%E5%9B%9B%E8%AE%B2/WEBRESOURCE12f2f61a0952c7c414a65433ca631157.png" alt=""></p><ul><li>群的阶必须要大于160来抵抗特殊的攻击，如果小于则敌手最多只需2^80步即可攻破</li></ul><h2 id="群的选择"><a href="#群的选择" class="headerlink" title="群的选择"></a>群的选择</h2><p><img src="https://blogimages.happyshark.cn/%E5%AE%89%E5%85%A8%E8%A7%84%E7%BA%A6%E7%AC%AC%E5%9B%9B%E8%AE%B2/WEBRESOURCE18b8ccbc002c66b64f29671ad336841e.png" alt=""></p><p>为什么要定义其他的一些更加复杂&amp;高级的群而不直接使用有限域中已有的两个群？</p><ul><li>有很多原因，比如椭圆曲线群，群元素可以用长度表示从而让其长度更短。</li></ul><h3 id="乘法群"><a href="#乘法群" class="headerlink" title="乘法群"></a>乘法群</h3><p><img src="https://blogimages.happyshark.cn/%E5%AE%89%E5%85%A8%E8%A7%84%E7%BA%A6%E7%AC%AC%E5%9B%9B%E8%AE%B2/WEBRESOURCEea4173b35c4333c74f36d7964c77392a.png" alt=""></p><ul><li><p>q指大素数，p是比q小的一个素数</p></li><li><p>p只需要大于160bit，但q要大于1024bit（与RSA相似），因为目前存在一种特殊的攻击可以攻破该方案，使用这种攻击的前提就是q足够小</p></li></ul><h3 id="椭圆曲线群"><a href="#椭圆曲线群" class="headerlink" title="椭圆曲线群"></a>椭圆曲线群</h3><p><img src="https://blogimages.happyshark.cn/%E5%AE%89%E5%85%A8%E8%A7%84%E7%BA%A6%E7%AC%AC%E5%9B%9B%E8%AE%B2/WEBRESOURCEc412e886a311fd901e41e9b33945821e.png" alt=""></p><ul><li><p>主需要给出横坐标，从而减小其长度表示（y通过计算得出，故增加了计算量）</p></li><li><p>u·v：包含了有限域中的加法和乘法运算</p></li></ul><h2 id="基于椭圆曲线群的计算"><a href="#基于椭圆曲线群的计算" class="headerlink" title="基于椭圆曲线群的计算"></a>基于椭圆曲线群的计算</h2><p><img src="https://blogimages.happyshark.cn/%E5%AE%89%E5%85%A8%E8%A7%84%E7%BA%A6%E7%AC%AC%E5%9B%9B%E8%AE%B2/WEBRESOURCE838787879dbd05fad0c86bfc1c145971.png" alt=""></p><ul><li>基于以上算法，可以构造出更加复杂的方案，比如上图中的Question</li></ul><h1 id="双线性对"><a href="#双线性对" class="headerlink" title="双线性对"></a>双线性对</h1><p>特点：将椭圆曲线上群的两个群元映射到一个乘法群上的群元，同时这种运算可以保持同态性。</p><blockquote><p>同态性：最早由两位日本学者提出，他们想解决椭圆曲线上困难问题，故提出将定义在椭圆曲线上的问题映射到惩罚群上去，在乘法群内解决在反映射回来。</p></blockquote><p>双线性对有3种：</p><p><img src="https://blogimages.happyshark.cn/%E5%AE%89%E5%85%A8%E8%A7%84%E7%BA%A6%E7%AC%AC%E5%9B%9B%E8%AE%B2/WEBRESOURCE320489e16ca7da93f81cfb60ed1d457c.png" alt=""></p><h2 id="Symmetric-Pairing"><a href="#Symmetric-Pairing" class="headerlink" title="Symmetric Pairing"></a>Symmetric Pairing</h2><h3 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h3><p><img src="https://blogimages.happyshark.cn/%E5%AE%89%E5%85%A8%E8%A7%84%E7%BA%A6%E7%AC%AC%E5%9B%9B%E8%AE%B2/WEBRESOURCEd928e03f27c675af21ec91584048feb4.png" alt=""></p><h3 id="大小"><a href="#大小" class="headerlink" title="大小"></a>大小</h3><p><img src="https://blogimages.happyshark.cn/安全规约第四讲/WEBRESOURCE98090e9af310e1756399b2dff81f4a88.png" alt=""></p><ul><li>实际上，80bit已经不够安全，现在最少需要128bit</li></ul><h2 id="Asymmetric-Pairing-非对称对"><a href="#Asymmetric-Pairing-非对称对" class="headerlink" title="Asymmetric Pairing 非对称对"></a>Asymmetric Pairing 非对称对</h2><h3 id="定义-2"><a href="#定义-2" class="headerlink" title="定义"></a>定义</h3><p><img src="https://blogimages.happyshark.cn/%E5%AE%89%E5%85%A8%E8%A7%84%E7%BA%A6%E7%AC%AC%E5%9B%9B%E8%AE%B2/WEBRESOURCEaa07bdc24b9d5e942606a215ae63aefd.png" alt=""></p><h3 id="大小-1"><a href="#大小-1" class="headerlink" title="大小"></a>大小</h3><p><img src="https://blogimages.happyshark.cn/%E5%AE%89%E5%85%A8%E8%A7%84%E7%BA%A6%E7%AC%AC%E5%9B%9B%E8%AE%B2/WEBRESOURCEe8f2304bd57b897b1ac67f90df027f1e.png" alt=""></p><ul><li>因为目前有三种群 g1 g2 gt，为了确保安全，目前g1最少需要160bit，g2=gt最少需要1024bit，目的为了让g1群越小越好</li></ul><h2 id="pairing上的计算"><a href="#pairing上的计算" class="headerlink" title="pairing上的计算"></a>pairing上的计算</h2><p><img src="https://blogimages.happyshark.cn/%E5%AE%89%E5%85%A8%E8%A7%84%E7%BA%A6%E7%AC%AC%E5%9B%9B%E8%AE%B2/WEBRESOURCE49cc290fd3e68c09f924712503c5de6f.png" alt=""></p><ul><li>在pairing上的计算可以拓展成乘法，指数，。。。，等其他方式的计算，实际上很多方案（比如加密，签名，认证等等）都是基于此扩展出来的，但是需要很高的技巧</li></ul><h1 id="哈希函数-H-·"><a href="#哈希函数-H-·" class="headerlink" title="哈希函数 H(·)"></a>哈希函数 H(·)</h1><p><img src="https://blogimages.happyshark.cn/%E5%AE%89%E5%85%A8%E8%A7%84%E7%BA%A6%E7%AC%AC%E5%9B%9B%E8%AE%B2/WEBRESOURCE8746821140089f64e20d6c1e2259252b.png" alt=""></p><ul><li>其中的一个用途：缩短签名长度：如果有个签名方案是按每bit签名，若有个1g的文件不压缩的话就签到猴年马月了；相反通过hash缩小到一个定长长度在对hash签名就很快</li></ul><h2 id="基于安全性的分类"><a href="#基于安全性的分类" class="headerlink" title="基于安全性的分类"></a>基于安全性的分类</h2><p><img src="https://blogimages.happyshark.cn/%E5%AE%89%E5%85%A8%E8%A7%84%E7%BA%A6%E7%AC%AC%E5%9B%9B%E8%AE%B2/WEBRESOURCEb1d3d5adab5bc1eb264ddfcf643c4b1b.png" alt=""></p><h2 id="基于输出对哈希函数进行分类"><a href="#基于输出对哈希函数进行分类" class="headerlink" title="基于输出对哈希函数进行分类"></a>基于输出对哈希函数进行分类</h2><p><img src="https://blogimages.happyshark.cn/%E5%AE%89%E5%85%A8%E8%A7%84%E7%BA%A6%E7%AC%AC%E5%9B%9B%E8%AE%B2/WEBRESOURCE28088345de4600719e80552d0009a7c6.png" alt=""></p><p>可以分成三类：</p><ul><li><p>n bit 的串：输出结果可以用作key，与对称密码结合用于加解密</p></li><li><p>Zp：</p></li><li><p>输出到群中： </p></li></ul><blockquote><p>为什么不直接用第二种取代第三种：如果使用第二种方法在方案构造中会出现不安全，只有用第三种才能构造出安全的方案。</p></blockquote><h1 id="随机函数"><a href="#随机函数" class="headerlink" title="随机函数"></a>随机函数</h1><p><img src="https://blogimages.happyshark.cn/%E5%AE%89%E5%85%A8%E8%A7%84%E7%BA%A6%E7%AC%AC%E5%9B%9B%E8%AE%B2/WEBRESOURCEed4f8c1cdfa807e7136c505b29932975.png" alt=""></p><blockquote><p>现有的公钥加密也是需要随机数得到，否则无法达到ind安全</p></blockquote><p><img src="https://blogimages.happyshark.cn/%E5%AE%89%E5%85%A8%E8%A7%84%E7%BA%A6%E7%AC%AC%E5%9B%9B%E8%AE%B2/WEBRESOURCEad988e3ff026c88b67fa82bf4b347693.png" alt=""></p><blockquote><p>现有的密码方案是依赖许多假设的 </p></blockquote><h1 id="不安全的方案"><a href="#不安全的方案" class="headerlink" title="不安全的方案"></a>不安全的方案</h1><blockquote><p>错误的方案原因都类似的，下面以签名为例</p></blockquote><h2 id="不安全的数字前面"><a href="#不安全的数字前面" class="headerlink" title="不安全的数字前面"></a>不安全的数字前面</h2><p><img src="https://blogimages.happyshark.cn/%E5%AE%89%E5%85%A8%E8%A7%84%E7%BA%A6%E7%AC%AC%E5%9B%9B%E8%AE%B2/WEBRESOURCEb90c906ce54a3d0ded13831bae59cfda.png" alt=""></p><p><img src="https://blogimages.happyshark.cn/%E5%AE%89%E5%85%A8%E8%A7%84%E7%BA%A6%E7%AC%AC%E5%9B%9B%E8%AE%B2/WEBRESOURCEf36c8845a0682996c6bbd6b06c4287ae.png" alt=""></p><ul><li>基础运算需要大量的去熟悉联系</li></ul><p><img src="https://blogimages.happyshark.cn/%E5%AE%89%E5%85%A8%E8%A7%84%E7%BA%A6%E7%AC%AC%E5%9B%9B%E8%AE%B2/WEBRESOURCEfc17b617a64b4043bd62523f15cb5853.png" alt=""></p><p><img src="https://blogimages.happyshark.cn/%E5%AE%89%E5%85%A8%E8%A7%84%E7%BA%A6%E7%AC%AC%E5%9B%9B%E8%AE%B2/WEBRESOURCE4f9fbb0a9e11b91a643639dcf405081e.png" alt=""></p><p><img src="https://blogimages.happyshark.cn/%E5%AE%89%E5%85%A8%E8%A7%84%E7%BA%A6%E7%AC%AC%E5%9B%9B%E8%AE%B2/WEBRESOURCE7193aa0ed95d59e60bc2f89126e23944.png" alt=""></p><p><img src="https://blogimages.happyshark.cn/%E5%AE%89%E5%85%A8%E8%A7%84%E7%BA%A6%E7%AC%AC%E5%9B%9B%E8%AE%B2/WEBRESOURCE5c5de542ef3f6fb6e2d8825a27c3690e.png" alt=""></p><blockquote><p>第四个和第五个相似</p></blockquote><p><img src="https://blogimages.happyshark.cn/%E5%AE%89%E5%85%A8%E8%A7%84%E7%BA%A6%E7%AC%AC%E5%9B%9B%E8%AE%B2/WEBRESOURCE99afb70e8ef8a911a7b38eb972aac87d.png" alt=""></p><blockquote><p>6与1类似</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 密码学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 安全规约 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>抓饭</title>
      <link href="/2022/02/12/%E6%8A%93%E9%A5%AD/"/>
      <url>/2022/02/12/%E6%8A%93%E9%A5%AD/</url>
      
        <content type="html"><![CDATA[<hr><ol><li><p>羊肉切开洗净，把水晾干，油锅加盐（不崩），中火把肉放进去抄抄，炒出水之后盖上锅盖把水闷干。</p><blockquote><p>过几分钟就开盖翻炒一下。 </p></blockquote><p><img src="https://blogimages.happyshark.cn/food/image-20220212132430021.png" alt="image-20220212132430021"></p></li><li><p>闷干之后出锅备用，油留锅里别倒掉<br><img src="https://blogimages.happyshark.cn/food/image-20220212132517077.png" alt="image-20220212132517077"></p></li><li><p>胡萝卜（3个）削皮切条，把米洗净备用<br><img src="https://blogimages.happyshark.cn/food/image-20220212132540721.png" alt="image-20220212132540721"></p></li><li><p>胡萝卜倒进锅里中火炒炒（油少了可以加些油），加些盐<br><img src="https://blogimages.happyshark.cn/food/image-20220212132605423.png" alt="image-20220212132605423"></p></li><li><p>抄完倒进高压锅，再往锅里加些水，米撒到胡萝卜上面，肉放到米上面。盖上锅盖大火烧到高压锅喷气，火改小一些（改到泄压阀不那么暴力为止）压10~15分钟米熟为止<br><img src="https://blogimages.happyshark.cn/food/image-20220212132627827.png" alt="image-20220212132627827"><br><img src="https://blogimages.happyshark.cn/food/image-20220212132651559.png" alt="image-20220212132651559"></p></li><li><p>关火高压锅放一边泄气，气没了就可以开锅享受美食啦</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> 厨房里的秘密 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 家的味道 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>蒸面条</title>
      <link href="/2022/02/11/%E8%92%B8%E9%9D%A2%E6%9D%A1/"/>
      <url>/2022/02/11/%E8%92%B8%E9%9D%A2%E6%9D%A1/</url>
      
        <content type="html"><![CDATA[<hr><ol><li>蒸锅加水，放手工面大火蒸到水开，改中火蒸十~十五分钟<br><img src="https://blogimages.happyshark.cn/food/image-20220212131748569.png" alt="image-20220212131748569"></li><li>猪肉切片，蒜薹洗干净切成一段一段的，姜切成片，切一节葱备用，也可选干辣椒调色<br><img src="https://blogimages.happyshark.cn/food/image-20220212131830715.png" alt="image-20220212131830715"></li><li>锅里放油，加猪肉炒变色放生抽调色，放姜，葱，干辣椒，蒜薹炒半熟，加咸盐，出锅备用<br><img src="https://blogimages.happyshark.cn/food/image-20220212131900050.png" alt="image-20220212131900050"></li><li>面蒸好之后出锅加些油（如果面太干加些水）拌开，蒸锅再加水大火煮水<br><img src="https://blogimages.happyshark.cn/food/image-20220212131921751.png" alt="image-20220212131921751"></li><li>加生抽调颜色，酱油，咸盐调味，可选十三香花椒粉鸡精。继续拌开<br><img src="https://blogimages.happyshark.cn/food/image-20220212131948425.png" alt="image-20220212131948425"></li><li>把前面炒的菜倒进去继续拌开，尝下味道淡了加生抽调味，干的话再加点油。一定要拌开不能缠一块<br><img src="https://blogimages.happyshark.cn/food/image-20220212132003990.png" alt="image-20220212132003990"></li><li>蒸锅水开了之后关火，先放面再放菜（避免菜从篦子洞掉下去），盖上锅盖大火烧一会锅里充满蒸汽之后改小火慢慢焖蒸10~15分钟入味。<br><img src="https://blogimages.happyshark.cn/food/image-20220212132030268.png" alt="image-20220212132030268"></li><li>关火出锅，拌辣椒酱，香菇酱。味道好极啦<br><img src="https://blogimages.happyshark.cn/food/image-20220212132108982.png" alt="image-20220212132108982"></li></ol>]]></content>
      
      
      <categories>
          
          <category> 厨房里的秘密 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 家的味道 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>炒扇贝肉</title>
      <link href="/2022/02/10/%E7%82%92%E6%89%87%E8%B4%9D%E8%82%89/"/>
      <url>/2022/02/10/%E7%82%92%E6%89%87%E8%B4%9D%E8%82%89/</url>
      
        <content type="html"><![CDATA[<hr><ol><li><p>把贝壳肉清理出来，去掉内胆杂质</p><p><img src="https://blogimages.happyshark.cn/food/image-20220210151231250.png" alt="image-20220210151231250"></p></li><li><p>锅里加油，放姜和辣椒抄一抄出锅备用</p><p><img src="https://blogimages.happyshark.cn/food/image-20220210151256350.png" alt="image-20220210151256350"></p></li><li><p>加油放葱姜香锅，放扇贝肉炒熟，改中火加酱油调色，耗油调味，料酒去腥</p><p><img src="https://blogimages.happyshark.cn/food/image-20220210151314665.png" alt="image-20220210151314665"></p></li><li><p>把辣椒加进去拌开，尝尝咸淡，淡的话可以加点盐。小火收汁出锅</p><p><img src="https://blogimages.happyshark.cn/food/image-20220210151339498.png" alt="image-20220210151339498"></p></li></ol>]]></content>
      
      
      <categories>
          
          <category> 厨房里的秘密 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 家的味道 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>炒烤肉</title>
      <link href="/2022/02/10/%E7%82%92%E7%83%A4%E8%82%89/"/>
      <url>/2022/02/10/%E7%82%92%E7%83%A4%E8%82%89/</url>
      
        <content type="html"><![CDATA[<hr><ol><li><p>羊肉拿出来化成半冻状态，切片</p><p><img src="https://blogimages.happyshark.cn/food/image-20220210151607906.png" alt="image-20220210151607906"></p></li><li><p>可选步骤：如果想吃软一点的烤肉可在肉里面加些勾芡淀粉，抓一抓拌匀</p><blockquote><p>就和揉面一样把肉放到盆里，然后加点淀粉开始揉，揉开就ok</p></blockquote></li><li><p>锅里放油防粘锅（看一下肥肉多不多，多的话油可以少放点），放肉小火炒</p><p><img src="https://blogimages.happyshark.cn/food/image-20220210151726064.png" alt="image-20220210151726064"></p></li><li><p>炒到变色，放点盐，辣椒面</p><p><img src="https://blogimages.happyshark.cn/food/image-20220210151756289.png" alt="image-20220210151756289"></p></li><li><p>炒熟，在放孜然，关火拌开出锅</p><p><img src="https://blogimages.happyshark.cn/food/image-20220210151817390.png" alt="image-20220210151817390"></p></li></ol>]]></content>
      
      
      <categories>
          
          <category> 厨房里的秘密 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 家的味道 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>红烧多宝鱼</title>
      <link href="/2022/02/10/%E7%BA%A2%E7%83%A7%E5%A4%9A%E5%AE%9D%E9%B1%BC/"/>
      <url>/2022/02/10/%E7%BA%A2%E7%83%A7%E5%A4%9A%E5%AE%9D%E9%B1%BC/</url>
      
        <content type="html"><![CDATA[<hr><ol><li><p>剪掉尾巴和鱼鳍，把鱼鳃和内胆掏干净（边上有个小孔从那开始沿着黑色部分剪开，里面掏干净不要弄破内胆）</p><p><img src="https://blogimages.happyshark.cn/food/image-20220210150909686.png" alt="image-20220210150909686"></p></li><li><p>锅里倒油，放葱和姜香锅，然后加酱油，耗油，水</p><p><img src="https://blogimages.happyshark.cn/food/image-20220210150936619.png" alt="image-20220210150936619"></p></li><li><p>放入鱼，大火烧开，有沫（血）的话可以撇一下</p><p><img src="https://blogimages.happyshark.cn/food/image-20220210150955994.png" alt="image-20220210150955994"></p></li><li><p>放料酒去腥，在放点葱调色，小伙炖一会大火收汁。出锅之前放点鸡精提味，在撇一下沫</p><p><img src="https://blogimages.happyshark.cn/food/image-20220210151013356.png" alt="image-20220210151013356"></p></li><li><p>水蒸发的差不多了收汁出锅</p><p><img src="https://blogimages.happyshark.cn/food/image-20220210151038891.png" alt="image-20220210151038891"></p></li></ol>]]></content>
      
      
      <categories>
          
          <category> 厨房里的秘密 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 家的味道 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>蒸饭（高压锅速成版）</title>
      <link href="/2022/02/10/%E8%92%B8%E9%A5%AD%EF%BC%88%E9%AB%98%E5%8E%8B%E9%94%85%E9%80%9F%E6%88%90%E7%89%88%EF%BC%89/"/>
      <url>/2022/02/10/%E8%92%B8%E9%A5%AD%EF%BC%88%E9%AB%98%E5%8E%8B%E9%94%85%E9%80%9F%E6%88%90%E7%89%88%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<hr><ol><li><p>高压锅里面放水，米饭洗净装到碗里放进高压锅。当然也可以在下面水里面放个玉米，或者在上面放个红薯利用下空间hhh</p><p><img src="https://blogimages.happyshark.cn//food/image-20220210150208622.png" alt="image-20220210150208622"></p></li><li><p>盖上盖子大火烧到往外喷气开始，火稍微关小点（避免压力太高，也不要太小了就不喷气了）继续倒计时10分钟</p><p><img src="https://blogimages.happyshark.cn//food/image-20220210150353001.png" alt="image-20220210150353001"></p></li><li><p>关火，等压力阀下去再焖十来分钟出锅就行~要是时间不够连锅放到冷水里面冷却一下</p><p><img src="https://blogimages.happyshark.cn//food/20220210150427.png" alt=""></p></li></ol>]]></content>
      
      
      <categories>
          
          <category> 厨房里的秘密 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 家的味道 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>清蒸贝壳</title>
      <link href="/2022/02/09/%E6%B8%85%E8%92%B8%E8%B4%9D%E5%A3%B3/"/>
      <url>/2022/02/09/%E6%B8%85%E8%92%B8%E8%B4%9D%E5%A3%B3/</url>
      
        <content type="html"><![CDATA[<hr><ol><li><p>清洗一下贝壳肉</p><p><img src="https://blogimages.happyshark.cn//food/image-20220209225923639.png" alt=""></p></li><li><p>清水煮一碗粉丝</p><p><img src="https://blogimages.happyshark.cn//food/image-20220209230241958.png" alt="image-20220209230241958"></p></li><li><p>调汁：葱姜耗油水料酒生抽</p><p><img src="https://blogimages.happyshark.cn//food/image-20220209230307708.png" alt="image-20220209230307708"></p></li><li><p>每个贝壳上面放点粉丝，再加汁，上蒸锅，加水大火蒸六到十分钟</p><p><img src="https://blogimages.happyshark.cn//food/image-20220209230341168.png" alt="image-20220209230341168"></p></li><li><p>关火出锅</p><p><img src="https://blogimages.happyshark.cn//food/image-20220209230404457.png" alt="image-20220209230404457"></p></li></ol>]]></content>
      
      
      <categories>
          
          <category> 厨房里的秘密 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 家的味道 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>糖醋排骨</title>
      <link href="/2022/02/09/%E7%B3%96%E9%86%8B%E6%8E%92%E9%AA%A8/"/>
      <url>/2022/02/09/%E7%B3%96%E9%86%8B%E6%8E%92%E9%AA%A8/</url>
      
        <content type="html"><![CDATA[<hr><ol><li><p>白糖淀粉西红柿酱加水配汁</p><p><img src="https://blogimages.happyshark.cn//food/image-20220210120640514.png" alt="image-20220210120640514"></p></li><li><p>锅里加汁，放红烧排骨（去调料）炒熟</p><p><img src="https://blogimages.happyshark.cn//food/image-20220210120723628.png" alt="image-20220210120723628"></p><p><img src="https://blogimages.happyshark.cn//food/image-20220210120741093.png" alt="image-20220210120741093"></p></li></ol>]]></content>
      
      
      <categories>
          
          <category> 厨房里的秘密 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 家的味道 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>紫菜蛋花汤</title>
      <link href="/2022/02/09/%E7%B4%AB%E8%8F%9C%E8%9B%8B%E8%8A%B1%E6%B1%A4/"/>
      <url>/2022/02/09/%E7%B4%AB%E8%8F%9C%E8%9B%8B%E8%8A%B1%E6%B1%A4/</url>
      
        <content type="html"><![CDATA[<hr><ol><li><p>锅里加水，可选放一些虾皮一起煮等，水开</p></li><li><p>水开了之后改中火，放番茄丁（番茄也可以） 紫菜，盐，可选胡椒粉（调辣） ，淀粉（调粘稠度），耗油（调鲜调味）<br><img src="https://blogimages.happyshark.cn/food/image-20220212133040186.png" alt="image-20220212133040186"></p></li><li><p>打蛋花，对着冒泡的地方慢慢往里滴<br><img src="https://blogimages.happyshark.cn/food/image-20220212133107802.png" alt="image-20220212133107802"></p></li><li><p>放菠菜（菠菜第二步放也可以，量大的话推荐最后一步放菠菜，因为菠菜煮时间长容易老），浮起来放香油，可选鸡精和味精，煮一会就可以出锅啦<br><img src="https://blogimages.happyshark.cn/food/image-20220212133136839.png" alt="image-20220212133136839"></p></li></ol>]]></content>
      
      
      <categories>
          
          <category> 厨房里的秘密 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 家的味道 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>红烧鱼</title>
      <link href="/2022/02/09/%E7%BA%A2%E7%83%A7%E9%B1%BC/"/>
      <url>/2022/02/09/%E7%BA%A2%E7%83%A7%E9%B1%BC/</url>
      
        <content type="html"><![CDATA[<hr><ol><li><p>把鱼鳃 内胆 鱼鳞处理好，抹盐淹一会</p><p><img src="https://blogimages.happyshark.cn//food/image-20220210120226539.png" alt="image-20220210120226539"></p></li><li><p>锅里倒油至冒烟放鱼煎一下（油热不粘锅）</p><p><img src="https://blogimages.happyshark.cn//food/image-20220210120402098.png" alt="image-20220210120402098"></p></li><li><p>放酱油，料酒，耗油，葱，蒜，可选辣椒，然后改小火，盖上锅盖炖到水干（大概七八分钟）</p><p><img src="https://blogimages.happyshark.cn//food/image-20220210120419613.png" alt="image-20220210120419613"></p></li><li><p>4分钟左右可以开锅尝一下咸淡，加盐，放点白糖提鲜继续炖，熟了之后改大火收汁</p><p><img src="https://blogimages.happyshark.cn//food/image-20220210120439074.png" alt="image-20220210120439074"></p></li><li><p>最后再加点葱提色，鸡精提鲜，出锅</p><p><img src="https://blogimages.happyshark.cn//food/image-20220210120458363.png" alt="image-20220210120458363"></p></li></ol>]]></content>
      
      
      <categories>
          
          <category> 厨房里的秘密 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 家的味道 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>红烧虾</title>
      <link href="/2022/02/09/%E7%BA%A2%E7%83%A7%E8%99%BE/"/>
      <url>/2022/02/09/%E7%BA%A2%E7%83%A7%E8%99%BE/</url>
      
        <content type="html"><![CDATA[<hr><ol><li><p>调汁儿：小葱 料酒 姜 鸡精 耗油 生抽 酱油</p><p><img src="https://blogimages.happyshark.cn//food/image-20220210121235203.png" alt="image-20220210121235203"></p></li><li><p>锅放油，倒虾，炒制变色，放汁</p><p>-<img src="https://blogimages.happyshark.cn//food/image-20220210121258320.png" alt="image-20220210121258320"></p></li><li><p>放水大火收汁，不用盖锅盖，最后放鸡精调味出锅</p><p><img src="https://blogimages.happyshark.cn//food/image-20220210121406157.png" alt="image-20220210121406157"></p></li></ol>]]></content>
      
      
      <categories>
          
          <category> 厨房里的秘密 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 家的味道 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux命令手册</title>
      <link href="/2021/10/21/Linux%E5%91%BD%E4%BB%A4%E6%89%8B%E5%86%8C/"/>
      <url>/2021/10/21/Linux%E5%91%BD%E4%BB%A4%E6%89%8B%E5%86%8C/</url>
      
        <content type="html"><![CDATA[<h1 id="关机-重启-注销"><a href="#关机-重启-注销" class="headerlink" title="关机/重启/注销"></a>关机/重启/注销</h1><div class="table-container"><table><thead><tr><th>常用命令</th><th>作用</th></tr></thead><tbody><tr><td>shutdown -h now</td><td>即刻关机</td></tr><tr><td>shutdown -h 10</td><td>10分钟后关机</td></tr><tr><td>shutdown -h 11:00</td><td>11：00关机</td></tr><tr><td>shutdown -h +10</td><td>预定时间关机（10分钟后）</td></tr><tr><td>shutdown -c</td><td>取消指定时间关机</td></tr><tr><td>shutdown -r now</td><td>重启</td></tr><tr><td>shutdown -r 10</td><td>10分钟之后重启</td></tr><tr><td>shutdown -r 11:00</td><td>定时重启</td></tr><tr><td>reboot</td><td>重启</td></tr><tr><td>init 6</td><td>重启</td></tr><tr><td>init 0</td><td>⽴刻关机</td></tr><tr><td>telinit 0</td><td>关机</td></tr><tr><td>poweroff</td><td>⽴刻关机</td></tr><tr><td>halt</td><td>关机</td></tr><tr><td>sync</td><td>buff数据同步到磁盘</td></tr><tr><td>logout</td><td>退出登录Shell</td></tr></tbody></table></div><h1 id="系统信息和性能查看"><a href="#系统信息和性能查看" class="headerlink" title="系统信息和性能查看"></a>系统信息和性能查看</h1><div class="table-container"><table><thead><tr><th>常用命令</th><th>作用</th></tr></thead><tbody><tr><td>uname -a</td><td>查看内核/OS/CPU信息</td></tr><tr><td>uname -r</td><td>查看内核版本</td></tr><tr><td>uname -m</td><td>查看处理器架构</td></tr><tr><td>arch</td><td>查看处理器架构</td></tr><tr><td>hostname</td><td>查看计算机名</td></tr><tr><td>who</td><td>显示当前登录系统的⽤户</td></tr><tr><td>who am i</td><td>显示登录时的⽤户名</td></tr><tr><td>whoami</td><td>显示当前⽤户名</td></tr><tr><td>cat /proc/version</td><td>查看linux版本信息</td></tr><tr><td>cat /proc/cpuinfo</td><td>查看CPU信息</td></tr><tr><td>cat /proc/interrupts</td><td>查看中断</td></tr><tr><td>cat /proc/loadavg</td><td>查看系统负载</td></tr><tr><td>uptime</td><td>查看系统运⾏时间、⽤户数、负载</td></tr><tr><td>env</td><td>查看系统的环境变量</td></tr><tr><td>lsusb -tv</td><td>查看系统USB设备信息</td></tr><tr><td>lspci -tv</td><td>查看系统PCI设备信息</td></tr><tr><td>lsmod</td><td>查看已加载的系统模块</td></tr><tr><td>grep MemTotal /proc/meminfo</td><td>查看内存总量</td></tr><tr><td>grep MemFree /proc/meminfo</td><td>查看空闲内存量</td></tr><tr><td>free -m</td><td>查看内存⽤量和交换区⽤量</td></tr><tr><td>date</td><td>显示系统⽇期时间</td></tr><tr><td>cal 2021</td><td>显示2021⽇历表</td></tr><tr><td>top</td><td>动态显示cpu/内存/进程等情况</td></tr><tr><td>vmstat 1 20</td><td>每1秒采⼀次系统状态，采20次</td></tr><tr><td>iostat</td><td>查看io读写/cpu使⽤情况</td></tr><tr><td>查看io读写/cpu使⽤情况</td><td>查询cpu使⽤情况（1秒⼀次，共10次）</td></tr><tr><td>sar -d 1 10</td><td>查询磁盘性能</td></tr></tbody></table></div><h1 id="磁盘和分区"><a href="#磁盘和分区" class="headerlink" title="磁盘和分区"></a>磁盘和分区</h1><div class="table-container"><table><thead><tr><th>常用命令</th><th>作用</th></tr></thead><tbody><tr><td>fdisk -l</td><td>查看所有磁盘分区</td></tr><tr><td>swapon -s</td><td>查看所有交换分区</td></tr><tr><td>df -h</td><td>查看磁盘使⽤情况及挂载点</td></tr><tr><td>df -hl</td><td>同上</td></tr><tr><td>du -sh /dir</td><td>查看指定某个⽬录的⼤⼩</td></tr><tr><td>du -sk * \</td><td>sort -rn</td><td>从⾼到低依次显示⽂件和⽬录⼤⼩</td></tr><tr><td>mount /dev/hda2 /mnt/hda2</td><td>挂载hda2盘</td></tr><tr><td>mount -t ntfs /dev/sdc1 /mnt/usbhd1</td><td>指定⽂件系统类型挂载（如ntfs）</td></tr><tr><td>mount -o loop xxx.iso /mnt/cdrom</td><td>挂 载 iso ⽂ 件</td></tr><tr><td>umount -v /dev/sda1</td><td>通过设备名卸载</td></tr><tr><td>umount -v /mnt/mymnt</td><td>通过挂载点卸载</td></tr><tr><td>fuser -km /mnt/hda1</td><td>强制卸载(慎⽤)</td></tr></tbody></table></div><h1 id="⽤户和⽤户组"><a href="#⽤户和⽤户组" class="headerlink" title="⽤户和⽤户组"></a>⽤户和⽤户组</h1><div class="table-container"><table><thead><tr><th>常用命令</th><th>作用</th></tr></thead><tbody><tr><td>useradd codesheep</td><td>创建⽤户</td></tr><tr><td>userdel -r codesheep</td><td>删除⽤户</td></tr><tr><td>usermod -g group_name user_name</td><td>修改⽤户的组</td></tr><tr><td>usermod -aG group_name user_name</td><td>将⽤户添加到组</td></tr><tr><td>usermod -s /bin/ksh -d /home/codepig –g dev codesheep</td><td>修改⽤户codesheep的登录Shell、主⽬录以及⽤户组</td></tr><tr><td>groups test</td><td>查看test⽤户所在的组</td></tr><tr><td>groupadd group_name</td><td>创建⽤户组</td></tr><tr><td>groupdel group_name</td><td>删除⽤户组</td></tr><tr><td>groupmod -n new_name old_name</td><td>重命名⽤户组</td></tr><tr><td>su - user_name</td><td>su - user_name</td></tr><tr><td>passwd</td><td>修改⼝令</td></tr><tr><td>passwd codesheep</td><td>修改某⽤户的⼝令</td></tr><tr><td>w</td><td>查看活动⽤户</td></tr><tr><td>id codesheep</td><td>查看指定⽤户codesheep信息</td></tr><tr><td>last</td><td>查看⽤户登录⽇志</td></tr><tr><td>crontab -l</td><td>查看当前⽤户的计划任务</td></tr><tr><td>cut -d: -f1 /etc/passwd</td><td>查看系统所有⽤户</td></tr><tr><td>cut -d: -f1 /etc/group</td><td>查看系统所有组</td></tr></tbody></table></div><h1 id="⽹络和进程管理"><a href="#⽹络和进程管理" class="headerlink" title="⽹络和进程管理"></a>⽹络和进程管理</h1><div class="table-container"><table><thead><tr><th>常用命令</th><th>作用</th></tr></thead><tbody><tr><td>ifconfig</td><td>查看⽹络接⼝属性</td></tr><tr><td>ifconfig eth0</td><td>查看某⽹卡的配置</td></tr><tr><td>route -n</td><td>查看路由表</td></tr><tr><td>netstat -lntp</td><td>查看所有监听端⼝</td></tr><tr><td>netstat -antp</td><td>查看已经建⽴的TCP连接</td></tr><tr><td>netstat -lutp</td><td>查看TCP/UDP的状态信息</td></tr><tr><td>ifup eth0</td><td>启⽤eth0⽹络设备</td></tr><tr><td>ifdown eth0</td><td>禁⽤eth0⽹络设备</td></tr><tr><td>iptables -L</td><td>查看iptables规则</td></tr><tr><td>ifconfig eth0 192.168.1.1 netmask 255.255.255.0</td><td>配置ip地址</td></tr><tr><td>dhclient eth0</td><td>以dhcp模式启⽤eth0</td></tr><tr><td>route add -net 0/0 gw Gateway_IP</td><td>配置默认⽹关</td></tr><tr><td>route add -net 192.168.0.0 netmask 255.255.0.0 gw 192.168.1.1</td><td>配置静态路由到达⽹络’192.168.0.0/16’</td></tr><tr><td>route del 0/0 gw Gateway_IP</td><td>删除静态路由</td></tr><tr><td>hostname</td><td>查看主机名</td></tr><tr><td>host <a href="http://www.baidu.com">www.baidu.com</a></td><td>解析主机名</td></tr><tr><td>nslookup <a href="http://www.baidu.com">www.baidu.com</a></td><td>查询DNS记录，查看域名解析是否正常</td></tr><tr><td>ps -ef</td><td>查看所有进程</td></tr><tr><td>ps -ef \</td><td>grep codesheep</td><td>过滤出你需要的进程</td></tr><tr><td>kill -s name</td><td>kill指定名称的进程</td></tr><tr><td>kill -s pid</td><td>kill指定pid的进程</td></tr><tr><td>top</td><td>实时显示进程状态</td></tr><tr><td>vmstat 1 20</td><td>每1秒采⼀次系统状态，采20次</td></tr><tr><td>iostat</td><td>iostat</td></tr><tr><td>sar -u 1 10</td><td>查询cpu使⽤情况（1秒⼀次，共10次）</td></tr><tr><td>sar -d 1 10</td><td>查询磁盘性能</td></tr></tbody></table></div><h1 id="常⻅系统服务命令"><a href="#常⻅系统服务命令" class="headerlink" title="常⻅系统服务命令"></a>常⻅系统服务命令</h1><div class="table-container"><table><thead><tr><th>常用命令</th><th>作用</th></tr></thead><tbody><tr><td>chkconfig —list</td><td>列出系统服务</td></tr><tr><td>service &lt;服务名&gt; status</td><td>查看某个服务</td></tr><tr><td>service &lt;服务名&gt; start</td><td>启动某个服务</td></tr><tr><td>service &lt;服务名&gt; stop</td><td>终⽌某个服务</td></tr><tr><td>service &lt;服务名&gt; restart</td><td>重启某个服务</td></tr><tr><td>systemctl status &lt;服务名&gt;</td><td>查看某个服务</td></tr><tr><td>systemctl start &lt;服务名&gt;</td><td>启动某个服务</td></tr><tr><td>systemctl stop &lt;服务名&gt;</td><td>终⽌某个服务</td></tr><tr><td>systemctl restart &lt;服务名&gt;</td><td>重启某个服务</td></tr><tr><td>systemctl enable &lt;服务名&gt;</td><td>关闭⾃启动</td></tr><tr><td>systemctl disable &lt;服务名&gt;</td><td>关闭⾃启动</td></tr></tbody></table></div><h1 id="⽂件和⽬录操作"><a href="#⽂件和⽬录操作" class="headerlink" title="⽂件和⽬录操作"></a>⽂件和⽬录操作</h1><div class="table-container"><table><thead><tr><th>常用命令</th><th>作用</th></tr></thead><tbody><tr><td>cd &lt;⽬录名&gt;</td><td>进⼊某个⽬录</td></tr><tr><td>cd ..</td><td>回上级⽬录</td></tr><tr><td>cd ../..</td><td>回上两级⽬录</td></tr><tr><td>cd</td><td>进个⼈主⽬录</td></tr><tr><td>cd -</td><td>回上⼀步所在⽬录</td></tr><tr><td>pwd</td><td>显示当前路径</td></tr><tr><td>ls</td><td>查看⽂件⽬录列表</td></tr><tr><td>ls -F</td><td>查看⽬录中内容（显示是⽂件还是⽬录）</td></tr><tr><td>ls -l</td><td>查看⽂件和⽬录的详情列表</td></tr><tr><td>ls -a</td><td>查看隐藏⽂件</td></tr><tr><td>ls -lh</td><td>查看⽂件和⽬录的详情列表（增强⽂件⼤⼩易读性）</td></tr><tr><td>ls -lSr</td><td>查看⽂件和⽬录列表（以⽂件⼤⼩升序查看）</td></tr><tr><td>tree</td><td>查看⽂件和⽬录的树形结构</td></tr><tr><td>mkdir &lt;⽬录名&gt;</td><td>创建⽬录</td></tr><tr><td>mkdir dir1 dir2</td><td>同时创建两个⽬录</td></tr><tr><td>mkdir -p /tmp/dir1/dir2</td><td>创建⽬录树</td></tr><tr><td>rm -f file1</td><td>删除’file1’⽂件</td></tr><tr><td>rmdir dir1</td><td>删除’dir1’⽬录</td></tr><tr><td>rm -rf dir1</td><td>删除’dir1’⽬录和其内容</td></tr><tr><td>rm -rf dir1 dir2</td><td>同时删除两个⽬录及其内容</td></tr><tr><td>mv old_dir new_dir</td><td>重命名/移动⽬录</td></tr><tr><td>cp file1 file2</td><td>复制⽂件</td></tr><tr><td>cp dir/* .</td><td>复制某⽬录下的所有⽂件⾄当前⽬录</td></tr><tr><td>cp -a dir1 dir2</td><td>复制⽬录</td></tr><tr><td>cp -a /tmp/dir1 .</td><td>复制⼀个⽬录⾄当前⽬录</td></tr><tr><td>ln -s file1 link1</td><td>创建指向⽂件/⽬录的软链接</td></tr><tr><td>ln file1 lnk1</td><td>创建指向⽂件/⽬录的物理链接</td></tr><tr><td>find / -name file1</td><td>从跟⽬录开始搜索⽂件/⽬录</td></tr><tr><td>find / -user user1</td><td>搜索⽤户user1的⽂件/⽬录</td></tr><tr><td>find /dir -name *.bin</td><td>在⽬录/dir中搜带有.bin后缀的⽂件</td></tr><tr><td>locate &lt;关键词&gt;</td><td>快速定位⽂件</td></tr><tr><td>locate *.mp4</td><td>寻找.mp4结尾的⽂件</td></tr><tr><td>whereis &lt;关键词&gt;</td><td>显示某⼆进制⽂件/可执⾏⽂件的路径</td></tr><tr><td>which &lt;关键词&gt;</td><td>查找系统⽬录下某的⼆进制⽂件</td></tr><tr><td>chmod ugo+rwx dir1</td><td>设置⽬录所有者(u)、群组(g)及其他⼈(o)的读（r）写(w)执⾏(x)权限</td></tr><tr><td>chmod go-rwx dir1</td><td>移除群组(g)与其他⼈(o)对⽬录的读写执⾏权限</td></tr><tr><td>chown user1 file1</td><td>改变⽂件的所有者属性</td></tr><tr><td>chown -R user1 dir1</td><td>改变⽬录的所有者属性</td></tr><tr><td>chgrp group1 file1</td><td>改变⽂件群组</td></tr><tr><td>chown user1:group1 file1</td><td>改变⽂件的所有⼈和群组</td></tr></tbody></table></div><h1 id="⽂件查看和处理"><a href="#⽂件查看和处理" class="headerlink" title="⽂件查看和处理"></a>⽂件查看和处理</h1><div class="table-container"><table><thead><tr><th>常用命令</th><th>作用</th></tr></thead><tbody><tr><td>cat file1</td><td>查看⽂件内容</td></tr><tr><td>cat -n file1</td><td>查看内容并标示⾏数</td></tr><tr><td>tac file1</td><td>从最后⼀⾏开始反看⽂件内容</td></tr><tr><td>more file1</td><td>more file1</td></tr><tr><td>less file1</td><td>类似more命令，但允许反向操作</td></tr><tr><td>head -2 file1</td><td>查看⽂件前两⾏</td></tr><tr><td>tail -2 file1</td><td>查看⽂件后两⾏</td></tr><tr><td>tail -f /log/msg</td><td>实时查看添加到⽂件中的内容</td></tr><tr><td>grep codesheep hello.txt</td><td>在⽂件hello.txt中查找关键词codesheep</td></tr><tr><td>grep ^sheep hello.txt</td><td>在⽂件hello.txt中查找以sheep开头的内容</td></tr><tr><td>grep [0-9] hello.txt</td><td>选择hello.txt⽂件中所有包含数字的⾏</td></tr><tr><td>sed ‘s/s1/s2/g’ hello.txt</td><td>将hello.txt⽂件中的s1替换成s2</td></tr><tr><td>sed ‘/^$/d’ hello.txt</td><td>从hello.txt⽂件中删除所有空⽩⾏</td></tr><tr><td>sed ‘/ *#/d; /^$/d’ hello.txt</td><td>从hello.txt⽂件中删除所有注释和空⽩⾏</td></tr><tr><td>sed -e ‘1d’ hello.txt</td><td>从⽂件hello.txt 中排除第⼀⾏</td></tr><tr><td>sed -n ‘/s1/p’ hello.txt</td><td>查看只包含关键词”s1”的⾏</td></tr><tr><td>sed -e ‘s/ *$//‘ hello.txt</td><td>删除每⼀⾏最后的空⽩字符</td></tr><tr><td>sed -e ‘s/s1//g’ hello.txt</td><td>从⽂档中只删除词汇s1并保留剩余全部</td></tr><tr><td>sed -n ‘1,5p;5q’ hello.txt</td><td>查看从第⼀⾏到第5⾏内容</td></tr><tr><td>sed -n ‘5p;5q’ hello.txt</td><td>查看第5⾏</td></tr><tr><td>paste file1 file2</td><td>合并两个⽂件或两栏的内容</td></tr><tr><td>paste -d ‘+’ file1 file2</td><td>合并两个⽂件或两栏的内容，中间⽤”+”区分</td></tr><tr><td>sort file1 file2</td><td>排序两个⽂件的内容</td></tr><tr><td>comm -1 file1 file2</td><td>⽐较两个⽂件的内容(去除’file1’所含内容)</td></tr><tr><td>comm -2 file1 file2</td><td>⽐较两个⽂件的内容(去除’file2’所含内容</td></tr><tr><td>comm -3 file1 file2</td><td>⽐较两个⽂件的内容(去除两⽂件共有部分)</td></tr></tbody></table></div><h1 id="打包和解压"><a href="#打包和解压" class="headerlink" title="打包和解压"></a>打包和解压</h1><div class="table-container"><table><thead><tr><th>常用命令</th><th>作用</th></tr></thead><tbody><tr><td>zip xxx.zip file</td><td>压缩⾄zip包</td></tr><tr><td>zip -r xxx.zip file1 file2 dir1</td><td>将多个⽂件+⽬录压成zip包</td></tr><tr><td>unzip xxx.zip</td><td>解压zip包</td></tr><tr><td>tar -cvf xxx.tar file</td><td>创建⾮压缩tar包</td></tr><tr><td>tar -cvf xxx.tar file1 file2 dir1</td><td>将多个⽂件+⽬录打tar包</td></tr><tr><td>tar -tf xxx.tar</td><td>查看tar包的内容</td></tr><tr><td>tar -xvf xxx.tar</td><td>解压tar包</td></tr><tr><td>tar -xvf xxx.tar -C /dir</td><td>将tar包解压⾄指定⽬录</td></tr><tr><td>tar -cvfj xxx.tar.bz2 dir</td><td>创建bz2压缩包</td></tr><tr><td>tar -jxvf xxx.tar.bz2</td><td>解压bz2压缩包</td></tr><tr><td>tar -cvfz xxx.tar.gz dir</td><td>创建gzip压缩包</td></tr><tr><td>tar -zxvf xxx.tar.gz</td><td>解压gzip压缩包</td></tr><tr><td>bunzip2 xxx.bz2</td><td>解压bz2压缩包</td></tr><tr><td>bzip2 filename</td><td>压缩⽂件</td></tr><tr><td>gunzip xxx.gz</td><td>解压gzip压缩包</td></tr><tr><td>gzip filename</td><td>压缩⽂件</td></tr><tr><td>gzip -9 filename</td><td>最⼤程度压缩</td></tr></tbody></table></div><h1 id="RPM包管理命令"><a href="#RPM包管理命令" class="headerlink" title="RPM包管理命令"></a>RPM包管理命令</h1><div class="table-container"><table><thead><tr><th>常用命令</th><th>作用</th></tr></thead><tbody><tr><td>rpm -qa</td><td>查看已安装的rpm包</td></tr><tr><td>rpm -q pkg_name</td><td>查询某个rpm包</td></tr><tr><td>rpm -q —whatprovides xxx</td><td>显示xxx功能是由哪个包提供的</td></tr><tr><td>rpm -q —whatrequires xxx</td><td>显示xxx功能被哪个程序包依赖的</td></tr><tr><td>rpm -q —changelog xxx</td><td>显示xxx包的更改记录</td></tr><tr><td>rpm -qi pkg_name</td><td>查看⼀个包的详细信息</td></tr><tr><td>rpm -qd pkg_name</td><td>查询⼀个包所提供的⽂档</td></tr><tr><td>rpm -qc pkg_name</td><td>查看已安装rpm包提供的配置⽂件</td></tr><tr><td>rpm -ql pkg_name</td><td>查看⼀个包安装了哪些⽂件</td></tr><tr><td>rpm -qf filename</td><td>查看某个⽂件属于哪个包</td></tr><tr><td>rpm -qR pkg_name</td><td>查询包的依赖关系</td></tr><tr><td>rpm -ivh xxx.rpm</td><td>安装rpm包</td></tr><tr><td>rpm -ivh —test xxx.rpm</td><td>测试安装rpm包</td></tr><tr><td>rpm -ivh —nodeps xxx.rpm</td><td>安装rpm包时忽略依赖关系</td></tr><tr><td>rpm -e xxx</td><td>卸载程序包</td></tr><tr><td>rpm -Fvh pkg_name</td><td>升级确定已安装的rpm包</td></tr><tr><td>rpm -Uvh pkg_name</td><td>升级rpm包(若未安装则会安装)</td></tr><tr><td>rpm -V pkg_name</td><td>RPM包详细信息校验</td></tr></tbody></table></div><h1 id="YUM包管理命令"><a href="#YUM包管理命令" class="headerlink" title="YUM包管理命令"></a>YUM包管理命令</h1><div class="table-container"><table><thead><tr><th>常用命令</th><th>作用</th></tr></thead><tbody><tr><td>yum repolist enabled</td><td>显示可⽤的源仓库</td></tr><tr><td>yum search pkg_name</td><td>搜索软件包</td></tr><tr><td>yum install pkg_name</td><td>下载并安装软件包</td></tr><tr><td>yum install —downloadonly pkg_name</td><td>只 下 载 不 安 装</td></tr><tr><td>yum list</td><td>显示所有程序包</td></tr><tr><td>yum list installed</td><td>查看当前系统已安装包</td></tr><tr><td>yum list updates</td><td>查看可以更新的包列表</td></tr><tr><td>yum check-update</td><td>查看可升级的软件包</td></tr><tr><td>yum update</td><td>更新所有软件包</td></tr><tr><td>yum update pkg_name</td><td>升级指定软件包</td></tr><tr><td>yum deplist pkg_name</td><td>列出软件包依赖关系</td></tr><tr><td>yum remove pkg_name</td><td>删除软件包</td></tr><tr><td>yum clean all</td><td>清除缓存</td></tr><tr><td>yum clean packages</td><td>清除缓存的软件包</td></tr><tr><td>yum clean headers</td><td>清除缓存的header</td></tr></tbody></table></div><h1 id="DPKG包管理命令"><a href="#DPKG包管理命令" class="headerlink" title="DPKG包管理命令"></a>DPKG包管理命令</h1><div class="table-container"><table><thead><tr><th>常用命令</th><th>作用</th></tr></thead><tbody><tr><td>dpkg -c xxx.deb</td><td>列出deb包的内容</td></tr><tr><td>dpkg -i xxx.deb</td><td>安装/更新deb包</td></tr><tr><td>dpkg -r pkg_name</td><td>移除deb包</td></tr><tr><td>dpkg -P pkg_name</td><td>移除deb包(不保留配置)</td></tr><tr><td>dpkg -l</td><td>查看系统中已安装deb包</td></tr><tr><td>dpkg -l pkg_name</td><td>显示包的⼤致信息</td></tr><tr><td>dpkg -L pkg_name</td><td>查看deb包安装的⽂件</td></tr><tr><td>dpkg -s pkg_name</td><td>查看包的详细信息</td></tr><tr><td>dpkg –unpack xxx.deb</td><td>解开deb包的内容</td></tr></tbody></table></div><h1 id="APT软件⼯具"><a href="#APT软件⼯具" class="headerlink" title="APT软件⼯具"></a>APT软件⼯具</h1><div class="table-container"><table><thead><tr><th>常用命令</th><th>作用</th></tr></thead><tbody><tr><td>apt-cache search pkg_name</td><td>搜索程序包</td></tr><tr><td>apt-cache show pkg_name</td><td>获取包的概览信息</td></tr><tr><td>apt-get install pkg_name</td><td>安装/升级软件包</td></tr><tr><td>apt-get purge pkg_name</td><td>卸载软件（包括配置）</td></tr><tr><td>apt-get remove pkg_name</td><td>卸载软件（不包括配置）</td></tr><tr><td>apt-get update</td><td>更新包索引信息</td></tr><tr><td>apt-get upgrade</td><td>更新已安装软件包</td></tr><tr><td>apt-get clean</td><td>清理缓存</td></tr></tbody></table></div>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 技术 </tag>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Win10/11 网络断连，无网络原因及解决方法</title>
      <link href="/2021/10/16/Win1011%E7%BD%91%E7%BB%9C%E6%96%AD%E8%BF%9E%EF%BC%8C%E6%97%A0%E7%BD%91%E7%BB%9C%E5%8E%9F%E5%9B%A0%E5%8F%8A%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95/"/>
      <url>/2021/10/16/Win1011%E7%BD%91%E7%BB%9C%E6%96%AD%E8%BF%9E%EF%BC%8C%E6%97%A0%E7%BD%91%E7%BB%9C%E5%8E%9F%E5%9B%A0%E5%8F%8A%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<p>win10 更新之后经常会出现已经连接wifi但提示无网络的情况，搜了下b站上有up主提供了方法，修改注册表即可修复</p><h1 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h1><p>在Win10 18362版以后的版本，微软在连接网络后，注册表的返回值发生了改变，之前是每当连网后，系统会自动向微软的dns.msftncsi.com发出请求，然后返回一个NCSI.txt的值，这一值如果正确时，则确认为已连网。而Win10 18362版本之后，这个返回服务器和值有了新变化并反映为6个注册表项中。这些变化因国内部分运行商的网络重定向，不能得到正确的反馈，因此出现实际能上网确显示为无internet的问题。</p><h1 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h1><ol><li><p>新建一个txt文档</p></li><li><p>写入如下内容：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">Windows Registry Editor Version 5.00</span><br><span class="line"></span><br><span class="line">[HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Services\NlaSvc\Parameters\Internet]</span><br><span class="line">ActiveDnsProbeContent=131.107.255.255</span><br><span class="line">ActiveDnsProbeContentV6=fd3e:4f5a:5b81::1</span><br><span class="line">ActiveDnsProbeHost=dns.msftncsi.com</span><br><span class="line">ActiveDnsProbeHostV6=dns.msftncsi.com</span><br><span class="line">ActiveWebProbeContent=Microsoft NCSI</span><br><span class="line">ActiveWebProbeContentV6=Microsoft NCSI         </span><br><span class="line">ActiveWebProbeHost=www.msftncsi.com                  </span><br><span class="line">ActiveWebProbeHostV6=ipv6.msftncsi.com</span><br><span class="line">ActiveWebProbePath=ncsi.txt</span><br><span class="line">ActiveWebProbePathV6=ncsi.txt</span><br><span class="line">EnableActiveProbing=dword:00000001</span><br><span class="line">PassivePollPeriod=dword:0000000f</span><br><span class="line">StaleThreshold=dword:0000001e</span><br><span class="line">WebTimeout=dword:00000023</span><br><span class="line"></span><br><span class="line">[HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Services\NlaSvc\Parameters\Internet\ManualProxies] </span><br></pre></td></tr></table></figure></li><li><p>保存，重命名后缀为.reg</p></li><li><p>运行即可</p></li></ol><blockquote><p>不放心的话可以备份注册表：</p><ol><li>win+R输regedit打开注册表编辑器</li><li>找到路径HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Services\NlaSvc\Parameters\Internet </li><li>导出</li></ol></blockquote><h1 id="参考来源"><a href="#参考来源" class="headerlink" title="参考来源"></a>参考来源</h1><p><a href="https://www.bilibili.com/video/BV1v44y1x7zM?spm_id_from=333.999.0.0">https://www.bilibili.com/video/BV1v44y1x7zM?spm_id_from=333.999.0.0</a></p><p><a href="https://www.zhihu.com/question/268072972/answer/2165203375">https://www.zhihu.com/question/268072972/answer/2165203375</a></p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 技术 </tag>
            
            <tag> 网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>常见经典算法AND背包问题</title>
      <link href="/2021/10/15/%E5%B8%B8%E8%A7%81%E7%BB%8F%E5%85%B8%E7%AE%97%E6%B3%95AND%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98/"/>
      <url>/2021/10/15/%E5%B8%B8%E8%A7%81%E7%BB%8F%E5%85%B8%E7%AE%97%E6%B3%95AND%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h1 id="常见经典算法策略的特点、区别与联系"><a href="#常见经典算法策略的特点、区别与联系" class="headerlink" title="常见经典算法策略的特点、区别与联系"></a>常见经典算法策略的特点、区别与联系</h1><h2 id="分治算法："><a href="#分治算法：" class="headerlink" title="分治算法："></a>分治算法：</h2><p>​    分治法的设计思想是：将一个难以解决的大问题分解为多个规模较小的子问题，以便分而治之。如果原问题可以分为k个子问题，其中国内1&lt;k&lt;=n,且这k个子问题都可解，并可利用子问题计算出原问题的解，则可以选择分治法解决该问题。</p><p>​    分治算法的特点：通过分治方法设计出的程序一般都递归算法，故分治法的计算效率可以用递归方程进行分析。但是分治与递归也有区别，分治是将原问题转换为若干个相似的小问题去解，而递归则是将原问题层层转化为一个与原问题相似的小问题然后再去求解。</p><h2 id="贪心算法："><a href="#贪心算法：" class="headerlink" title="贪心算法："></a>贪心算法：</h2><p>贪心算法指在求解问题的时候总是做出在当前情况下的最好的选择，不会考虑整体最优解，即只寻找局部最优解。不同的贪心策略会得到差异非常大的结果，如果希望对该问题使用贪心策略，则待求解的问题中的字问题需要具备无后效性——即某个状态以前的过程不会影响以后的状态，只与当前的状态有关。</p><p>贪心算法的特点：最优子结构性质和贪心选择性质。贪心选择性质指需要求解的问题的整体最优解可通过一系列局部最优解的选择来实现。对于每一个具体的问题，必须证明每一步所做的贪心选择最后都会达成一个全局最优解。最优子结构是指一个问题的最优解包含其子问题的最优解性质。</p><p>贪心算法与动态规划算法的区别和联系：贪心算法和动态规划算法都具有最优子结构的性质。但是动态规划算法中，每一步所做出的选择要依赖相关子问题的解，因此只有在求出相关子问题的解后才能做出选择。而贪心算法则不依赖全局解，仅仅依靠过去所做出的选择而不依赖将来所做出的选择，也不依赖子问题的解，即只选择局部最优解。</p><h2 id="动态规划算法："><a href="#动态规划算法：" class="headerlink" title="动态规划算法："></a>动态规划算法：</h2><p>动态规划算法的基本思想是将需要求解的问题划分为若干个子问题，先求解子问题，然后从这些子问题的解中得到原问题的解。动态规划算法通常用于求解具有某种最优子结构性质的问题。在这类问题中，可能会有许多可行的解，但是期望找到具有最优值的解。基于动态规划法的算法设计通常按一下四个步骤进行：</p><ol><li><p>找出最优解的性质，并描述其结构特征。</p></li><li><p>递归定义最优值。</p></li><li><p>自底向上的方式计算最优质。</p></li><li><p>根据计算最优值时得到的信息构造一个最优解。</p></li></ol><p>通常，在步骤3中计算最优值时，需要记录更多的信息，以便在步骤4中快速构造出一个最优解。</p><p>动态规划算法的特点：动态规划算法一般具有最优子结构，重叠子问题两个性质。设计动态规划算法的第一步是分析最优结构，当带求解的问题中包含了其子问题的最优解时，就可以定义该问题具有最优子结构性质。而可以用动态规划方法求解的问题，应具有重叠子问题的性质。在用递归算法自顶向下尝试解决此类问题时，每次产生的问题并不一定是新问题，有些子问题会被反复计算多次从而造成计算资源的浪费。而动态规划算法通过利用这种子问题的重叠性，对每个子问题只求一次解，并将结果保存在一个表中，当再次需要解相同的问题时只需要从表中调出数据即可。</p><p>动态规划算法与分治算法的区别与联系：动态规划酸粉与分治法类似，基本思想都是将带求解的问题分解成很多子问题，先求子问题然后从这些子问题中得到原问题的解。与分治法不同的地方在于使用动态规划求解的问题其子问题不是相互独立的，而使用分治法求解的问题其子问题相互独立，若使用分治法去求解子问题不相互独立的问题，则分解得到的子问题数量太大从而使得计算时间大大增加。另外使用分治法求解问题的时候有些子问题会被重复计算，而使用动态规划法去求解的时候每个子问题只需要计算一次。</p><h2 id="回溯算法："><a href="#回溯算法：" class="headerlink" title="回溯算法："></a>回溯算法：</h2><p>回溯算法是搜索算法的一种，它在包含问题所有解的空间树中，按照深度优先的策略从root节点出发去搜索整个空间树。这种算法搜索到解空间的任意一个节点时，会首先判断该节点是否不包含问题的解，如果不包含则跳过以该节点为根的子树，逐层向其祖先节点回溯；否则进入该子树并继续按深度优先遍历进行搜索。</p><p>回溯法的特点：回溯法在求解的过程中需要回溯到树根，并且在搜索树中所有节点后才结束。而用回溯法搜索问题的任意一个解时，只需要搜到其中一个问题的解即可结束。</p><h2 id="分支界限法"><a href="#分支界限法" class="headerlink" title="分支界限法"></a>分支界限法</h2><p>分支界限法是一种在问题的解空间树T上搜索问题解的算法，其特点是：在扩展节点出，首先生成器所有孩子节点，然后在从当前活动节点表中选择下一个扩展节点。为了有效的计算下一个活节点，加快搜索速度，就在每一个活节点处计算一个函数值，并根据已计算出的函数值从当前活节点表中选择一个最有利的节点作为扩展节点，使搜索朝着解空间中具有最优解的分支推进，以便尽快找出一个最优解。</p><p>分支界限法与回溯法的区别与联系：二者类似，一般而言分支界限法与回溯法的求解目标不同：分支界限法的求解目标是找出解空间树T中满足约束条件的一个解，或者在满足约束条件的解中找一个使得目标函数极大活着极小的解，即某种意义下的最优解。而回溯法则是找出T中满足约束条件的所有解。由于解题目标不同，导致分支界限法和回溯法的搜索方式也不同，回溯法以深度优先的方式搜索T，而分支界限法以广度优先或最小耗费有限的方式搜索T。</p><h1 id="参考取数问题的算法框架，写出0-1背包问题的3种算法，并写出找出最优解的算法"><a href="#参考取数问题的算法框架，写出0-1背包问题的3种算法，并写出找出最优解的算法" class="headerlink" title="参考取数问题的算法框架，写出0-1背包问题的3种算法，并写出找出最优解的算法"></a>参考取数问题的算法框架，写出0-1背包问题的3种算法，并写出找出最优解的算法</h1><p>定义一下0-1背包问题中的变量：给定n个物品和一个背包，物品i的重量是wi，其价值为vi，背包容量为c。</p><h2 id="动态规划算法"><a href="#动态规划算法" class="headerlink" title="动态规划算法"></a>动态规划算法</h2><h3 id="算法策略"><a href="#算法策略" class="headerlink" title="算法策略"></a>算法策略</h3><p>与贪心算法不同的是，动态规划算法需要比较选择该物品和不选择该物品所导致的最终结果，然后在做出最佳选择。如果放入第i个东西后可以取得最大价值，则前i-1个物品也取到了最大价值，重量为w-w[i]。定义dp[i][j]为放入第i个物品后可以取得最大价值，则其状态转移方程为：dp[i][j] = max(dp[i-1][j], dp[i-1][j-v[i]] +price[i])。</p><h3 id="核心算法："><a href="#核心算法：" class="headerlink" title="核心算法："></a>核心算法：</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Dongtaiguihua</span>(<span class="params">w,n,</span>):</span></span><br><span class="line">    listWV = [[<span class="number">0</span>,<span class="number">0</span>]]</span><br><span class="line">    listTemp = []</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">        listTemp = <span class="built_in">list</span>(<span class="built_in">map</span>(<span class="built_in">int</span>, <span class="built_in">input</span>().split()))  </span><br><span class="line">        listWV.append(listTemp) </span><br><span class="line"></span><br><span class="line">    value = [[<span class="number">0</span> <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(w+<span class="number">1</span>)] <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(n+<span class="number">1</span>)]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, n+<span class="number">1</span>):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, w+<span class="number">1</span>):</span><br><span class="line">        <span class="comment">#若物品不能放到背包中</span></span><br><span class="line">            <span class="keyword">if</span> j &lt; listWV[i][<span class="number">0</span>]:</span><br><span class="line">           <span class="comment">#价值与之前相同    </span></span><br><span class="line">                value[i][j] = value[i-<span class="number">1</span>][j] </span><br><span class="line">            <span class="keyword">else</span>:   </span><br><span class="line">            <span class="comment">#物品可以放到背包中，最大价值在两者之中取</span></span><br><span class="line">                value[i][j] = <span class="built_in">max</span>(value[i-<span class="number">1</span>][j], value[i-<span class="number">1</span>][j-listWV[i][<span class="number">0</span>]] + listWV[i][<span class="number">1</span>])</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> value</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="回溯法"><a href="#回溯法" class="headerlink" title="回溯法"></a>回溯法</h2><h3 id="算法策略-1"><a href="#算法策略-1" class="headerlink" title="算法策略"></a>算法策略</h3><p>使用回溯法求解时，如果用wCur和vCur分别表示当前正在搜索的部分解中装入背包物体的总重量和总价值，用vBest表示当前正在搜索部分解的最大价值，则基本思路如下：</p><ol><li>把物体按单位价值降序排列</li><li>wCur vCur vBest初始化</li><li>对于有n种可选物品的0/1背包问题，其解空间由长度为n的0-1向量组成,可用子集数表示。在搜索解空间树时，只要其左儿子结点是一个可行结点，搜索就进入左子树。当右子树中有可能包含最优解时就进入右子树搜索。</li></ol><h3 id="核心算法：-1"><a href="#核心算法：-1" class="headerlink" title="核心算法："></a>核心算法：</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">vbest：最大价值</span></span><br><span class="line"><span class="string">vCur：背包价值</span></span><br><span class="line"><span class="string">wCur：背包重量</span></span><br><span class="line"><span class="string">x：list型，标记是否路径中是否包含了该节点</span></span><br><span class="line"><span class="string">v:list型，存放所有物品的价值</span></span><br><span class="line"><span class="string">w:list型，存放所有物品的重量</span></span><br><span class="line"><span class="string">n：物品数量</span></span><br><span class="line"><span class="string">c：背包容量</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Huisu</span>(<span class="params">vbest,vCur,wCur,x,w,v,n,c</span>):</span></span><br><span class="line">    <span class="keyword">if</span> i&gt;= n <span class="keyword">and</span> vbest&lt;vCur:</span><br><span class="line">        vbest = vCur</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">if</span> wCur+w[i]&lt;=c:</span><br><span class="line">            x[i]=<span class="number">1</span></span><br><span class="line">            wCur += w[i]</span><br><span class="line">            vCur += v[i]</span><br><span class="line">            <span class="comment"># 下一个</span></span><br><span class="line">            Huisu(i+<span class="number">1</span>)</span><br><span class="line">            wCur -= w[i]</span><br><span class="line">            vCur -= v[i]</span><br><span class="line">        x[i]=<span class="number">0</span></span><br><span class="line">        <span class="comment"># 下一个</span></span><br><span class="line">        Huisu(i+<span class="number">1</span>)</span><br><span class="line"><span class="comment"># vbest中存放了最优解</span></span><br><span class="line">    <span class="keyword">return</span> vbest</span><br></pre></td></tr></table></figure><h2 id="贪心算法"><a href="#贪心算法" class="headerlink" title="贪心算法"></a>贪心算法</h2><blockquote><p>理论上贪心算法只能够求解背包问题，没法求解0-1背包问题，但是本来应该作为第三种算法的分支界限算法跑到最后一问去了，还找不到其他算法就把贪心算法放这强行充3个挽尊了orz</p></blockquote><h3 id="算法策略-2"><a href="#算法策略-2" class="headerlink" title="算法策略"></a>算法策略</h3><p>使用贪心选择求解0-1背包问题本质上还是计算单位重量价值最高的物品装到包里，但是与背包问题不同的地方在于这里没有办法对物品进行拆分，即在选择装入背包的物品时对每种物品i只有两个选择——装或者不装。不能将物品i装入背包多次，也不能只装入部分物品i，故使用该策略计算0-1背包问题的时候会存在背包装不满的情况，这符合贪心策略的最优解，即局部最优解；但是不符合整体最优解。</p><h3 id="基本步骤"><a href="#基本步骤" class="headerlink" title="基本步骤"></a>基本步骤</h3><ol><li>计算出每种物品的单位重量价值vi/wi</li><li>依贪心选择策略，将尽可能多的单位重量价值最高的物品（设其重量为wi）装进去</li><li>将物品全部装完之后，背包内总重量未超过c则按单位价值排序选择重量不超过c-wi的下一个物品全部装进去。</li><li>依此策略一直进行下去，一直到背包装满或者剩余空间不够装剩下的物品。</li></ol><h3 id="核心算法"><a href="#核心算法" class="headerlink" title="核心算法"></a>核心算法</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Listv:list型，存放所有物品的价值</span></span><br><span class="line"><span class="comment"># Listw:list型，存放所有物品的重量</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Tanxin</span>(<span class="params">n,C,Listv,Listw</span>):</span></span><br><span class="line"><span class="comment"># 计算单位价值并排序</span></span><br><span class="line">value = [(x,Listv[x] / Listw[x], Listv[x], Listw[x]) <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>,n)]</span><br><span class="line">value.sort(key=<span class="keyword">lambda</span> x:x[<span class="number">1</span>], reverse=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 开始放往包里放东西</span></span><br><span class="line">maxvalue = <span class="number">0</span></span><br><span class="line">Listx = []</span><br><span class="line"><span class="keyword">for</span> x,xi,vi,wi <span class="keyword">in</span> value:</span><br><span class="line">    <span class="comment"># 如果能放的下就全放进去</span></span><br><span class="line">    <span class="keyword">if</span> vi &lt;= C:</span><br><span class="line">        C -= wi</span><br><span class="line">        maxvalue += vi</span><br><span class="line">        Listx.append(x)</span><br><span class="line"><span class="comment"># Listx中存放的是放进包的物品，maxvalue是使用贪心算法时包内物品的总价值</span></span><br><span class="line"><span class="keyword">return</span> Listx, maxvalue</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>算法Tanxin的主要计算时间在于将各种物品依其单位重量的价值从大到小排序。因此，算法的计算时间上界为O（nlogn）。</p><h1 id="写出0-1背包问题的分支界限算法"><a href="#写出0-1背包问题的分支界限算法" class="headerlink" title="写出0-1背包问题的分支界限算法"></a>写出0-1背包问题的分支界限算法</h1><h2 id="算法策略-3"><a href="#算法策略-3" class="headerlink" title="算法策略"></a>算法策略</h2><p>采用优先队列方式，按照物品的单位价值从大到小进行优先级排序，使用大根堆结构存储物品数据。构造上界函数maxbound( )计算当前结点下的价值上界，如果当前结点下的价值上界比当前的最优值大，则将当前结点加入堆中，否则剪去该节点下的所有路径(即剪去子集树的枝)，直到堆中所有结点均被弹出。基本步骤如下：</p><ol><li><p>把物体按单位价值降序排列</p></li><li><p>节点的优先级由已装的物品价值加上剩下的最大单位重量价值的物品装满剩余容量的价值和</p></li><li><p>算法首先检查当前扩展结点的左子树结点，若满足约束条件则加入优先队列中</p></li><li><p>检查右子树结点，若满足约束条件则加入优先队列中</p></li></ol><h2 id="算法代码"><a href="#算法代码" class="headerlink" title="算法代码"></a>算法代码</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Fenzhijiexian</span>(<span class="params">vw, limit</span>):</span></span><br><span class="line"><span class="comment"># 上界函数：计算当前结点下的价值上界</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">bound</span>(<span class="params">v, w, j</span>):</span></span><br><span class="line">        <span class="keyword">if</span> j &gt;= <span class="built_in">len</span>(vw) <span class="keyword">or</span> w &gt; limit:</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">while</span> j &lt; <span class="built_in">len</span>(vw) <span class="keyword">and</span> w + vw[j][<span class="number">1</span>] &lt;= limit:</span><br><span class="line">                v, w, j = v + vw[j][<span class="number">0</span>], w + vw[j][<span class="number">1</span>], j + <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> j &lt; <span class="built_in">len</span>(vw):</span><br><span class="line">                v += (limit - w) * vw[j][<span class="number">0</span>] / (vw[j][<span class="number">1</span>] * <span class="number">1.0</span>)</span><br><span class="line">            <span class="keyword">return</span> v</span><br><span class="line">    <span class="comment"># 分支限界算法求解01背包</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">traverse</span>(<span class="params">v, w, j</span>):</span></span><br><span class="line">        <span class="keyword">nonlocal</span> maxValue</span><br><span class="line">        <span class="keyword">if</span> bound(v, w, j) &gt;= maxValue: <span class="comment"># promising </span></span><br><span class="line">            <span class="keyword">if</span> w + vw[j][<span class="number">1</span>] &lt;= limit:  <span class="comment"># w/ j</span></span><br><span class="line">                maxValue = <span class="built_in">max</span>(maxValue, v + vw[j][<span class="number">0</span>])</span><br><span class="line">                traverse(v + vw[j][<span class="number">0</span>], w + vw[j][<span class="number">1</span>], j + <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">if</span> j &lt; <span class="built_in">len</span>(vw) - <span class="number">1</span>:        <span class="comment"># w/o j</span></span><br><span class="line">                traverse(v, w, j + <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    maxValue = <span class="number">0</span></span><br><span class="line">    traverse(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> maxValue</span><br></pre></td></tr></table></figure><p>先对 vw 按照单位重量的价值排序，然后利用 bound 函数确定价值上限。如果价值上限超过了已经出现的最大价值，再分别计算加上当前物品和不加当前物品的两种情况，否则就跳过。</p><h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><blockquote><p><a href="https://blog.csdn.net/qq_42939527/article/details/104043900">https://blog.csdn.net/qq_42939527/article/details/104043900</a></p><p><a href="https://blog.csdn.net/yue_luo_/article/details/95097844">https://blog.csdn.net/yue_luo_/article/details/95097844</a></p><p><a href="https://www.cnblogs.com/chenleideblog/p/11254578.html">https://www.cnblogs.com/chenleideblog/p/11254578.html</a></p><p><a href="https://blog.csdn.net/weixin_42260102/article/details/96008327">https://blog.csdn.net/weixin_42260102/article/details/96008327</a></p><p><a href="https://www.jlao.net/technology/10188/">https://www.jlao.net/technology/10188/</a></p><p>王红珍,李竹林,延飞波.基于0-1背包问题的两种算法[J].信息技术,2011,35(02):27-29.</p><p>荣政主编. 数据结构与算法分析. 西安：西安电子科技大学出版社, 2012.02.</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>安全规约第一讲</title>
      <link href="/2021/10/12/%E5%AE%89%E5%85%A8%E8%A7%84%E7%BA%A6%E7%AC%AC%E4%B8%80%E8%AE%B2/"/>
      <url>/2021/10/12/%E5%AE%89%E5%85%A8%E8%A7%84%E7%BA%A6%E7%AC%AC%E4%B8%80%E8%AE%B2/</url>
      
        <content type="html"><![CDATA[<h1 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h1><p>安全规约课程笔记，整理一下以备以后查询使用，如果有错误欢迎留言讨论</p><p>本文的内容和图片均来自b站的郭福春老师的安全规约课程：<a href="https://space.bilibili.com/2095536965">https://space.bilibili.com/2095536965</a></p><h1 id="密码发展史"><a href="#密码发展史" class="headerlink" title="密码发展史"></a>密码发展史</h1><ul><li><p>经典密码：古罗马</p></li><li><p>近代密码：二战</p></li><li><p>现代密码（科学）：70年代以后</p></li></ul><p>模型：计算模型，安全模型</p><h1 id="概念澄清："><a href="#概念澄清：" class="headerlink" title="概念澄清："></a>概念澄清：</h1><p><img src="https://blogimages.happyshark.cn/%E5%AE%89%E5%85%A8%E8%A7%84%E7%BA%A6%E7%AC%AC%E4%B8%80%E8%AE%B2/image-20211012123908460.png" alt="image-20211012123908460"></p><ul><li><p>Cryptography：对称密码，工要密码，等等，是一种方法来达到一种目标（security）</p></li><li><p>Cryptanalysis：已有Cryptography的分析。比如分析一些公钥密码，提出一些攻击方案.etc</p></li><li><p>Cryptosystem：提出一种具体的security studys</p></li><li><p>Scheme：实现cryptosystem的一种方案</p></li></ul><p>四者关系如下：</p><p><img src="https://blogimages.happyshark.cn/%E5%AE%89%E5%85%A8%E8%A7%84%E7%BA%A6%E7%AC%AC%E4%B8%80%E8%AE%B2/image-20211012123920826.png" alt="image-20211012123920826"></p><h1 id="如何定义一个算法"><a href="#如何定义一个算法" class="headerlink" title="如何定义一个算法"></a>如何定义一个算法</h1><p><img src="https://blogimages.happyshark.cn/%E5%AE%89%E5%85%A8%E8%A7%84%E7%BA%A6%E7%AC%AC%E4%B8%80%E8%AE%B2/image-20211012123942284.png" alt="image-20211012123942284"></p><p>当现有方案无法解决需求的时候，就必须要提出一种新的算法来满足需求</p><h2 id="具体步骤："><a href="#具体步骤：" class="headerlink" title="具体步骤："></a>具体步骤：</h2><ol><li><p>确定一个完整的安全目标</p></li><li><p>确定涉及到几个参与方</p></li><li><p>需要确定至少需要几个算法（当然越少越好，但也不可能无限制优化）Ex：签名，有一个签名算法必然有一个对应的验证算法。</p></li><li><p>每个算法的名字该如何命名（类似编程中的函数名）</p></li><li><p>每个算法应该由2中的谁运行（为了给审稿人理清思路hhh）</p></li><li><p>每个算法的输入输出是啥</p></li><li><p>算法的正确性（下回分解）</p></li></ol><h2 id="举个例子：定义一个数字签名的算法"><a href="#举个例子：定义一个数字签名的算法" class="headerlink" title="举个例子：定义一个数字签名的算法"></a>举个例子：定义一个数字签名的算法</h2><p><img src="https://blogimages.happyshark.cn/%E5%AE%89%E5%85%A8%E8%A7%84%E7%BA%A6%E7%AC%AC%E4%B8%80%E8%AE%B2/image-20211012123959709.png" alt="image-20211012123959709"></p><p>上面就是一个讲故事的方式（只有讲故事的时候才Alice，bob，正式的描述算法的时候要精确一些，比如服务器，路由器，云，AS等，这种场景下使用ABC审稿人会锤爆你的狗头#滑稽），在这个过程中：</p><ul><li><p>参与方：signer，verifier</p></li><li><p>有几个算法：看涉及到几个计算，一个计算对应一个算法。故有3个计算（算法）+ 1个系统参数（system parameter generation）</p></li><li><p>给算法取名：SysGen，KeyGen，Sign，Verify</p></li></ul><blockquote><p>注：取名的要求</p><ol><li>美观</li><li>简洁</li><li>易懂<br>Ex：KeyGen（完美），KeyGeneration（太长），Key_Gen（少用下划线），Key Gen（不要用空格），i（审稿人提刀在路上了）</li></ol></blockquote><ul><li>每个算法由谁运行：</li></ul><p><img src="https://blogimages.happyshark.cn/%E5%AE%89%E5%85%A8%E8%A7%84%E7%BA%A6%E7%AC%AC%E4%B8%80%E8%AE%B2/image-20211012124014972.png" alt="image-20211012124014972"></p><ul><li>抽象化：</li></ul><p><img src="https://blogimages.happyshark.cn/%E5%AE%89%E5%85%A8%E8%A7%84%E7%BA%A6%E7%AC%AC%E4%B8%80%E8%AE%B2/image-20211012124020329.png" alt="image-20211012124020329"></p><blockquote><ol><li>箭头和等号是有区别的，谨慎使用</li><li>输入和输出的符号有一般的约定，不要乱用</li><li>就算抄，也要改几个符号，简简单单的修改</li></ol></blockquote><ul><li>正确性：</li></ul><p><img src="https://blogimages.happyshark.cn/%E5%AE%89%E5%85%A8%E8%A7%84%E7%BA%A6%E7%AC%AC%E4%B8%80%E8%AE%B2/image-20211012124027422.png" alt="image-20211012124027422"></p><h1 id="如何定义一个安全模型（第29期）"><a href="#如何定义一个安全模型（第29期）" class="headerlink" title="如何定义一个安全模型（第29期）"></a>如何定义一个安全模型（第29期）</h1><h2 id="如何分析一个方案的安全性"><a href="#如何分析一个方案的安全性" class="headerlink" title="如何分析一个方案的安全性"></a>如何分析一个方案的安全性</h2><p>可以从以下几个方面考虑：</p><ol><li><p>如何分析一个scheme的安全性</p></li><li><p>一个scheme（在安全模型下是安全的）可以抵抗所有（any）攻击吗？</p></li></ol><p>安全模型是为了提出一个方案而定义的吗</p><ol><li>安全模型是为了提出一个方案而定义的吗</li></ol><h2 id="什么是安全模型？"><a href="#什么是安全模型？" class="headerlink" title="什么是安全模型？"></a>什么是安全模型？</h2><p><img src="https://blogimages.happyshark.cn/%E5%AE%89%E5%85%A8%E8%A7%84%E7%BA%A6%E7%AC%AC%E4%B8%80%E8%AE%B2/image-20211012124045272.png" alt="image-20211012124045272"></p><ul><li><p>一个安全模型可以当成一个集合，攻击类型可以看成一个一个点。一个集合无法包含所有的点，即一个安全模型无法包含所有的攻击</p></li><li><p>抽象攻击：侧重介绍敌手可以获取什么信息以及如何获取这些信息。</p></li><li><p>安全模型是为了cryptosystem定义而不是为了某一个具体scheme定义</p></li></ul><blockquote><p>比如有个cryptosystem；里面有个scheme用到了hash函数，那你定义安全模型的时候就不能用hash函数，因为一个cryptosystem不一定用到hash函数，如果你定义了hash函数就意味着所有的cryptosystem都用到了hash函数</p></blockquote><h2 id="定义安全模型的方法"><a href="#定义安全模型的方法" class="headerlink" title="定义安全模型的方法"></a>定义安全模型的方法</h2><ul><li><p>game，下面用的这个种</p></li><li><p>伪代码（对新手不友好）</p></li></ul><p>Game方法：通过一种game的方式（adversary vs challenger）来描述</p><ul><li><p>challenger：crypsystem的拥有者，产生公私钥</p></li><li><p>adversary：尝试break这个cryptsystem（而不是scheme）</p></li></ul><blockquote><p>显而易见，二者存在信息差</p></blockquote><p>则一个安全模型定义了：</p><p>adversary能力：</p><ul><li><p>what：他可以查询什么信息</p></li><li><p>when：他什么时候可以查询这些信息</p></li></ul><p>adversary的安全目标：</p><ul><li>how：如何赢得这场game（break the cryptsystem）</li></ul><p>定义安全模型的四步：</p><p><img src="https://blogimages.happyshark.cn/%E5%AE%89%E5%85%A8%E8%A7%84%E7%BA%A6%E7%AC%AC%E4%B8%80%E8%AE%B2/image-20211012124056662.png" alt="image-20211012124056662"></p><ol><li>setup：初始化定义双方</li></ol><p>2.capabilities：描述什么时间敌手会以什么方式获取信息（query），并且challenger要诚实的回应（response）</p><blockquote><p>当然要诚实的回答，这个问题类似减法的时候高位不给低位借咋整（锤爆高位的狗头#滑稽）</p></blockquote><p>3.安全目标：定义一个敌手赢得游戏的目标</p><p>4.优势（advantage）：定义一个满足条件的参数（parameter）</p><p>Ex：对于一个签名方案，定义一个安全模型</p><p><img src="C:/Users/happy/Desktop/%25E6%259C%2589%25E9%2581%2593%25E4%25BA%2591%25E7%25AC%2594%25E8%25AE%25B0%25E5%25AF%25BC%25E5%2587%25BA/youdaonote-pull-master/youdaonote/youdaonote-images/WEBRESOURCE2838a5247c371604f5504a3ace992c58.png" alt=""></p><blockquote><ol><li>并不是所有的放哪都有Advantage</li><li>有些行为必须被禁止，比如问问challenger的私钥是啥</li></ol></blockquote><h2 id="什么时候该定义一个安全模型"><a href="#什么时候该定义一个安全模型" class="headerlink" title="什么时候该定义一个安全模型"></a>什么时候该定义一个安全模型</h2><p>当我们需要考虑一个算法的输入和输出的是时候就可以定义一个安全模型。</p><p><img src="https://blogimages.happyshark.cn/%E5%AE%89%E5%85%A8%E8%A7%84%E7%BA%A6%E7%AC%AC%E4%B8%80%E8%AE%B2/image-20211012124118557.png" alt="image-20211012124118557"></p><p>需要确定哪些需要考虑，哪些不需要，并且抽象化</p><blockquote><p>比如确认参与方应该问啥</p></blockquote><p><img src="https://blogimages.happyshark.cn/%E5%AE%89%E5%85%A8%E8%A7%84%E7%BA%A6%E7%AC%AC%E4%B8%80%E8%AE%B2/image-20211012124128683.png" alt="image-20211012124128683"></p><h1 id="形式化描述一个安全模型（可以借鉴，不能copy）"><a href="#形式化描述一个安全模型（可以借鉴，不能copy）" class="headerlink" title="形式化描述一个安全模型（可以借鉴，不能copy）"></a>形式化描述一个安全模型（可以借鉴，不能copy）</h1><p>Ex：</p><p><img src="https://blogimages.happyshark.cn/%E5%AE%89%E5%85%A8%E8%A7%84%E7%BA%A6%E7%AC%AC%E4%B8%80%E8%AE%B2/image-20211012124135249.png" alt="image-20211012124135249"></p><h1 id="安全模型定义的一些注释（听不清了，变身截图狂魔）"><a href="#安全模型定义的一些注释（听不清了，变身截图狂魔）" class="headerlink" title="安全模型定义的一些注释（听不清了，变身截图狂魔）"></a>安全模型定义的一些注释（听不清了，变身截图狂魔）</h1><ul><li>一个Cryptosystem可能有多个sercuity service</li></ul><blockquote><p>比如Alice给bob发消息，会对其加密并且签名，故这里alice提供了两个服务，签名和加密。</p></blockquote><ul><li>一个sercuity service 需要一个security model 去定义</li></ul><p><img src="https://blogimages.happyshark.cn/%E5%AE%89%E5%85%A8%E8%A7%84%E7%BA%A6%E7%AC%AC%E4%B8%80%E8%AE%B2/image-20211012124147481.png" alt="image-20211012124147481"></p><ul><li>一个安全模型可以对应多个sercuity service</li></ul><p><img src="https://blogimages.happyshark.cn/%E5%AE%89%E5%85%A8%E8%A7%84%E7%BA%A6%E7%AC%AC%E4%B8%80%E8%AE%B2/image-20211012124153964.png" alt="image-20211012124153964"></p><blockquote><p>standard model是一种计算模型</p><p>standard security model 是一种安全模型</p></blockquote><ul><li><p>标准的安全模型不一定是最强的，没有对比的话很难区分standard &amp; strong</p></li><li><p>标准/强/弱的区别在证明的时候区别是很大的</p></li></ul><p><img src="https://blogimages.happyshark.cn/%E5%AE%89%E5%85%A8%E8%A7%84%E7%BA%A6%E7%AC%AC%E4%B8%80%E8%AE%B2/image-20211012124203183.png" alt="image-20211012124203183"></p><blockquote><p>19期文章有更加详细的解释</p></blockquote><ul><li><p>没有安全模型，就无法把攻破方案抽象成解决一个计算问题</p></li><li><p>无法把攻破方案抽象成解决一个计算问题，就没法定义一个安全模型</p></li></ul><h1 id="一些例子和练习"><a href="#一些例子和练习" class="headerlink" title="一些例子和练习"></a>一些例子和练习</h1><p><img src="https://blogimages.happyshark.cn/%E5%AE%89%E5%85%A8%E8%A7%84%E7%BA%A6%E7%AC%AC%E4%B8%80%E8%AE%B2/image-20211012124335581.png" alt="image-20211012124335581"></p><p><img src="https://blogimages.happyshark.cn/%E5%AE%89%E5%85%A8%E8%A7%84%E7%BA%A6%E7%AC%AC%E4%B8%80%E8%AE%B2/image-20211012124342656.png" alt="image-20211012124342656"></p><p><img src="https://blogimages.happyshark.cn/%E5%AE%89%E5%85%A8%E8%A7%84%E7%BA%A6%E7%AC%AC%E4%B8%80%E8%AE%B2/image-20211012124349493.png" alt="image-20211012124349493"></p><p><img src="https://blogimages.happyshark.cn/%E5%AE%89%E5%85%A8%E8%A7%84%E7%BA%A6%E7%AC%AC%E4%B8%80%E8%AE%B2/image-20211012124358144.png" alt="image-20211012124358144"></p><p><img src="https://blogimages.happyshark.cn/%E5%AE%89%E5%85%A8%E8%A7%84%E7%BA%A6%E7%AC%AC%E4%B8%80%E8%AE%B2/image-20211012124405842.png" alt="image-20211012124405842"></p><ul><li>以上的定义和解释可以从一些论文和公开资料中获得</li></ul><blockquote><p>密码学报 2019 第六期的文章也有一些资料可以查看</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 密码学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 安全规约 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>开机执行python脚本自动登录SNNU校园网</title>
      <link href="/2021/10/02/%E5%BC%80%E6%9C%BA%E6%89%A7%E8%A1%8Cpython%E8%84%9A%E6%9C%AC%E8%87%AA%E5%8A%A8%E7%99%BB%E5%BD%95SNNU%E6%A0%A1%E5%9B%AD%E7%BD%91/"/>
      <url>/2021/10/02/%E5%BC%80%E6%9C%BA%E6%89%A7%E8%A1%8Cpython%E8%84%9A%E6%9C%AC%E8%87%AA%E5%8A%A8%E7%99%BB%E5%BD%95SNNU%E6%A0%A1%E5%9B%AD%E7%BD%91/</url>
      
        <content type="html"><![CDATA[<h1 id="需要准备的东西"><a href="#需要准备的东西" class="headerlink" title="需要准备的东西"></a>需要准备的东西</h1><ul><li>一位大佬写的python脚本一份：<a href="https://github.com/LiYW-SL/SNNU_login">https://github.com/LiYW-SL/SNNU_login</a></li><li>搭建python环境一个（python3测试通过）</li><li>windows10 OR 11一台</li></ul><h1 id="设置步骤"><a href="#设置步骤" class="headerlink" title="设置步骤"></a>设置步骤</h1><ol><li><p>新建个txt文件，打开填入以下内容</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">@echo off  </span><br><span class="line">python  D:\loginSNNU.py</span><br><span class="line">exit</span><br></pre></td></tr></table></figure><p>如果还想在自动开启热点（给我自己的电脑和手机和板子提供wifi用，<del>一懒到底</del>）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@echo off  </span><br><span class="line">python  D:\loginSNNU.py</span><br><span class="line">powershell.exe -encodedCommand WwBXAGkAbgBkAG8AdwBzAC4AUwB5AHMAdABlAG0ALgBVAHMAZQByAFAAcgBvAGYAaQBsAGUALgBMAG8AYwBrAFMAYwByAGUAZQBuACwAVwBpAG4AZABvAHcAcwAuAFMAeQBzAHQAZQBtAC4AVQBzAGUAcgBQAHIAbwBmAGkAbABlACwAQwBvAG4AdABlAG4AdABUAHkAcABlAD0AVwBpAG4AZABvAHcAcwBSAHUAbgB0AGkAbQBlAF0AIAB8ACAATwB1AHQALQBOAHUAbABsAA0ACgBBAGQAZAAtAFQAeQBwAGUAIAAtAEEAcwBzAGUAbQBiAGwAeQBOAGEAbQBlACAAUwB5AHMAdABlAG0ALgBSAHUAbgB0AGkAbQBlAC4AVwBpAG4AZABvAHcAcwBSAHUAbgB0AGkAbQBlAA0ACgAkAGEAcwBUAGEAcwBrAEcAZQBuAGUAcgBpAGMAIAA9ACAAKABbAFMAeQBzAHQAZQBtAC4AVwBpAG4AZABvAHcAcwBSAHUAbgB0AGkAbQBlAFMAeQBzAHQAZQBtAEUAeAB0AGUAbgBzAGkAbwBuAHMAXQAuAEcAZQB0AE0AZQB0AGgAbwBkAHMAKAApACAAfAAgAD8AIAB7ACAAJABfAC4ATgBhAG0AZQAgAC0AZQBxACAAJwBBAHMAVABhAHMAawAnACAALQBhAG4AZAAgACQAXwAuAEcAZQB0AFAAYQByAGEAbQBlAHQAZQByAHMAKAApAC4AQwBvAHUAbgB0ACAALQBlAHEAIAAxACAALQBhAG4AZAAgACQAXwAuAEcAZQB0AFAAYQByAGEAbQBlAHQAZQByAHMAKAApAFsAMABdAC4AUABhAHIAYQBtAGUAdABlAHIAVAB5AHAAZQAuAE4AYQBtAGUAIAAtAGUAcQAgACcASQBBAHMAeQBuAGMATwBwAGUAcgBhAHQAaQBvAG4AYAAxACcAIAB9ACkAWwAwAF0ADQAKAEYAdQBuAGMAdABpAG8AbgAgAEEAdwBhAGkAdAAoACQAVwBpAG4AUgB0AFQAYQBzAGsALAAgACQAUgBlAHMAdQBsAHQAVAB5AHAAZQApACAAewANAAoAIAAgACAAIAAkAGEAcwBUAGEAcwBrACAAPQAgACQAYQBzAFQAYQBzAGsARwBlAG4AZQByAGkAYwAuAE0AYQBrAGUARwBlAG4AZQByAGkAYwBNAGUAdABoAG8AZAAoACQAUgBlAHMAdQBsAHQAVAB5AHAAZQApAA0ACgAgACAAIAAgACQAbgBlAHQAVABhAHMAawAgAD0AIAAkAGEAcwBUAGEAcwBrAC4ASQBuAHYAbwBrAGUAKAAkAG4AdQBsAGwALAAgAEAAKAAkAFcAaQBuAFIAdABUAGEAcwBrACkAKQANAAoAIAAgACAAIAAkAG4AZQB0AFQAYQBzAGsALgBXAGEAaQB0ACgALQAxACkAIAB8ACAATwB1AHQALQBOAHUAbABsAA0ACgAgACAAIAAgACQAbgBlAHQAVABhAHMAawAuAFIAZQBzAHUAbAB0AA0ACgB9AA0ACgBGAHUAbgBjAHQAaQBvAG4AIABBAHcAYQBpAHQAQQBjAHQAaQBvAG4AKAAkAFcAaQBuAFIAdABBAGMAdABpAG8AbgApACAAewANAAoAIAAgACAAIAAkAGEAcwBUAGEAcwBrACAAPQAgACgAWwBTAHkAcwB0AGUAbQAuAFcAaQBuAGQAbwB3AHMAUgB1AG4AdABpAG0AZQBTAHkAcwB0AGUAbQBFAHgAdABlAG4AcwBpAG8AbgBzAF0ALgBHAGUAdABNAGUAdABoAG8AZABzACgAKQAgAHwAIAA/ACAAewAgACQAXwAuAE4AYQBtAGUAIAAtAGUAcQAgACcAQQBzAFQAYQBzAGsAJwAgAC0AYQBuAGQAIAAkAF8ALgBHAGUAdABQAGEAcgBhAG0AZQB0AGUAcgBzACgAKQAuAEMAbwB1AG4AdAAgAC0AZQBxACAAMQAgAC0AYQBuAGQAIAAhACQAXwAuAEkAcwBHAGUAbgBlAHIAaQBjAE0AZQB0AGgAbwBkACAAfQApAFsAMABdAA0ACgAgACAAIAAgACQAbgBlAHQAVABhAHMAawAgAD0AIAAkAGEAcwBUAGEAcwBrAC4ASQBuAHYAbwBrAGUAKAAkAG4AdQBsAGwALAAgAEAAKAAkAFcAaQBuAFIAdABBAGMAdABpAG8AbgApACkADQAKACAAIAAgACAAJABuAGUAdABUAGEAcwBrAC4AVwBhAGkAdAAoAC0AMQApACAAfAAgAE8AdQB0AC0ATgB1AGwAbAANAAoAfQANAAoADQAKACQAYwBvAG4AbgBlAGMAdABpAG8AbgBQAHIAbwBmAGkAbABlACAAPQAgAFsAVwBpAG4AZABvAHcAcwAuAE4AZQB0AHcAbwByAGsAaQBuAGcALgBDAG8AbgBuAGUAYwB0AGkAdgBpAHQAeQAuAE4AZQB0AHcAbwByAGsASQBuAGYAbwByAG0AYQB0AGkAbwBuACwAVwBpAG4AZABvAHcAcwAuAE4AZQB0AHcAbwByAGsAaQBuAGcALgBDAG8AbgBuAGUAYwB0AGkAdgBpAHQAeQAsAEMAbwBuAHQAZQBuAHQAVAB5AHAAZQA9AFcAaQBuAGQAbwB3AHMAUgB1AG4AdABpAG0AZQBdADoAOgBHAGUAdABJAG4AdABlAHIAbgBlAHQAQwBvAG4AbgBlAGMAdABpAG8AbgBQAHIAbwBmAGkAbABlACgAKQANAAoAJAB0AGUAdABoAGUAcgBpAG4AZwBNAGEAbgBhAGcAZQByACAAPQAgAFsAVwBpAG4AZABvAHcAcwAuAE4AZQB0AHcAbwByAGsAaQBuAGcALgBOAGUAdAB3AG8AcgBrAE8AcABlAHIAYQB0AG8AcgBzAC4ATgBlAHQAdwBvAHIAawBPAHAAZQByAGEAdABvAHIAVABlAHQAaABlAHIAaQBuAGcATQBhAG4AYQBnAGUAcgAsAFcAaQBuAGQAbwB3AHMALgBOAGUAdAB3AG8AcgBrAGkAbgBnAC4ATgBlAHQAdwBvAHIAawBPAHAAZQByAGEAdABvAHIAcwAsAEMAbwBuAHQAZQBuAHQAVAB5AHAAZQA9AFcAaQBuAGQAbwB3AHMAUgB1AG4AdABpAG0AZQBdADoAOgBDAHIAZQBhAHQAZQBGAHIAbwBtAEMAbwBuAG4AZQBjAHQAaQBvAG4AUAByAG8AZgBpAGwAZQAoACQAYwBvAG4AbgBlAGMAdABpAG8AbgBQAHIAbwBmAGkAbABlACkADQAKAA0ACgAjACAAQgBlACAAcwB1AHIAZQAgAHQAbwAgAGkAbgBjAGwAdQBkAGUAIABCAGUAbgAgAE4ALgAnAHMAIABhAHcAYQBpAHQAIABmAG8AcgAgAEkAQQBzAHkAbgBjAE8AcABlAHIAYQB0AGkAbwBuADoADQAKACMAIABoAHQAdABwAHMAOgAvAC8AcwB1AHAAZQByAHUAcwBlAHIALgBjAG8AbQAvAHEAdQBlAHMAdABpAG8AbgBzAC8AMQAzADQAMQA5ADkANwAvAHUAcwBpAG4AZwAtAGEALQB1AHcAcAAtAGEAcABpAC0AbgBhAG0AZQBzAHAAYQBjAGUALQBpAG4ALQBwAG8AdwBlAHIAcwBoAGUAbABsAA0ACgANAAoAIwAgAEMAaABlAGMAawAgAHcAaABlAHQAaABlAHIAIABNAG8AYgBpAGwAZQAgAEgAbwB0AHMAcABvAHQAIABpAHMAIABlAG4AYQBiAGwAZQBkAA0ACgAkAHQAZQB0AGgAZQByAGkAbgBnAE0AYQBuAGEAZwBlAHIALgBUAGUAdABoAGUAcgBpAG4AZwBPAHAAZQByAGEAdABpAG8AbgBhAGwAUwB0AGEAdABlAA0ACgANAAoAIwAgAEkAZgAgAE0AbwBiAGkAbABlACAASABvAHQAcwBwAG8AdAAgAGkAcwAgAG8AbgAgAC0AIAB0AHUAcgBuACAAaQB0ACAAbwBmAGYALgANAAoAaQBmACAAKAAkAHQAZQB0AGgAZQByAGkAbgBnAE0AYQBuAGEAZwBlAHIALgBUAGUAdABoAGUAcgBpAG4AZwBPAHAAZQByAGEAdABpAG8AbgBhAGwAUwB0AGEAdABlACAALQBlAHEAIAAxACkAewANAAoAIAAgACAAIAAjACAAUwB0AG8AcAAgAE0AbwBiAGkAbABlACAASABvAHQAcwBwAG8AdAANAAoAIAAgACAAIABBAHcAYQBpAHQAIAAoACQAdABlAHQAaABlAHIAaQBuAGcATQBhAG4AYQBnAGUAcgAuAFMAdABvAHAAVABlAHQAaABlAHIAaQBuAGcAQQBzAHkAbgBjACgAKQApACAAKABbAFcAaQBuAGQAbwB3AHMALgBOAGUAdAB3AG8AcgBrAGkAbgBnAC4ATgBlAHQAdwBvAHIAawBPAHAAZQByAGEAdABvAHIAcwAuAE4AZQB0AHcAbwByAGsATwBwAGUAcgBhAHQAbwByAFQAZQB0AGgAZQByAGkAbgBnAE8AcABlAHIAYQB0AGkAbwBuAFIAZQBzAHUAbAB0AF0AKQANAAoAfQANAAoAIwAgAEkAZgAgAE0AbwBiAGkAbABlACAASABvAHQAcwBwAG8AdAAgAGkAcwAgAG8AZgBmACAALQAgAHQAdQByAG4AIABpAHQAIABvAG4ALgANAAoAZQBsAHMAZQB7AA0ACgAgACAAIAAgACMAIABTAHQAYQByAHQAIABNAG8AYgBpAGwAZQAgAEgAbwB0AHMAcABvAHQADQAKACAAIAAgACAAQQB3AGEAaQB0ACAAKAAkAHQAZQB0AGgAZQByAGkAbgBnAE0AYQBuAGEAZwBlAHIALgBTAHQAYQByAHQAVABlAHQAaABlAHIAaQBuAGcAQQBzAHkAbgBjACgAKQApACAAKABbAFcAaQBuAGQAbwB3AHMALgBOAGUAdAB3AG8AcgBrAGkAbgBnAC4ATgBlAHQAdwBvAHIAawBPAHAAZQByAGEAdABvAHIAcwAuAE4AZQB0AHcAbwByAGsATwBwAGUAcgBhAHQAbwByAFQAZQB0AGgAZQByAGkAbgBnAE8AcABlAHIAYQB0AGkAbwBuAFIAZQBzAHUAbAB0AF0AKQANAAoAfQANAAoADQAKAA==</span><br><span class="line">exit</span><br></pre></td></tr></table></figure><p>其中<code>D:\loginSNNU.py</code>是登录文件绝对路径</p></li><li><p>将文件命名为loginSNNU.bat</p></li><li><p>搜索<code>计划任务</code>程序，打开然后点击<code>创建任务</code></p><p><img src="https://blogimages.happyshark.cn/%E7%99%BB%E5%BD%95snnu/image-20211002224758046.png" alt="image-20211002224758046"></p></li><li><p>填下名称，其他配置参考如下：</p><p><img src="https://blogimages.happyshark.cn/%E7%99%BB%E5%BD%95snnu/image-20211002224908184.png" alt="image-20211002224908184"></p><p><img src="https://blogimages.happyshark.cn/%E7%99%BB%E5%BD%95snnu/image-20211002224934712.png" alt="image-20211002224934712"></p><p><img src="https://blogimages.happyshark.cn/%E7%99%BB%E5%BD%95snnu/image-20211002225005425.png" alt="image-20211002225005425"></p></li></ol><p>OVER</p><h1 id="或者"><a href="#或者" class="headerlink" title="或者"></a>或者</h1><h2 id="启动脚本方式"><a href="#启动脚本方式" class="headerlink" title="启动脚本方式"></a>启动脚本方式</h2><ol><li><p>bat文件创建过程同上</p></li><li><p>win+R输入<code>gpedit.msc</code>启动组策略编辑器</p></li><li><p>选择启动配置项</p><p><img src="https://blogimages.happyshark.cn/%E7%99%BB%E5%BD%95snnu/image-20211002201724296.png" alt="image-20211002201724296"></p></li><li><p>点击<code>浏览</code>添加需要运行的bat脚本</p><p><img src="https://blogimages.happyshark.cn/%E7%99%BB%E5%BD%95snnu/image-20211002210159374.png" alt="image-20211002210159374"></p></li><li><p>设置一下脚本最长运行时间，要不然一出错就运行个没完了</p><p><img src="https://blogimages.happyshark.cn/%E7%99%BB%E5%BD%95snnu/image-20211002202815469.png" alt="image-20211002202815469"></p></li></ol><h2 id="启动文件夹方式"><a href="#启动文件夹方式" class="headerlink" title="启动文件夹方式"></a>启动文件夹方式</h2><p><code>stackoverflow</code>上找到的，这个更简单：<a href="https://stackoverflow.com/questions/51622702/windows-10-run-python-program-in-startup">https://stackoverflow.com/questions/51622702/windows-10-run-python-program-in-startup</a></p><ol><li><p>win+r运行<code>shell:startup</code></p></li><li><p>把bat文件扔进去</p></li><li>over</li></ol>]]></content>
      
      
      <categories>
          
          <category> SNNU </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 技术 </tag>
            
            <tag> 网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>win11启用wsl2</title>
      <link href="/2021/09/30/win11%E5%90%AF%E7%94%A8wsl2/"/>
      <url>/2021/09/30/win11%E5%90%AF%E7%94%A8wsl2/</url>
      
        <content type="html"><![CDATA[<p>前两天帮师兄跑一个docker，发现安装完docker for windows后死活打不开，今天晚上决定捣鼓捣鼓这个问题。。。</p><h1 id="安装vmware-16"><a href="#安装vmware-16" class="headerlink" title="安装vmware 16"></a>安装vmware 16</h1><p>据传闻说vm16版本好像支持共存，故直接安装最新版本的即可。</p><h1 id="安装docker"><a href="#安装docker" class="headerlink" title="安装docker"></a>安装docker</h1><ol><li><p>先去windows功能里面启用<code>虚拟机平台</code>和<code>适用于linux的windows子系统</code></p><p><img src="https://blogimages.happyshark.cn/win11%E5%90%AF%E7%94%A8wsl2/image-20210930203355617.png" alt="image-20210930203355617"></p></li><li><p>重启，管理员身份打开cmd，输入以下指令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wsl --set-default-version 2</span><br></pre></td></tr></table></figure><p><img src="https://blogimages.happyshark.cn/win11启用wsl2/image-20210930203527442.png" alt=""></p></li><li><p>更新一下wsl到最新版</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">wsl --update</span><br><span class="line">wsl --install</span><br></pre></td></tr></table></figure></li><li><p>下载安装docker for windows，启动成功</p><p><img src="https://blogimages.happyshark.cn/win11%E5%90%AF%E7%94%A8wsl2/image-20210930205420308.png" alt="image-20210930205420308"></p></li></ol>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 技术 </tag>
            
            <tag> 虚拟机 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>v2ray搭建+Cloudflare Workers反向代理</title>
      <link href="/2021/09/13/%E4%BD%BF%E7%94%A8Cloudflare%20Workers%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86/"/>
      <url>/2021/09/13/%E4%BD%BF%E7%94%A8Cloudflare%20Workers%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h1 id="v2ray搭建-Cloudflare-Workers反向代理"><a href="#v2ray搭建-Cloudflare-Workers反向代理" class="headerlink" title="v2ray搭建+Cloudflare Workers反向代理"></a>v2ray搭建+Cloudflare Workers反向代理</h1><h2 id="v2ray搭建"><a href="#v2ray搭建" class="headerlink" title="v2ray搭建"></a>v2ray搭建</h2><ul><li><p><a href="https://github.com/wulabing/V2Ray_ws-tls_bash_onekey">https://github.com/wulabing/V2Ray_ws-tls_bash_onekey</a> 脚本</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget -N --no-check-certificate -q -O install.sh &quot;https://raw.githubusercontent.com/wulabing/V2Ray_ws-tls_bash_onekey/master/install.sh&quot; &amp;&amp; chmod +x install.sh &amp;&amp; bash install.sh</span><br></pre></td></tr></table></figure></li><li><p>233boy脚本（好久没更新了感觉不太稳定）</p><p>使用 root 用户输入下面命令安装或卸载</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bash &lt;(curl -s -L https://git.io/v2ray.sh)</span><br></pre></td></tr></table></figure><blockquote><p>如果提示 curl: command not found ，那是因为你的 VPS 没装 Curl<br>ubuntu/debian 系统安装 Curl 方法: <code>apt-get update -y &amp;&amp; apt-get install curl -y</code><br>centos 系统安装 Curl 方法: <code>yum update -y &amp;&amp; yum install curl -y</code><br>安装好 curl 之后就能安装脚本了</p></blockquote><p>备注：安装完成后，输入 <code>v2ray</code> 即可管理 V2Ray</p></li></ul><p><strong>注意</strong>：</p><ul><li>选择wb+tls协议</li><li>反代地址：<a href="https://hitokoto.cn">https://hitokoto.cn</a></li></ul><h2 id="安装锐速BBR-cake"><a href="#安装锐速BBR-cake" class="headerlink" title="安装锐速BBR+cake"></a>安装<del>锐速</del>BBR+cake</h2><p><strong>支持系统：</strong><code>Centos 6+</code>/<code>Debian 7+</code>/<code>Ubuntu 14+</code>，<code>BBR</code>魔改版不支持<code>Debian 8</code>。<br><strong>注意：</strong>该脚本在<code>Vultr</code>各个系统均测试通过，如果期间有出现任何问题，可向原作者反映帮助改善。<br>运行以下命令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">wget -N --no-check-certificate &quot;https://github.com/ylx2016/Linux-NetSpeed/raw/master/tcp.sh&quot; &amp;&amp; chmod +x tcp.sh &amp;&amp; ./tcp.sh</span><br><span class="line"></span><br><span class="line">选择安装bbr原版内核</span><br></pre></td></tr></table></figure><p>或者</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bash &lt;(wget --no-check-certificate -qO- wget https://git.io/Kernel.sh)</span><br></pre></td></tr></table></figure><p>或者</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget -N --no-check-certificate &quot;https://raw.githubusercontent.com/dlxg/Linux-NetSpeed/master/tcp.sh&quot; &amp;&amp; chmod +x tcp.sh &amp;&amp; ./tcp.sh</span><br></pre></td></tr></table></figure><p>激活</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bash &lt;(wget --no-check-certificate -qO-  https://git.io/lotServerInstall.sh) install</span><br></pre></td></tr></table></figure><h2 id="使用说明"><a href="#使用说明" class="headerlink" title="使用说明"></a>使用说明</h2><p>使用脚本后会出现如下选项：<br><img src="https://blogimages.happyshark.cn/v2ray+cf%E5%8F%8D%E4%BB%A3/Snipaste_2020-04-23_00-42-15.png" alt="img"></p><p>根据自己需求操作，重启后再使用<code>./tcp.sh</code>命令接着操作。</p><p>脚本会自动检测安装的情况，请注意脚本菜单下的状态检测即可。</p><p>如果在删除内核环节出现这样一张图，注意选择<code>NO</code>，然后根据提示重启系统。</p><p><a href="https://camo.githubusercontent.com/b047b125b25b3c5d441394e1d891691a209b8dbc/68747470733a2f2f7777772e6d6f65726174732e636f6d2f7573722f706963747572652f7169616e79696e676262722832292e706e67"><img src="https://blogimages.happyshark.cn/v2ray+cf%E5%8F%8D%E4%BB%A3/68747470733a2f2f7777772e6d6f65726174732e636f6d2f7573722f706963747572652f7169616e79696e676262722832292e706e67" alt="img"></a></p><h2 id="使用Cloudflare-Workers反向代理"><a href="#使用Cloudflare-Workers反向代理" class="headerlink" title="使用Cloudflare Workers反向代理"></a>使用Cloudflare Workers反向代理</h2><p>要使用 Cloud­flare 加速梯子，首先梯子必须是用 web­socket 作为传输方式的，比如 v2ray 的 web­socket，gost 的 web­socket 隧道，SS 的 v2-plu­gin 等等，关于这些东西的搭建教程有很多，我就不赘述了，只讲如何使用 Cloud­flare，并自选 ip 来达到最好的加速效果，你所需要的只是一个域名</p><p>先创建一个 Cloud­flare 账号，然后在主页面右下角点击 Work­ers，进入创建一个 Worker</p><p><a href="https://maofun.com/wp-content/uploads/2020/11/20201123233753-2eea3.png"><img src="https://maofun.com/wp-content/uploads/2020/11/20201123233753-2eea3.png" alt="img"></a></p><p>接着在编辑区域粘贴以下代码</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">addEventListener(</span><br><span class="line">    <span class="string">&quot;fetch&quot;</span>, <span class="function"><span class="params">event</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> url = <span class="keyword">new</span> URL(event.request.url);</span><br><span class="line">        url.hostname = <span class="string">&quot;your.domain&quot;</span>;</span><br><span class="line">        url.protocol = <span class="string">&quot;protocol&quot;</span>;</span><br><span class="line">        <span class="keyword">let</span> request = <span class="keyword">new</span> Request(url, event.request);</span><br><span class="line">        event.respondWith(</span><br><span class="line">            fetch(request)</span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>将 <code>your.domain</code> 改成你的域名，<code>protocol</code> 如果后端使用 https 就写 https，http 就写 http，如下图所示</p><p><a href="https://maofun.com/wp-content/uploads/2020/11/20201123233753-6b726.png"><img src="https://maofun.com/wp-content/uploads/2020/11/20201123233753-6b726.png" alt="img"></a></p><p>然后在左上角自定义你的子域</p><p><a href="https://maofun.com/wp-content/uploads/2020/11/20201123233753-be0fe.png"><img src="https://blogimages.happyshark.cn/v2ray+cf%E5%8F%8D%E4%BB%A3/20201123233753-be0fe.png" alt="img"></a></p><p>最后点击保存并部署即可</p><p>在左上角点击访问你的应用，如果出现的是你的网站的内容那说明反代成功了，将 v2ray 的客户端的地址改成 Worker 应用的地址即可，客户端没有开启 tls 的要开启，并将连接端口设为 443</p><p><a href="https://maofun.com/wp-content/uploads/2020/11/20201123233753-dca95.png"><img src="https://blogimages.happyshark.cn/v2ray+cf%E5%8F%8D%E4%BB%A3/20201123233753-dca95.png" alt="img"></a></p><h2 id="自选Cloudflare的ip"><a href="#自选Cloudflare的ip" class="headerlink" title="自选Cloudflare的ip"></a>自选Cloudflare的ip</h2><p>为了实现这一点需要使用这个项目：<a href="https://github.com/Spedoske/CloudflareScanner">https://github.com/Spedoske/CloudflareScanner</a><br>在 Re­lease 页面下载对应平台的二进制运行即可，参数如下，当然你也可以自定义，但记得 tcping 协程数不要超过一千</p><p><a href="https://maofun.com/wp-content/uploads/2020/11/20201123233753-eee3f.png"><img src="https://blogimages.happyshark.cn/v2ray+cf%E5%8F%8D%E4%BB%A3/20201123233753-eee3f.png" alt="img"></a></p><p>在同目录的result.csv文件中就可以看到筛选出的优质ip，一般第一行的ip就可以使用了</p><p>然后修改系统的 hosts 文件加入这一行</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CF的优质ip Worker应用的域名</span><br></pre></td></tr></table></figure><p>这时候重启你的代理软件，应该已经使用到了 CF 的自选 ip 了</p><p>如果你想要在 CF 前再套一个国内中转机，只需要在中转机上将流量转发到筛选出的 CF 优质 ip，端口为 443，然后在代理软件上将地址和端口修改为中转机的地址和端口，host 设置为 Work­ers 应用的域名</p><ul><li>测试 Cloudflare CDN 延迟和速度，获取最快 IP (IPv4+IPv6)！ <a href="https://github.com/XIU2/CloudflareSpeedTest">https://github.com/XIU2/CloudflareSpeedTest</a></li></ul><p>直接运行就能自动延迟测速+下载测速，并列出速度最快的 IP。 当然还有进阶使用方法，自行搭配各种参数来获得更个性化的测速结果！</p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 技术 </tag>
            
            <tag> v2ray </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>travis-ci在Node.js v14.0下自动构建hexo报错</title>
      <link href="/2020/05/22/travis-ci%E5%9C%A8Node.js-v14.0%E4%B8%8B%E8%87%AA%E5%8A%A8%E6%9E%84%E5%BB%BAhexo%E6%8A%A5%E9%94%99/"/>
      <url>/2020/05/22/travis-ci%E5%9C%A8Node.js-v14.0%E4%B8%8B%E8%87%AA%E5%8A%A8%E6%9E%84%E5%BB%BAhexo%E6%8A%A5%E9%94%99/</url>
      
        <content type="html"><![CDATA[<hr><blockquote><p>参考<a href="https://vensing.com/a-bug-in-nodejs-v14/">https://vensing.com/a-bug-in-nodejs-v14/</a></p></blockquote><h1 id="报错情况"><a href="#报错情况" class="headerlink" title="报错情况"></a>报错情况</h1><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">1.27s$ hexo clean</span><br><span class="line">(node:5971) Warning: Accessing non-existent property &#x27;lineno&#x27; of module exports inside circular dependency</span><br><span class="line">(Use `node --trace-warnings ...` to show where the warning was created)</span><br><span class="line">(node:5971) Warning: Accessing non-existent property &#x27;column&#x27; of module exports inside circular dependency</span><br><span class="line">(node:5971) Warning: Accessing non-existent property &#x27;filename&#x27; of module exports inside circular dependency</span><br><span class="line">(node:5971) Warning: Accessing non-existent property &#x27;lineno&#x27; of module exports inside circular dependency</span><br><span class="line">(node:5971) Warning: Accessing non-existent property &#x27;column&#x27; of module exports inside circular dependency</span><br><span class="line">(node:5971) Warning: Accessing non-existent property &#x27;filename&#x27; of module exports inside circular dependency</span><br><span class="line">322The command &quot;hexo clean&quot; exited with 0.</span><br><span class="line">6.83s$ hexo g</span><br><span class="line">(node:5991) Warning: Accessing non-existent property &#x27;lineno&#x27; of module exports inside circular dependency</span><br><span class="line">(Use `node --trace-warnings ...` to show where the warning was created)</span><br><span class="line">(node:5991) Warning: Accessing non-existent property &#x27;column&#x27; of module exports inside circular dependency</span><br><span class="line">(node:5991) Warning: Accessing non-existent property &#x27;filename&#x27; of module exports inside circular dependency</span><br><span class="line">(node:5991) Warning: Accessing non-existent property &#x27;lineno&#x27; of module exports inside circular dependency</span><br><span class="line">(node:5991) Warning: Accessing non-existent property &#x27;column&#x27; of module exports inside circular dependency</span><br><span class="line">(node:5991) Warning: Accessing non-existent property &#x27;filename&#x27; of module exports inside circular dependency</span><br><span class="line">INFO  Start processing</span><br><span class="line">INFO  Files loaded in 3.93 s</span><br><span class="line">(node:5991) Warning: Accessing non-existent property &#x27;lineno&#x27; of module exports inside circular dependency</span><br><span class="line">(node:5991) Warning: Accessing non-existent property &#x27;column&#x27; of module exports inside circular dependency</span><br><span class="line">(node:5991) Warning: Accessing non-existent property &#x27;filename&#x27; of module exports inside circular dependency</span><br><span class="line">(node:5991) Warning: Accessing non-existent property &#x27;lineno&#x27; of module exports inside circular dependency</span><br><span class="line">(node:5991) Warning: Accessing non-existent property &#x27;column&#x27; of module exports inside circular dependency</span><br><span class="line">(node:5991) Warning: Accessing non-existent property &#x27;filename&#x27; of module exports inside circular dependency</span><br></pre></td></tr></table></figure><h1 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h1><p>在travis.yml里面的Node.js版本那里把<strong>stable</strong>改成指定版本号就行，错误已经提交至hexo项目的issue，估计过一段时间就能修复</p><h1 id="附travis-yml中的language用法"><a href="#附travis-yml中的language用法" class="headerlink" title="附travis.yml中的language用法"></a>附travis.yml中的language用法</h1><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">language:</span> <span class="string">node_js</span></span><br><span class="line"><span class="attr">node_js:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="number">7</span></span><br></pre></td></tr></table></figure><p>其中版本号可填如下内容：</p><ul><li><p><code>node</code> latest stable Node.js release</p></li><li><p><code>lts/*</code> latest LTS Node.js release</p></li><li><p><code>14</code> latest 14.x release</p></li><li><p><code>13</code> latest 13.x release</p></li><li><p><code>12</code> latest 12.x release</p></li><li><p><code>11</code> latest 11.x release</p></li><li><p><code>10</code> latest 10.x release</p></li></ul><blockquote><p>参考自<a href="https://docs.travis-ci.com/user/languages/javascript-with-nodejs/">https://docs.travis-ci.com/user/languages/javascript-with-nodejs/</a></p></blockquote><h1 id="吐槽"><a href="#吐槽" class="headerlink" title="吐槽"></a>吐槽</h1><p>有点想换GitHub Actions了…</p>]]></content>
      
      
      <categories>
          
          <category> 博客 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hexo </tag>
            
            <tag> travis CI </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>windows XP安装pyqt5和pyinstaller的坑</title>
      <link href="/2020/03/24/windows-XP%E5%AE%89%E8%A3%85pyqt5%E5%92%8Cpyinstaller%E7%9A%84%E5%9D%91/"/>
      <url>/2020/03/24/windows-XP%E5%AE%89%E8%A3%85pyqt5%E5%92%8Cpyinstaller%E7%9A%84%E5%9D%91/</url>
      
        <content type="html"><![CDATA[<h1 id="xp支持的python和qt版本"><a href="#xp支持的python和qt版本" class="headerlink" title="xp支持的python和qt版本"></a>xp支持的python和qt版本</h1><ul><li><p>Windows xp 不能运行python3.5及以上版本python。</p></li><li><p>Windows xp 不能运行qt5.7及以上版本qt。</p></li><li><p>Pyqt5官方预编译二进制文件不能在xp上运行。</p></li><li><p>Windows xp 能运行的最高版本的python版本为：python3.4和python2.7</p></li><li><p>Windows xp 上能运行的最高版本的qt为qt5.6.3</p></li></ul><h1 id="准备安装包"><a href="#准备安装包" class="headerlink" title="准备安装包"></a>准备安装包</h1><ul><li>windows xp镜像（itellyou.cn）要下载vl版本的</li><li>Python 3.4.4 (官网下载安装程序)</li><li>pip (官网下载get-pip.py文件安装)</li><li>PyQt 5.5.1</li><li>pywin32 220 (221和最新的222没有尝试)</li><li>PyInstaller 3.2.1 (pip install pyinstaller==3.2.1)</li><li>pySrial 3.0.1 (pip install pyserial==3.0.1)</li><li>eric6 ：可以安装17.03.1，Eric6的主程序文件是 $python安装文件夹$\Lib\site-packages\eric6\eric6.pyw</li></ul><p>注1：如果不手动安装pywin32是无法安装PyInstaller的.</p><p>注2：pip install 安装慢的话可以用清华源：<a href="https://mirrors.tuna.tsinghua.edu.cn/help/pypi/">https://mirrors.tuna.tsinghua.edu.cn/help/pypi/</a></p><p>注3：相关安装包下载地址：<a href="https://www.lanzous.com/b015akode">https://www.lanzous.com/b015akode</a> 密码:7zjp</p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> windowsXP </tag>
            
            <tag> pyqt5 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>修改WIFI名称&amp;暴力多拨提升网速</title>
      <link href="/2020/01/20/%E6%9A%B4%E5%8A%9B%E6%8F%90%E5%8D%87%E7%BD%91%E9%80%9F%E2%80%94%E2%80%94%E5%A4%9A%E6%8B%A8/"/>
      <url>/2020/01/20/%E6%9A%B4%E5%8A%9B%E6%8F%90%E5%8D%87%E7%BD%91%E9%80%9F%E2%80%94%E2%80%94%E5%A4%9A%E6%8B%A8/</url>
      
        <content type="html"><![CDATA[<hr><blockquote><p>打开wifi列表全是CMCC-XXXX，找自己家的wifi好麻烦啊，把名字一改岂不美滋滋，另外今天突然发现东站的宽带好像可以多拨，而且一个账号可以在不同地方拨号</p></blockquote><h1 id="可以用来干什么？"><a href="#可以用来干什么？" class="headerlink" title="可以用来干什么？"></a>可以用来干什么？</h1><h2 id="修改wifi名称"><a href="#修改wifi名称" class="headerlink" title="修改wifi名称"></a>修改wifi名称</h2><ul><li>当然是<del>装逼</del>（搜索wifi的时候快速找到自己的家的呀hhh）</li></ul><h2 id="多拨"><a href="#多拨" class="headerlink" title="多拨"></a>多拨</h2><ul><li>如果对网速有要求的话可以通过多拨暴力提升网速，比如200M宽带可以通过双拨变400M，三拨600M，五拨就可以提前体验5G速度了#滑稽</li><li>如果有多间屋子的话就可以只办一个宽带，去哪间屋子就在哪间屋子拨个号就能上网了，省钱大法好</li></ul><h1 id="效果"><a href="#效果" class="headerlink" title="效果"></a>效果</h1><ul><li><p>修改wifi的名称（去掉开头的CMCC+配置中文名）</p><p><img src="https://pptqdq.ch.files.1drv.com/y4mBJZ-mW2qN-3RoSAsYiePZ_-zsIiGgFIaZSDokxG8KsBfJO2MtXxqDO0N8c8HMsKyn5Hqqe-uRuIOhs0hfA307vvA1ZEuuGAhgUx6CkceI7jk2XILRg5zWMaEUkPb24_s4_eXf2pST1aGrNrf7g0kksKPji9DUo5qhZ3obonjjks0n0N4gBiON-L6g7maEqHYR66jWhtqUiJyLhumLtvmdQ?width=371&amp;height=660&amp;cropmode=none" alt=""></p></li><li><p>双路200M宽带双拨</p><p><img src="https://ppqbdg.ch.files.1drv.com/y4mIfCsNxDB6CLQOYWnbz_ZhzI2YYzqdXBg1Tm454FGzFM6PoghY6Y97HgOykrTsEVENTytObilCqtQwoRV1FXs1z1UJTBUP63WXMz7RPM5v-uYPOPeaeR5MQiCaYVB3JNyah6zg_TVqeSufU_iMpO9AJH2eGdxK0sXwcynDlUgGNUIasu8RmE1zqfxqgtgimSuO8C_Exe13bR1qL9Fcj-M5A?width=790&amp;height=395&amp;cropmode=none" alt=""></p><p><img src="https://ppqcdg.ch.files.1drv.com/y4m9MMd6JTL3Z9bm_49dB-fmZbIjxnJCJ7qdF14Q8UPo0_2TD4_gT_ZFunSr_Q67ribivOgpkJSJdqW-idtqkuKJK0IrxCD7VJLTftdrnW0Z6iUUV9D8xROGkQnffOoWAHHOmtmJ171_FIBiaPsixkJy_RzgNijckg_THurGP_ZwdsGkPgX_29DxOWvA3P1kHL8yyEGt2giY5WObViUvX4nGw?width=1071&amp;height=581&amp;cropmode=none" alt=""></p></li></ul><h1 id="配置方法"><a href="#配置方法" class="headerlink" title="配置方法"></a>配置方法</h1><h2 id="修改wifi名字"><a href="#修改wifi名字" class="headerlink" title="修改wifi名字"></a>修改wifi名字</h2><h3 id="所需工具（二选一即可）"><a href="#所需工具（二选一即可）" class="headerlink" title="所需工具（二选一即可）"></a>所需工具（二选一即可）</h3><ul><li>chrome浏览器</li><li>Burp Suite + 任意浏览器</li></ul><h3 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h3><h4 id="单chrome浏览器方法"><a href="#单chrome浏览器方法" class="headerlink" title="单chrome浏览器方法"></a>单chrome浏览器方法</h4><ol><li>连接光猫，登录192.168.1.1后台，超级管理员用户名CMCCAdmin，密码aDm8H%MdA</li><li><p>进入网络-WLAN网络设置</p></li><li><p>按F12，ctrl+shift+F，在search里面搜索gp_ssidPre（或者Frm_ESSID），可以搜到在<strong>4980</strong>行有一行代码</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">setValue(&quot;ESSID&quot;, gp_ssidPre+getValue(&quot;Frm_ESSID&quot;));</span><br></pre></td></tr></table></figure><p><img src="https://ppqedg.ch.files.1drv.com/y4mGT1R2WBo13RDfywEpFkZ-kad16l5cjofSwSx2zCumi1L0-B2ph6dP4pL_KdkHIOQMaXEeh1eY_rHB5Ve51HhYGsq-oI0qoLbYgV8C6yY-WlS8GEBbm8sHj1s7YCzPxonaAiM0NxjJ-sWLw3Sc4JVQfQZ8_VWj6d4vTf_thqbGSVJgwtbGzmjEak_2xNRwBBpoNPYSXqzRoCMDSwONy-K2w?width=1920&amp;height=942&amp;cropmode=none" alt=""></p></li><li><p>在<strong>4981</strong>行（即该行代码的下一行）的数字那里点一下设置断电，会变蓝</p></li><li><p>F5刷新页面</p></li><li><p>先修改SSID名称，然后确定提交</p></li><li><p>页面会中断在4981行</p><p><img src="https://ppqddg.ch.files.1drv.com/y4mHEmuS0gEe_JDnnjiArZ-5KyKWi6P6KeJhdBTVKMCzy3szk1jtt8-mXabBBIKHzIioKeeG93HZkbp-4Hv4x4Vapa9eCf0S-Mj3tZnDWQs_cm0QbyYzR1KnqB5StUtpQHzReY-m43brC4y-JofHRgF6r3lx-DjqhJdZaMPX_h7iCL9BCeVbF7uyq0JF12RoWqw3nsaD8Z1I3NRjBbVHwEPLg?width=1920&amp;height=943&amp;cropmode=none" alt=""></p></li><li><p>进入Console标签，输入以下代码</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">setValue(&quot;ESSID&quot;, getValue(&quot;Frm_ESSID&quot;));</span><br></pre></td></tr></table></figure><p><img src="https://95qcdg.ch.files.1drv.com/y4mBBYKOwQS4zojZt31ATs8kmKWOTVx5gd3p31YZMbZ8U4jR98OZACErLTdQVLTOB0c0oKex-_UVV5O0a8-HqDuKnvvNTJXq5hsioc42X-6-X7Yw6t8f7gXUAHNxu5Bmg95Pl_2Oa1JsJUI6YSaH28n8KEShk_AzzG5EUv1M5wVt9VIRyssxrv7zKBUa_vRX7o3A4p_Ondkg5GZLer0EVTnYA?width=1920&amp;height=938&amp;cropmode=none" alt=""></p><p>为了确认ESSID已经被修改，可以输入ESSID查看修改前后的代码，结果就是已经把cmcc去掉了</p></li><li><p>点页面顶上蓝色的箭头执行断点，提交成功，然后wifi名字就被修改了</p><p><img src="https://95tqdq.ch.files.1drv.com/y4mLowTxTPtn0g5jxT9O9nRvYr9c0haevAuV16o7Ifd22P5qrZjcdNxH8GIVyrml2-A2CSMl1lv7CnUqIt95cCts8Eau4l7d7ukj2I8J9f4kQynKcAaUwpr87v--5uH5ogYSgT_lk5DfnPzFGBgBjV4Qkwaotff4RCWBItqDYVKScvYetc2-qCBYLQam1_3M9KqlkxPRcde9FwptG_j6cwCSw?width=1035&amp;height=185&amp;cropmode=none" alt=""></p><p><img src="https://pptqdq.ch.files.1drv.com/y4mBJZ-mW2qN-3RoSAsYiePZ_-zsIiGgFIaZSDokxG8KsBfJO2MtXxqDO0N8c8HMsKyn5Hqqe-uRuIOhs0hfA307vvA1ZEuuGAhgUx6CkceI7jk2XILRg5zWMaEUkPb24_s4_eXf2pST1aGrNrf7g0kksKPji9DUo5qhZ3obonjjks0n0N4gBiON-L6g7maEqHYR66jWhtqUiJyLhumLtvmdQ?width=371&amp;height=660&amp;cropmode=none" alt=""></p></li></ol><h4 id="Burp-Suite-任意浏览器"><a href="#Burp-Suite-任意浏览器" class="headerlink" title="Burp Suite + 任意浏览器"></a>Burp Suite + 任意浏览器</h4><p>慢更…</p><h2 id="多拨-1"><a href="#多拨-1" class="headerlink" title="多拨"></a>多拨</h2><ul><li><p>实现多拨需要使用自己的路由器（千兆端口）</p></li><li><p>需要将光猫设置为桥接，在路由器里面使用pppoe拨号</p><p><img src="https://95qadg.ch.files.1drv.com/y4mZdqSghJOmPL07KH7WpVou7sqNLIp2W6vANxUznlhug-kI3mvdrQofVcUscNa21WeGe5Lgv0gcC7KosJgC4tN8pNmLC-ml442TDT_LLnyru_LG0F_QKCmpchtXnXqJ7cSZLXDLyBVnWxHgJ_89IZXyerJYaUf2zXlWVKx6f7Sc1QdnyrlimUDAKom4fmjhIvFN7fYZ8vytqApBk9UKTb2Kw?width=937&amp;height=571&amp;cropmode=none" alt=""></p></li><li><p>如果使用多拨的话必须要有路由器固件支持，推荐老毛子&amp;潘多拉固件，内置了多拨的功能。</p></li><li><p>如果是华硕路由器里面内置了双wan，可以直接双拨。（AC66U B1以上型号）</p><p><img src="https://ppqbdg.ch.files.1drv.com/y4mIfCsNxDB6CLQOYWnbz_ZhzI2YYzqdXBg1Tm454FGzFM6PoghY6Y97HgOykrTsEVENTytObilCqtQwoRV1FXs1z1UJTBUP63WXMz7RPM5v-uYPOPeaeR5MQiCaYVB3JNyah6zg_TVqeSufU_iMpO9AJH2eGdxK0sXwcynDlUgGNUIasu8RmE1zqfxqgtgimSuO8C_Exe13bR1qL9Fcj-M5A?width=790&amp;height=395&amp;cropmode=none" alt=""></p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 宽带 </tag>
            
            <tag> 多拨 </tag>
            
            <tag> 提速 </tag>
            
            <tag> wifi </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>hexo博客上线</title>
      <link href="/2019/12/26/hello-world/"/>
      <url>/2019/12/26/hello-world/</url>
      
        <content type="html"><![CDATA[<blockquote><p>博客又双叒叕上线了，这次使用的是hexo + Github Pages + travis CI + 语雀 + serverless + onedrive图床，部署完成之后可以直接在语雀上编辑文章然后自动发布到博客，云端写作不是梦hhh </p></blockquote><h1 id="部署"><a href="#部署" class="headerlink" title="部署"></a>部署</h1><blockquote><p>部署部分是按照博客<a href="https://www.simon96.online/2018/10/12/hexo-tutorial/">https://www.simon96.online/2018/10/12/hexo-tutorial/</a> 配置的，仅做备份之用以便日后博客迁移可以照着这篇文文章重新恢复(ಥ _ ಥ)</p></blockquote><p>本地环境：windows Linux Ubuntu 18.04</p><h2 id="（可选）配置git"><a href="#（可选）配置git" class="headerlink" title="（可选）配置git"></a>（可选）配置git</h2><p>首先我得重新在git设置一下身份的名字和邮箱（因为当初都忘了设置啥了，因为遇到坑了）进入到需要提交的文件夹底下（因为直接打开git Bash，在没有路径的情况下，根本没！法！改！刚使用git时遇到的坑。。。）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git config --global user.name &quot;yourname&quot;</span><br><span class="line">git config --global user.email“your@email.com&quot;</span><br></pre></td></tr></table></figure><p>注：yourname是你要设置的名字，your@email是你要设置的邮箱。</p><h2 id="安装-Node-js和npm"><a href="#安装-Node-js和npm" class="headerlink" title="安装 Node.js和npm"></a>安装 Node.js和npm</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get update</span><br><span class="line">sudo apt-get install nodejs</span><br><span class="line">sudo apt-get install npm</span><br></pre></td></tr></table></figure><p>如果报错,请更改软件源—清华大学开源软件源,并更新</p><p>注：查看nodejs和npm版本号</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">nodejs -v</span><br><span class="line">npm -v</span><br></pre></td></tr></table></figure><p>可以正常打印版本号说明,安装成功</p><h2 id="安装-Hexo"><a href="#安装-Hexo" class="headerlink" title="安装 Hexo"></a>安装 Hexo</h2><ol><li><p>创建博客所在目录</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mkdir hexo </span><br></pre></td></tr></table></figure></li><li><p>创建目录</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mkdir hexo</span><br></pre></td></tr></table></figure></li><li><p>切换目录</p> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cd hexo</span><br></pre></td></tr></table></figure></li><li><p>全局安装 Hexo，需要最高权限，记得输入root密码</p> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo npm install -g hexo-cli</span><br></pre></td></tr></table></figure></li><li><p>初始化 Hexo</p> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo init</span><br></pre></td></tr></table></figure><p> 注：如果报错执行代码,不报错忽略</p> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo npm config set user 0</span><br><span class="line">sudo npm config set unsafe-perm true</span><br><span class="line">sudo npm install -g hexo-cli</span><br></pre></td></tr></table></figure></li></ol><h2 id="安装插件"><a href="#安装插件" class="headerlink" title="安装插件"></a>安装插件</h2><ol><li><p>如果安装慢就安装proxychains，并且定义alias npm=’proxychains4 npm’</p></li><li><p>如果要永久定义（重启不失效的话就编辑：</p> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim ~/.bashrc</span><br></pre></td></tr></table></figure><p>   并且在末尾添加以下代码并定义 alias</p> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">alias npm=&#x27;proxychains4 npm&#x27;</span><br></pre></td></tr></table></figure></li><li><p>配置完代理后就可以安装npm插件了</p> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-renderer-pug hexo-renderer-stylus --save</span><br><span class="line">npm install hexo-generator-index --save</span><br><span class="line">npm install hexo-generator-archive --save</span><br><span class="line">npm install hexo-generator-category --save</span><br><span class="line">npm install hexo-generator-tag --save</span><br><span class="line">npm install hexo-server --save</span><br><span class="line">npm install hexo-deployer-git --save</span><br><span class="line">npm install hexo-deployer-heroku --save</span><br><span class="line">npm install hexo-deployer-rsync --save</span><br><span class="line">npm install hexo-deployer-openshift --save</span><br><span class="line">npm install hexo-renderer-marked --save</span><br><span class="line">npm install hexo-renderer-stylus --save</span><br><span class="line">npm install hexo-generator-feed --save</span><br><span class="line">npm install hexo-generator-sitemap --save</span><br><span class="line">npm install hexo-tag-aplayer --save</span><br><span class="line">npm install aplayer --save</span><br><span class="line">npm i --save hexo-wordcount</span><br><span class="line">npm install aplayer --save</span><br><span class="line">npm install --save hexo-helper-live2d</span><br><span class="line">    </span><br></pre></td></tr></table></figure></li></ol><h2 id="测试安装成功"><a href="#测试安装成功" class="headerlink" title="测试安装成功"></a>测试安装成功</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo g &amp;&amp; hexo server</span><br></pre></td></tr></table></figure><p><img src="https://blogimages.happyshark.cn//hello-world/部署成功.png" alt="本地部署成功"></p><h1 id="同步到githubpages"><a href="#同步到githubpages" class="headerlink" title="同步到githubpages"></a>同步到githubpages</h1><h2 id="方案一：GithubPages"><a href="#方案一：GithubPages" class="headerlink" title="方案一：GithubPages"></a>方案一：GithubPages</h2><ol><li><p>创建<a href="https://github.com/">Github</a>账号</p></li><li><p>创建仓库， 仓库名为：<Github账号名称>.github.io</p></li><li><p>将本地Hexo博客推送到GithubPages</p><ul><li><p>安装hexo-deployer-git插件。在命令行（即Git Bash）运行以下命令即可：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm install hexo-deployer-git --save</span><br></pre></td></tr></table></figure></li><li><p>添加SSH key。</p><p>创建一个 SSH key 。在命令行（即Git Bash）输入以下命令，     回车三下即可：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ssh-keygen -t rsa -C &quot;邮箱地址&quot;  </span><br></pre></td></tr></table></figure></li><li><p>添加到 github。 复制密钥文件内容（路径形如C:\Users\Administrator.ssh\id_rsa.pub），粘贴到<a href="https://github.com/settings/keys">New SSH Key</a>即可。</p></li><li><p>测试是否添加成功。在命令行（即Git     Bash）依次输入以下命令，返回“You’ve successfully authenticated”即成功：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ ssh -T git@github.com  </span><br><span class="line">$ yes  </span><br></pre></td></tr></table></figure></li></ul></li><li><p>修改_config.yml（在站点目录下）。文件末尾修改为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># Deployment  </span><br><span class="line">  ## Docs: https://hexo.io/docs/deployment.html  </span><br><span class="line">  deploy:  </span><br><span class="line">  type: git  </span><br><span class="line">  repo: git@github.com:&lt;Github账号名称&gt;/&lt;Github账号名称&gt;.github.io.git  </span><br><span class="line">  branch: master  </span><br></pre></td></tr></table></figure><p>注意：上面仓库地址写ssh地址，不写http地址。(windows使用git的话建议用https，可以挂代理)</p></li><li><p>推送到GithubPages。在命令行（即Git Bash）依次输入以下命令， 返回INFO Deploy done: git即成功推送：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ hexo g  </span><br><span class="line">$ hexo d  </span><br></pre></td></tr></table></figure></li><li><p>等待1分钟左右，浏览器访问网址：https://<github账号名称>.github.io</p></li></ol><p>至此，的Hexo博客已经搭建在GithubPages, 域名为https://<Github账号名称>.github.io。</p><h2 id="方案二：GithubPages-域名"><a href="#方案二：GithubPages-域名" class="headerlink" title="方案二：GithubPages + 域名"></a>方案二：GithubPages + 域名</h2><p>在方案一的基础上，添加自定义域名（购买的域名）。</p><ol><li><p>域名解析。</p><pre><code>类型选择为 CNAME；主机记录即域名前缀，填写为www；记录值填写为&lt;Github账号名称&gt;.github.io；解析线路，TTL 默认即可。</code></pre></li><li><p>仓库设置。</p><ul><li>打开博客仓库设置：<a href="https://github.com/">https://github.com/</a><Github账号名称>/<Github账号名称>.github.io/settings</li><li>在Custom domain下，填写自定义域名，点击save。</li><li>在站点目录的source文件夹下，创建并打开CNAME.txt，写入你的域名，保存，并重命名为CNAME。 </li></ul></li><li><p>等待10分钟左右。</p><pre><code>浏览器访问自定义域名。至此，Hexo博客已经解析到自定义域名，https://&lt;Github账号名称&gt;.github.io依然可用。</code></pre></li></ol><h1 id="主题，插件配置"><a href="#主题，插件配置" class="headerlink" title="主题，插件配置"></a>主题，插件配置</h1><h2 id="主题"><a href="#主题" class="headerlink" title="主题"></a>主题</h2><p>hexo博客主题用的是<a href="https://github.com/jerryc127/hexo-theme-butterfly">butterfly</a>，配置信息：<a href="https://jerryc.me/posts/21cfbf15/">https://jerryc.me/posts/21cfbf15/</a> ，感谢作者~</p><h2 id="插件"><a href="#插件" class="headerlink" title="插件"></a>插件</h2><blockquote><p>插件部分引自博客<a href="https://www.simon96.online/2018/10/12/hexo-tutorial/">https://www.simon96.online/2018/10/12/hexo-tutorial/</a> ，仅做备份之用以便日后博客迁移可以照着这篇文文章重新恢复(ಥ _ ಥ)</p></blockquote><h3 id="live2d"><a href="#live2d" class="headerlink" title="live2d"></a>live2d</h3><ul><li><p>安装插件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install --save hexo-helper-live2d</span><br></pre></td></tr></table></figure></li><li><p>复制你喜欢的模型名字：</p><p> Epsilon2.1</p><p> <img src="https://blogimages.happyshark.cn/hello-world/20220513103605.png" alt=""></p><p> Gantzert_Felixander</p><p> <img src="https://blogimages.happyshark.cn/hello-world/Gantzert_Felixander.gif" alt="Gantzert_Felixander"></p><p> haru</p><p> <img src="https://blogimages.happyshark.cn/hello-world/haru.gif" alt="haru"></p><p> miku</p><p> <img src="https://blogimages.happyshark.cn/hello-world/miku.gif" alt="miku"></p><p> ni-j</p><p> <img src="https://blogimages.happyshark.cn/hello-world/ni-j.gif" alt="ni-j"></p><p> nico</p><p> <img src="https://blogimages.happyshark.cn/hello-world/nico.gif" alt="nico"></p><p> nietzche</p><p> <img src="https://blogimages.happyshark.cn/hello-world/nietzche.gif" alt="nietzche"></p></li></ul><p>   nipsilon</p><p>   <img src="https://blogimages.happyshark.cn/hello-world/nipsilon.gif" alt="nipsilon"></p><p>   nito</p><p>   <img src="https://blogimages.happyshark.cn/hello-world/nito.gif" alt="nito"></p><p>   shizuku</p><p>   <img src="https://blogimages.happyshark.cn/hello-world/shizuku.gif" alt="shizuku"></p><p>   tsumiki</p><p>   <img src="https://blogimages.happyshark.cn/hello-world/tsumiki.gif" alt="tsumiki"></p><p>   wanko</p><p>   <img src="https://blogimages.happyshark.cn/hello-world/wanko.gif" alt="wanko"></p><p>   z16</p><p>   <img src="https://blogimages.happyshark.cn/hello-world/z16.gif" alt="z16"></p><p>   hibiki</p><p>   <img src="https://blogimages.happyshark.cn/hello-world/hibiki.gif" alt="hibiki"></p><p>   koharu</p><p>   <img src="https://blogimages.happyshark.cn/hello-world/koharu.gif" alt="koharu"></p><p>   haruto</p><p>   <img src="https://blogimages.happyshark.cn/hello-world/koharu.gif" alt=""></p><p>   Unitychan</p><p>   <img src="https://blogimages.happyshark.cn/hello-world/Unitychan.gif" alt="Unitychan"></p><p>   tororo</p><p>   <img src="https://blogimages.happyshark.cn/hello-world/tororo.gif" alt="tororo"></p><p>   hijiki</p><p>   <img src="https://blogimages.happyshark.cn/hello-world/hijiki.gif" alt="hijiki"></p><ul><li><p>将以下代码添加到主题配置文件<code>_config.yml</code>，修改&lt;你喜欢的模型名字&gt;：</p> <figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">live2d:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">scriptFrom:</span> <span class="string">local</span></span><br><span class="line">  <span class="attr">pluginRootPath:</span> <span class="string">live2dw/</span></span><br><span class="line">  <span class="attr">pluginJsPath:</span> <span class="string">lib/</span></span><br><span class="line">  <span class="attr">pluginModelPath:</span> <span class="string">assets/</span></span><br><span class="line">  <span class="attr">tagMode:</span> <span class="literal">false</span></span><br><span class="line">  <span class="attr">log:</span> <span class="literal">false</span></span><br><span class="line">  <span class="attr">model:</span></span><br><span class="line">    <span class="attr">use:</span> <span class="string">live2d-widget-model-hijiki</span></span><br><span class="line">  <span class="attr">display:</span></span><br><span class="line">    <span class="attr">position:</span> <span class="string">right</span></span><br><span class="line">    <span class="attr">width:</span> <span class="number">150</span></span><br><span class="line">    <span class="attr">height:</span> <span class="number">300</span></span><br><span class="line">  <span class="attr">mobile:</span></span><br><span class="line">    <span class="attr">show:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">react:</span></span><br><span class="line">    <span class="attr">opacity:</span> <span class="number">0.7</span></span><br></pre></td></tr></table></figure></li><li><p>建配置文件</p><ul><li><p>在站点目录下建文件夹<code>live2d_models</code>，</p></li><li><p>再在<code>live2d_models</code>下建文件夹<code>&lt;你喜欢的模型名字&gt;</code>,</p></li><li><p>再在<code>&lt;你喜欢的模型名字&gt;</code>下建json文件：&lt;你喜欢的模型名字&gt;.model.json</p></li></ul></li><li><p>安装模型。在命令行（即Git Bash）运行以下命令即可：</p> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install --save live2d-widget-model-hijiki</span><br></pre></td></tr></table></figure></li><li><p>在命令行（即Git Bash）运行以下命令， 在<code>http://127.0.0.1:4000/</code>查看测试结果:</p> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo clean &amp;&amp; hexo g &amp;&amp; hexo s</span><br></pre></td></tr></table></figure></li></ul><h3 id="评论插件（2021年9月12日更新）"><a href="#评论插件（2021年9月12日更新）" class="headerlink" title="评论插件（2021年9月12日更新）"></a>评论插件（2021年9月12日更新）</h3><ul><li>博客评论采用gitalk，配置过程参考<a href="https://github.com/gitalk/gitalk/blob/master/readme-cn.md">https://github.com/gitalk/gitalk/blob/master/readme-cn.md</a></li><li>创建 <strong>GitHub Application</strong>的时候需要注意一下，url填个人博客的完整地址。</li></ul><h1 id="进阶配置"><a href="#进阶配置" class="headerlink" title="进阶配置"></a>进阶配置</h1><h2 id="github-actions自动构建（2021年9月12日更新）"><a href="#github-actions自动构建（2021年9月12日更新）" class="headerlink" title="github actions自动构建（2021年9月12日更新）"></a>github actions自动构建（2021年9月12日更新）</h2><p>由于不经常用语雀（就是懒），再加上travis ci要求构建的库必须是公共库，所以转战github actions。</p><ul><li><p>创建 <code>blog</code> 仓库用来存放 Hexo 项目</p></li><li><p>创建 <code>your.github.io</code> 仓库用来存放静态博客页面</p></li></ul><ol><li><p>生成ssh密钥</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh-keygen -f github-deploy-key</span><br></pre></td></tr></table></figure><p>会生成 <code>github-deploy-key</code> 和 <code>github-deploy-key.pub</code> 两个文件。</p></li><li><p>配置部署密钥</p><p>复制 <code>github-deploy-key</code> 文件内容，在 <code>blog</code> 仓库 <code>Settings -&gt; Secrets -&gt; Add a new secret</code> 页面上添加。</p><ul><li>在 <code>Name</code> 输入框填写 <code>HEXO_DEPLOY_PRI</code>。</li><li>在 <code>Value</code> 输入框填写 <code>github-deploy-key</code> 文件内容。</li></ul><p>复制 <code>github-deploy-key.pub</code> 文件内容，在 <code>your.github.io</code> 仓库 <code>Settings -&gt; Deploy keys -&gt; Add deploy key</code> 页面上添加。</p><ul><li><p>在 <code>Title</code> 输入框填写 <code>HEXO_DEPLOY_PUB</code>。</p></li><li><p>在 <code>Key</code> 输入框填写 <code>github-deploy-key.pub</code> 文件内容。</p></li><li><p>勾选 <code>Allow write access</code> 选项。</p></li></ul></li><li><p>编写 Github Actions</p><p><strong>Workflow 模版</strong></p><p>3.1 在 <code>blog</code> 仓库根目录下创建 <code>.github/workflows/deploy.yml</code> 文件，目录结构如下。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">blog (repository)</span><br><span class="line">└── .github</span><br><span class="line">    └── workflows</span><br><span class="line">        └── deploy.yml</span><br></pre></td></tr></table></figure><p>3.2 </p><p>在 <code>deploy.yml</code> 文件中粘贴以下内容。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line">name: CI</span><br><span class="line"></span><br><span class="line">on:</span><br><span class="line">  push:</span><br><span class="line">    branches:</span><br><span class="line">      - master</span><br><span class="line"></span><br><span class="line">env:</span><br><span class="line">  GIT_USER: HPShark</span><br><span class="line">  GIT_EMAIL: www.yaoyuchao@qq.com</span><br><span class="line">  THEME_REPO: HPShark/happyshark</span><br><span class="line">  THEME_BRANCH: master</span><br><span class="line">  DEPLOY_REPO: HPShark/HPShark.github.io</span><br><span class="line">  DEPLOY_BRANCH: master</span><br><span class="line"></span><br><span class="line">jobs:</span><br><span class="line">  build:</span><br><span class="line">    name: Build on node $&#123;&#123; matrix.node_version &#125;&#125; and $&#123;&#123; matrix.os &#125;&#125;</span><br><span class="line">    runs-on: ubuntu-latest</span><br><span class="line">    strategy:</span><br><span class="line">      matrix:</span><br><span class="line">        os: [ubuntu-latest]</span><br><span class="line">        node_version: [14.x]</span><br><span class="line"></span><br><span class="line">    steps:</span><br><span class="line">      - name: Checkout</span><br><span class="line">        uses: actions/checkout@v2</span><br><span class="line"></span><br><span class="line">      - name: Checkout theme repo</span><br><span class="line">        uses: actions/checkout@v2</span><br><span class="line">        with:</span><br><span class="line">          repository: $&#123;&#123; env.THEME_REPO &#125;&#125;</span><br><span class="line">          ref: $&#123;&#123; env.THEME_BRANCH &#125;&#125;</span><br><span class="line">          path: themes/concise</span><br><span class="line"></span><br><span class="line">      - name: Checkout deploy repo</span><br><span class="line">        uses: actions/checkout@v2</span><br><span class="line">        with:</span><br><span class="line">          repository: $&#123;&#123; env.DEPLOY_REPO &#125;&#125;</span><br><span class="line">          ref: $&#123;&#123; env.DEPLOY_BRANCH &#125;&#125;</span><br><span class="line">          path: .deploy_git</span><br><span class="line"></span><br><span class="line">      - name: Use Node.js $&#123;&#123; matrix.node_version &#125;&#125;</span><br><span class="line">        uses: actions/setup-node@v1</span><br><span class="line">        with:</span><br><span class="line">          node-version: $&#123;&#123; matrix.node_version &#125;&#125;</span><br><span class="line"></span><br><span class="line">      - name: Configuration environment</span><br><span class="line">        env:</span><br><span class="line">          HEXO_DEPLOY_PRI: $&#123;&#123;secrets.HEXO_DEPLOY_PRI&#125;&#125;</span><br><span class="line">        run: |</span><br><span class="line">          sudo timedatectl set-timezone &quot;Asia/Shanghai&quot;</span><br><span class="line">          mkdir -p ~/.ssh/</span><br><span class="line">          echo &quot;$HEXO_DEPLOY_PRI&quot; &gt; ~/.ssh/id_rsa</span><br><span class="line">          chmod 600 ~/.ssh/id_rsa</span><br><span class="line">          ssh-keyscan github.com &gt;&gt; ~/.ssh/known_hosts</span><br><span class="line">          git config --global user.name $GIT_USER</span><br><span class="line">          git config --global user.email $GIT_EMAIL</span><br><span class="line"></span><br><span class="line">      - name: Install dependencies</span><br><span class="line">        run: |</span><br><span class="line">          npm install</span><br><span class="line"></span><br><span class="line">      - name: Deploy hexo</span><br><span class="line">        run: |</span><br><span class="line">          npm run deploy</span><br></pre></td></tr></table></figure><p><code>name</code> 是当前 Action 的名字，最后你可以在仓库的 Actions 菜单项中看到它。<br><code>on</code>是此 Action 触发条件，当满足条件时会触发此任务，上面的 on.push.branches.source-<code>action</code> 是指当 source-action 分支收到 push 后会触发 Action 执行任务。<br><code>env</code>为环境变量对象</p><ul><li><p><code>env.GIT_USER</code>为 Hexo 编译后使用此 git 用户部署到仓库</p></li><li><p><code>env.GIT_EMAIL</code> 为 Hexo 编译后使用此 git 邮箱部署到仓库</p></li><li><code>env.THEME_REPO</code> 为 Hexo 所使用的主题的仓库，这里为 vensing/Kratos-Rebirth</li><li><code>env.THEME_BRANCH</code> 为 Hexo 所使用的主题仓库的版本，可以是：branch、tag 或者 SHA</li><li><code>env.DEPLOY_REPO</code>为 Hexo 编译后要部署的仓库，例如：vensing/vensing.github.io</li><li><code>env.DEPLOY_BRANCH</code> 为 Hexo 编译后要部署到的分支，例如：master</li></ul><p><code>jobs</code> 为此 Action 下的任务列表</p><ul><li><code>jobs.&#123;job&#125;.name</code> 任务名称</li><li><code>jobs.&#123;job&#125;.runs-on</code>任务所需容器，可选值：ubuntu-latest、windows-latest、macos-latest。</li><li><code>jobs.&#123;job&#125;.strategy</code> 策略下可以写 array 格式，此 job 会遍历此数组执行。</li><li><p><code>jobs.&#123;job&#125;.steps</code> 一个步骤数组，可以把所要干的事分步骤放到这里。</p><ul><li><p><code>jobs.&#123;job&#125;.steps.$.name</code> 步骤名，编译时会会以 LOG 形式输出。</p></li><li><p><code>jobs.&#123;job&#125;.steps.$.uses</code>所要调用的 Action，可以到 <a href="https://github.com/actions">https://github.com/actions</a> 查看更多。</p></li><li><p><code>jobs.&#123;job&#125;.steps.$.with</code>一个对象，调用 Action 传的参数，具体可以查看所使用 Action 的说明。</p></li></ul></li></ul><p>在上面配置文件中的代码段，指定了 Action 依赖的 OS 实例为 ubuntu-latest，以及 node 运行环境版本为 14.x，任务 steps 中引用了一个 版本为 v2 的 Action checkout ，actions/checkout@v2 的作用是 Checkout 一个 git 仓库到当前 ubuntu 容器。</p><ul><li>Checkout theme repo step 中从环境变量中拿出 $ 指定本站使用的博客仓库名及分支 hexo5-custom，检出到 themes/Kratos-Rebirth 目录下。</li><li>Checkout deploy repo step 中从环境变量中拿出 $ 指定部署备份的博客仓库，及要部署备份生成的静态网页的分支 master，检出到 .deploy_git 目录下。</li><li>Use Node.js step 中使用了 actions/setup-node@v1 action 指定了 node 的版本。</li></ul><p>检出主题分支和 Github Pages 部署分支之后，接着配置执行环境：</p><ul><li>设置容器的时区；</li><li>将在 Settings -&gt; Secrets 中的 SSH 私钥写入到 ~/.ssh/id_rsa 文件中；</li><li>设置 id_rsa 的文件权限及 know_hosts、git 全局用户信息</li></ul><p>接着执行 npm install 安装依赖和 npm run deploy 部署到 Github Pages 进行备份。run: | 可分行连续执行多条命令，需要注意的是使用 hexo 的 deploy 命令需要我们安装 hexo-deployer-git 依赖，所以需要先在本地安装下依赖写入 package.json 中。</p></li><li><p>执行任务</p><p>写一篇文章，<code>push</code> 到 <code>blog</code> 仓库的 <code>master</code> 分支，在此仓库 <code>Actions</code> 页面查看当前 task。</p></li></ol><h2 id="语雀云端写作-腾讯云serverless提交-Travis-ci自动构建-github-pages发布"><a href="#语雀云端写作-腾讯云serverless提交-Travis-ci自动构建-github-pages发布" class="headerlink" title="语雀云端写作+腾讯云serverless提交+ Travis-ci自动构建+github-pages发布"></a><del>语雀云端写作+腾讯云serverless提交+ Travis-ci自动构建+github-pages发布</del></h2><blockquote><p>目前博客使用github action发布，好处是源代码仓库可以设为<code>私有</code>,而travis-ci构建的代码仓库必须是公开，所以这一部分的配置已经废弃~</p><p>实现语雀云端协作部分引自博客<a href="https://www.itfanr.cc/2017/08/09/using-travis-ci-automatic-deploy-hexo-blogs/">https://www.itfanr.cc/2017/08/09/using-travis-ci-automatic-deploy-hexo-blogs/</a> 以及<a href="https://aqpcet.coding.me/%E8%AF%AD%E9%9B%80+TravisCI+Serverless/3689364350.html">https://aqpcet.coding.me/%E8%AF%AD%E9%9B%80+TravisCI+Serverless/3689364350.html</a> ，仅做备份之用以便日后博客迁移可以照着这篇文文章重新恢复(ಥ _ ಥ)</p></blockquote><ul><li><p>语雀</p><p><a href="https://yuque.com/">语雀</a>是阿里巴巴旗下的专业云端知识库，支持<a href="https://baike.baidu.com/item/markdown/3245829?fr=aladdin">Markdown</a>语法，个人和团队皆可用于文档编写。它不仅仅是一个在线编写文档的工具，还集成了<a href="https://www.yuque.com/yuque/developer/doc-webhook">Web Hook</a> ，为自动化部署Hexo建立了基础。而<a href="https://github.com/x-cold/yuque-hexo">yuque-hexo</a>是<a href="https://github.com/x-cold">x-cold</a>根据语雀的API为Hexo博客写的插件，可以很方便的将语雀指定知识库里的文章全部更新到hexo博客中。</p></li></ul><ul><li><p>Travis CI</p><p><a href="https://travis-ci.com/">Travis CI</a>可以很方便地将<a href="https://github.com/">GitHub</a>的项目持续集成并构建。</p></li></ul><ul><li><p>Serverless</p><p><a href="https://cloud.tencent.com/developer/article/1200169">Serverless</a>可以通过代码唤起Travis CI执行构建项目。</p></li></ul><p>自动部署总体流程如下。</p><p><img src="https://blogimages.happyshark.cn//hello-world/部署流程.png" alt="图片来自aqpcet.coding.me"></p><h3 id="关键文件："><a href="#关键文件：" class="headerlink" title="关键文件："></a>关键文件：</h3><ul><li><p>.travis.yml：（参考自<a href="https://www.itfanr.cc/2017/08/09/using-travis-ci-automatic-deploy-hexo-blogs/">IT范儿</a>）</p><p>如果使用这两个问卷配置travis-ci的话，travis-ci.com上仓库的设置里面环境变量只需要设置Travis_Token，变量值为github上取得的Token（DISPLAY VALUE IN BUILD LOG一定要关上！）</p></li></ul><p>  <strong>20200324更新：语雀会对频繁调用的请求进行限流，故需要将语雀token加入到该文件中。${YUQUE_TOKEN}即为语雀token，为保证安全故将token值加进travic网站中而不保存在文件中，添加方法与Travis_Token添加方法相同</strong></p>  <figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">language:</span> <span class="string">node_js</span> <span class="comment"># 设置语言</span></span><br><span class="line"><span class="attr">node_js:</span> <span class="string">stable</span> <span class="comment"># 设置相应版本</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># cache:</span></span><br><span class="line"><span class="comment">#     apt: true</span></span><br><span class="line"><span class="comment">#     directories:</span></span><br><span class="line"><span class="comment">#         - node_modules # 缓存不经常更改的内容</span></span><br><span class="line"></span><br><span class="line"><span class="attr">notifications:</span></span><br><span class="line">    <span class="attr">email:</span></span><br><span class="line">        <span class="attr">recipients:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">happyshark520@outlook.com</span></span><br><span class="line">        <span class="attr">on_success:</span> <span class="string">change</span></span><br><span class="line">        <span class="attr">on_failure:</span> <span class="string">always</span></span><br><span class="line"></span><br><span class="line"><span class="attr">before_install:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">export</span> <span class="string">TZ=&#x27;Asia/Shanghai&#x27;</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">npm</span> <span class="string">install</span> <span class="string">hexo-cli</span> <span class="string">-g</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">npm</span> <span class="string">install</span> <span class="string">cheerio</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">chmod</span> <span class="string">+x</span> <span class="string">./publish-to-gh-pages.sh</span></span><br><span class="line"></span><br><span class="line"><span class="attr">install:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">npm</span> <span class="string">install</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">npm</span> <span class="string">i</span> <span class="string">-g</span> <span class="string">yuque-hexo</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">npm</span> <span class="string">install</span> <span class="string">hexo-deployer-git</span> <span class="string">--save</span></span><br><span class="line"></span><br><span class="line"><span class="attr">script:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">yuque-hexo</span> <span class="string">clean</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">YUQUE_TOKEN=$&#123;YUQUE_TOKEN&#125;</span> <span class="string">yuque-hexo</span> <span class="string">sync</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">npm</span> <span class="string">run</span> <span class="string">sync</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">hexo</span> <span class="string">clean</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">hexo</span> <span class="string">g</span></span><br><span class="line"></span><br><span class="line"><span class="attr">after_script:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">./publish-to-gh-pages.sh</span></span><br><span class="line"></span><br><span class="line"><span class="attr">branches:</span></span><br><span class="line">    <span class="attr">only:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">master</span> <span class="comment">#只监测hexo分支，hexo是我的分支的名称，可根据自己情况设置</span></span><br><span class="line"><span class="attr">env:</span></span><br><span class="line">    <span class="attr">global:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">GH_REF:</span> <span class="string">github.com/HPShark/HPShark.github.io.git</span> <span class="comment">#设置GH_REF，注意更改yourname</span></span><br></pre></td></tr></table></figure><ul><li><p>publish-to-gh-pages.sh：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">#!/bin/bash</span><br><span class="line"></span><br><span class="line">set -ev</span><br><span class="line">git clone https://$&#123;GH_REF&#125; .deploy_git</span><br><span class="line">cd .deploy_git</span><br><span class="line">git checkout master</span><br><span class="line">cd ../</span><br><span class="line">mv .deploy_git/.git/ ./public/</span><br><span class="line">cd ./public</span><br><span class="line">git config user.name &quot;HPShark&quot; # 修改name</span><br><span class="line">git config user.email &quot;&lt;github登录邮箱&gt;&quot; # 修改email</span><br><span class="line"># add commit timestamp</span><br><span class="line">git add .</span><br><span class="line">git commit -m &quot;Travis CI Auto Builder at `date +&quot;%Y-%m-%d %H:%M&quot;`&quot;</span><br><span class="line">git push --force --quiet &quot;https://$&#123;Travis_Token&#125;@$&#123;GH_REF&#125;&quot; master:master</span><br></pre></td></tr></table></figure></li><li><p>腾讯云serverless函数配置，因为travis-ci.org的网址换成了travis-ci.com，所以要对网上的一些老版本的函数内容中的api部分进行修改，然后再加上token和repos即可</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">main_handler</span>(<span class="params"><span class="variable">$event</span>, <span class="variable">$context</span></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 解析语雀post的数据</span></span><br><span class="line">    <span class="variable">$update_title</span> = <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">    <span class="keyword">if</span>(<span class="variable">$event</span>-&gt;body)&#123;</span><br><span class="line">        <span class="variable">$yuque_data</span>= json_decode(<span class="variable">$event</span>-&gt;body);</span><br><span class="line">        <span class="variable">$update_title</span> .= <span class="variable">$yuque_data</span>-&gt;data-&gt;title;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// default params</span></span><br><span class="line">    <span class="variable">$repos</span> = <span class="string">&#x27;&#x27;</span>;  <span class="comment">// 用户名%2F源码仓库名，斜杠用%2F代替</span></span><br><span class="line">    <span class="variable">$token</span> = <span class="string">&#x27;&#x27;</span>; <span class="comment">// 你的登录token</span></span><br><span class="line">    <span class="variable">$message</span> = date(<span class="string">&quot;Y/m/d&quot;</span>).<span class="string">&#x27;:yuque update:&#x27;</span>.<span class="variable">$update_title</span>;</span><br><span class="line">    <span class="variable">$branch</span> = <span class="string">&#x27;master&#x27;</span>;</span><br><span class="line">    <span class="comment">// post params</span></span><br><span class="line">    <span class="variable">$queryString</span> = <span class="variable">$event</span>-&gt;queryString;</span><br><span class="line">    <span class="variable">$q_token</span> = <span class="variable">$queryString</span>-&gt;token ? <span class="variable">$queryString</span>-&gt;token : <span class="variable">$token</span>;</span><br><span class="line">    <span class="variable">$q_repos</span> = <span class="variable">$queryString</span>-&gt;repos ? <span class="variable">$queryString</span>-&gt;repos : <span class="variable">$repos</span>;</span><br><span class="line">    <span class="variable">$q_message</span> = <span class="variable">$queryString</span>-&gt;message ? <span class="variable">$queryString</span>-&gt;message : <span class="variable">$message</span>;</span><br><span class="line">    <span class="variable">$q_branch</span> = <span class="variable">$queryString</span>-&gt;branch ? <span class="variable">$queryString</span>-&gt;branch : <span class="string">&#x27;master&#x27;</span>;</span><br><span class="line">    <span class="keyword">echo</span>(<span class="variable">$q_token</span>);</span><br><span class="line">    <span class="keyword">echo</span>(<span class="string">&#x27;===&#x27;</span>);</span><br><span class="line">    <span class="keyword">echo</span> (<span class="variable">$q_repos</span>);</span><br><span class="line">    <span class="keyword">echo</span> (<span class="string">&#x27;===&#x27;</span>);</span><br><span class="line">    <span class="keyword">echo</span> (<span class="variable">$q_message</span>);</span><br><span class="line">    <span class="keyword">echo</span> (<span class="string">&#x27;===&#x27;</span>);</span><br><span class="line">    <span class="keyword">echo</span> (<span class="variable">$q_branch</span>);</span><br><span class="line">    <span class="keyword">echo</span> (<span class="string">&#x27;===&#x27;</span>);</span><br><span class="line">    <span class="comment">//request travis ci</span></span><br><span class="line">    <span class="variable">$res_info</span> = triggerTravisCI(<span class="variable">$q_repos</span>, <span class="variable">$q_token</span>, <span class="variable">$q_message</span>, <span class="variable">$q_branch</span>);</span><br><span class="line"></span><br><span class="line">    <span class="variable">$res_code</span> = <span class="number">0</span>;</span><br><span class="line">    <span class="variable">$res_message</span> = <span class="string">&#x27;未知&#x27;</span>;</span><br><span class="line">    <span class="keyword">if</span>(<span class="variable">$res_info</span>[<span class="string">&#x27;http_code&#x27;</span>])&#123;</span><br><span class="line">        <span class="variable">$res_code</span> = <span class="variable">$res_info</span>[<span class="string">&#x27;http_code&#x27;</span>];</span><br><span class="line">        <span class="keyword">switch</span>(<span class="variable">$res_info</span>[<span class="string">&#x27;http_code&#x27;</span>])&#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">200</span>:</span><br><span class="line">            <span class="keyword">case</span> <span class="number">202</span>:</span><br><span class="line">                <span class="variable">$res_message</span> = <span class="string">&#x27;success&#x27;</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="variable">$res_message</span> = <span class="string">&#x27;faild&#x27;</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="variable">$res</span> = <span class="keyword">array</span>(</span><br><span class="line">        <span class="string">&#x27;status&#x27;</span>=&gt;<span class="variable">$res_code</span>,</span><br><span class="line">        <span class="string">&#x27;message&#x27;</span>=&gt;<span class="variable">$res_message</span></span><br><span class="line">    );</span><br><span class="line">    <span class="keyword">return</span> <span class="variable">$res</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* <span class="doctag">@description</span>  travis api , trigger a build</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> $repos string 仓库ID、slug</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> $token string 登录验证token</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> $message string 触发信息</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> $branch string 分支</span></span><br><span class="line"><span class="comment">* <span class="doctag">@return</span> $info array 回包信息</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">triggerTravisCI</span> (<span class="params"><span class="variable">$repos</span>, <span class="variable">$token</span>, <span class="variable">$message</span>=<span class="string">&#x27;yuque update&#x27;</span>, <span class="variable">$branch</span>=<span class="string">&#x27;master&#x27;</span></span>) </span>&#123;</span><br><span class="line">    <span class="comment">//初始化</span></span><br><span class="line">    <span class="variable">$curl</span> = curl_init();</span><br><span class="line">    <span class="comment">//设置抓取的url</span></span><br><span class="line">    curl_setopt(<span class="variable">$curl</span>, CURLOPT_URL, <span class="string">&#x27;https://api.travis-ci.com/repo/&#x27;</span>.<span class="variable">$repos</span>.<span class="string">&#x27;/requests&#x27;</span>);</span><br><span class="line">    <span class="comment">//设置获取的信息以文件流的形式返回，而不是直接输出。</span></span><br><span class="line">    curl_setopt(<span class="variable">$curl</span>, CURLOPT_RETURNTRANSFER, <span class="number">1</span>);</span><br><span class="line">    <span class="comment">//设置post方式提交</span></span><br><span class="line">    curl_setopt(<span class="variable">$curl</span>, CURLOPT_CUSTOMREQUEST, <span class="string">&quot;POST&quot;</span>);</span><br><span class="line">    <span class="comment">//设置post数据</span></span><br><span class="line">    <span class="variable">$post_data</span> = json_encode(<span class="keyword">array</span>(</span><br><span class="line">        <span class="string">&quot;request&quot;</span>=&gt; <span class="keyword">array</span>(</span><br><span class="line">            <span class="string">&quot;message&quot;</span>=&gt;<span class="variable">$message</span>,</span><br><span class="line">            <span class="string">&quot;branch&quot;</span>=&gt;<span class="variable">$branch</span></span><br><span class="line">        )</span><br><span class="line">    ));</span><br><span class="line">    <span class="variable">$header</span> = <span class="keyword">array</span>(</span><br><span class="line">      <span class="string">&#x27;Content-Type: application/json&#x27;</span>,</span><br><span class="line">      <span class="string">&#x27;Travis-API-Version: 3&#x27;</span>,</span><br><span class="line">      <span class="string">&#x27;Authorization:token &#x27;</span>.<span class="variable">$token</span>,</span><br><span class="line">      <span class="string">&#x27;Content-Length:&#x27;</span> . strlen(<span class="variable">$post_data</span>)</span><br><span class="line">    );</span><br><span class="line">    curl_setopt(<span class="variable">$curl</span>, CURLOPT_HTTPHEADER, <span class="variable">$header</span>);</span><br><span class="line">    curl_setopt(<span class="variable">$curl</span>, CURLOPT_POSTFIELDS, <span class="variable">$post_data</span>);</span><br><span class="line">    <span class="comment">//执行命令</span></span><br><span class="line">    <span class="variable">$data</span> = curl_exec(<span class="variable">$curl</span>);</span><br><span class="line">    <span class="variable">$info</span> = curl_getinfo(<span class="variable">$curl</span>);</span><br><span class="line">    <span class="comment">//关闭URL请求</span></span><br><span class="line">    curl_close(<span class="variable">$curl</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="variable">$info</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="部署过程"><a href="#部署过程" class="headerlink" title="部署过程"></a>部署过程</h3><ol><li><p>源码上传至github</p><ul><li>建一个新的仓库，专门存放源代码（也可以直接在github.io 的那个仓库新建一个分支，不过设置麻烦，就放弃了）</li><li>将本地代码上传（可能有信息安全风险，所以建议为博客单独开设一个帐号）。注意仓库要设为公开，travis-ci构建私人仓库是要付费的orz..</li></ul><p>注意事项：</p><ul><li><p>上传前建议先执行hexo clean，可以减少上传体积。</p></li><li><p>也可以通过配置.gitignore控制上传内容</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">.DS_Store</span><br><span class="line">Thumbs.db</span><br><span class="line">db.json</span><br><span class="line">*.log</span><br><span class="line">node_modules/</span><br><span class="line">public/</span><br><span class="line">.deploy*/</span><br></pre></td></tr></table></figure></li></ul></li></ol><ol><li><p>配置travis-ci</p><ul><li><p>把.travis.yml和publish-to-gh-pages.sh放在根目录</p><ul><li><p>登录<a href="https://travis-ci.com/">travis-ci</a>，绑定github，允许访问github仓库，进入<strong>博客源码</strong>仓库</p><p><img src="https://blogimages.happyshark.cn//hello-world/travis设置.png" alt=""></p></li><li><p>设置Environment Variables(环境变量)，设置Travis_Token，YUQUE_TOKEN添加方法类似</p><p><img src="https://blogimages.happyshark.cn//hello-world/travis的token设置.png" alt=""></p></li><li><p>配置完成后等待腾讯云serverless触发即可构建，构建成功会return 0，如果有其他问题（一般是缺环境）缺啥在.travis.yml中的install那里npm装包即可~</p></li></ul></li></ul></li></ol><ol><li><p>腾讯云serverless函数配置：</p><ul><li><p>新建php空白函数：（可以用python，aqpcet.coding.me用的就是python设置的）</p><p><img src="https://blogimages.happyshark.cn//hello-world/serverless新建plp文件.png" alt=""></p></li><li><p>编辑serverless函数内容，需要获取以下两个信息，填入对应的地方就行</p><ul><li><p>travis登录token，在travis-ci.com中设置界面获取：</p><p><img src="https://blogimages.happyshark.cn//hello-world/travis登录token.png" alt=""></p></li><li><p>博客源码的仓库名</p><p>现在可以直接用\<github用户名>%2F&lt;博客源码仓库名&gt;代替原来的仓库id了，不用在拿抓包工具抓仓库ID 或 扩展名了</p></li></ul></li><li><p>配置触发方式</p><p><img src="https://blogimages.happyshark.cn//hello-world/serverless设置触发方式.png" alt=""></p><p>一般会得到这么个api：<a href="https://service-s08f6nvk-1251833201.ap-guangzhou.apigateway.myqcloud.com/release/xxx">https://service-s08f6nvk-1251833201.ap-guangzhou.apigateway.myqcloud.com/release/xxx</a></p></li></ul></li><li><p>语雀配置：</p><p>配置一个仓库的webhook:</p><p><img src="https://blogimages.happyshark.cn//hello-world/语雀配置.png" alt=""></p><p>可以选择所有更新触发或者主动触发，主动触发的意思即发布需要勾选一个选项才会触发webhook。具体可参见语雀文档：<a href="https://www.yuque.com/yuque/developer/doc-webhook；">https://www.yuque.com/yuque/developer/doc-webhook；</a><br>将serverless生成的api填入,可以在链接后面带参数：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">token 登录token</span><br><span class="line">repos 仓库id</span><br><span class="line">message 提交信息</span><br><span class="line">branch 分支</span><br><span class="line"></span><br><span class="line">示例：</span><br><span class="line">https://service-s08f6nvk-1251833201.ap-guangzhou.apigateway.myqcloud.com/release/xxx?repos=xxx&amp;token=xxx&amp;message=xxx&amp;branch=xxx</span><br></pre></td></tr></table></figure><p>如果不在链接带参数则写在serverless函数内。</p></li></ol><h3 id="通过语雀插件对front-matter进行处理"><a href="#通过语雀插件对front-matter进行处理" class="headerlink" title="通过语雀插件对front-matter进行处理"></a>通过语雀插件对front-matter进行处理</h3><p>插件地址：<a href="https://github.com/x-cold/yuque-hexo">https://github.com/x-cold/yuque-hexo</a></p><p>需要对package.json，.travis.yml进行配置，在编辑语雀文章时头部要这么写：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">tags: [hexo, node]</span><br><span class="line">categories: fe</span><br><span class="line">cover: https://cdn.nlark.com/yuque/0/2019/jpeg/155457/1546857679810-d82e3d46-e960-419c-a715-0a82c48a2fd6.jpeg#align=left&amp;display=inline&amp;height=225&amp;name=image.jpeg&amp;originHeight=225&amp;originWidth=225&amp;size=6267&amp;width=225</span><br><span class="line"></span><br><span class="line">---</span><br><span class="line"></span><br><span class="line">some description</span><br><span class="line"></span><br><span class="line">&lt;!-- more --&gt;</span><br><span class="line"></span><br><span class="line">more detail</span><br></pre></td></tr></table></figure><p>注：冒号后面是<strong>空格</strong>！tags后面必须有中<strong>括号</strong>！有时候同步完之后空格会变成tab造成front-matter无法被插件识别，就会出现front-matter重叠的情况<a href="https://github.com/x-cold/yuque-hexo/issues/45">issues#45</a></p><p><strong>大功告成！在语雀上正常发布一篇文章即可自动触发serverless函数提交给travis-ci构建博客</strong></p><h1 id="一些坑"><a href="#一些坑" class="headerlink" title="一些坑"></a>一些坑</h1><h2 id="serverless-python版"><a href="#serverless-python版" class="headerlink" title="serverless python版"></a>serverless python版</h2><p><img src="https://blogimages.happyshark.cn//hello-world/serverlesspython版.png" alt=""></p><h2 id="私人图床：onedrive"><a href="#私人图床：onedrive" class="headerlink" title="私人图床：onedrive"></a>私人图床：onedrive</h2><p>使用方法非常简单，具体步骤如下：</p><ul><li><p>注册账户，已有的可直接略过。</p></li><li><p>登录OneDrive，上传需要外链的图片。</p></li><li><p>在图片上右键选择“嵌入”按钮，再在弹出的窗口中点击“生成”选项。</p></li><li><p>将链接复制到需要展示的地方。</p></li></ul><p>来自 <a href="https://osk.ink/archives/12/">https://osk.ink/archives/12/</a> </p><h2 id="travis渲染时报错："><a href="#travis渲染时报错：" class="headerlink" title="travis渲染时报错："></a>travis渲染时报错：</h2><blockquote><p>travis /bin/bash^M: bad interpreter: No such file or directory</p><p>If you use <strong>Sublime Text</strong> on Windows or Mac to edit your scripts:</p><p>Click on View &gt; Line Endings &gt; Unix and <strong>save</strong> the file again.</p></blockquote><p>原因：编码问题，如下解决即可</p><p><img src="https://blogimages.happyshark.cn//hello-world/travis编码报错解决.png" alt=""></p><h2 id="Ubuntu安装Proxychains"><a href="#Ubuntu安装Proxychains" class="headerlink" title="Ubuntu安装Proxychains"></a>Ubuntu安装Proxychains</h2><p>Proxychains是Linux上一款全局代理工具，通过Hook Socket函数实现透明代理，这和Windows上的Proxifier有点类似。 在Ubuntu上安装Proxychains的方法是：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">apt-get install proxychains </span><br></pre></td></tr></table></figure><p>安装的是3.1版本，配置文件的路径是：/etc/proxychains.conf，内容如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"># proxychains.conf  VER 3.1</span><br><span class="line">#</span><br><span class="line">#        HTTP, SOCKS4, SOCKS5 tunneling proxifier with DNS.</span><br><span class="line">#</span><br><span class="line"># The option below identifies how the ProxyList is treated.</span><br><span class="line"># only one option should be uncommented at time,</span><br><span class="line"># otherwise the last appearing option will be accepted</span><br><span class="line">#</span><br><span class="line">#dynamic_chain</span><br><span class="line">#</span><br><span class="line"># Dynamic - Each connection will be done via chained proxies</span><br><span class="line"># all proxies chained in the order as they appear in the list</span><br><span class="line"># at least one proxy must be online to play in chain</span><br><span class="line"># (dead proxies are skipped)</span><br><span class="line"># otherwise EINTR is returned to the app</span><br><span class="line">#</span><br><span class="line">strict_chain</span><br><span class="line">#</span><br><span class="line"># Strict - Each connection will be done via chained proxies</span><br><span class="line"># all proxies chained in the order as they appear in the list</span><br><span class="line"># all proxies must be online to play in chain</span><br><span class="line"># otherwise EINTR is returned to the app</span><br><span class="line">#</span><br><span class="line">#random_chain</span><br><span class="line">#</span><br><span class="line"># Random - Each connection will be done via random proxy</span><br><span class="line"># (or proxy chain, see  chain_len) from the list.</span><br><span class="line"># this option is good to test your IDS :)</span><br><span class="line"># Make sense only if random_chain</span><br><span class="line">#chain_len = 2</span><br><span class="line"># Quiet mode (no output from library)</span><br><span class="line">#quiet_mode</span><br><span class="line"># Proxy DNS requests - no leak for DNS data</span><br><span class="line">proxy_dns </span><br><span class="line"># Some timeouts in milliseconds</span><br><span class="line">tcp_read_time_out 15000</span><br><span class="line">tcp_connect_time_out 8000</span><br><span class="line"># ProxyList format</span><br><span class="line">#       type  host  port [user pass]</span><br><span class="line">#       (values separated by &#x27;tab&#x27; or &#x27;blank&#x27;)</span><br><span class="line">#</span><br><span class="line">#</span><br><span class="line">#        Examples:</span><br><span class="line">#</span><br><span class="line">#               socks5  192.168.67.78   1080    lamer   secret</span><br><span class="line">#               http    192.168.89.3    8080    justu   hidden</span><br><span class="line">#               socks4  192.168.1.49    1080</span><br><span class="line">#               http    192.168.39.93   8080</span><br><span class="line">#</span><br><span class="line">#</span><br><span class="line">#       proxy types: http, socks4, socks5</span><br><span class="line">#        ( auth types supported: &quot;basic&quot;-http  &quot;user/pass&quot;-socks )</span><br><span class="line">#</span><br><span class="line">[ProxyList]</span><br><span class="line"># add proxy here ...</span><br><span class="line"># meanwile</span><br><span class="line"># defaults set to &quot;tor&quot;</span><br><span class="line">socks4         127.0.0.1 9050</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>Proxychains支持HTTP（HTTP-Connect）、SOCKS4和SOCKS5三种类型的代理，需要注意的是：配置代理服务器只能使用ip地址，不能使用域名，否则会连不上。</p><p>Proxychains支持3种模式： </p><ol><li>动态模式 按照配置的代理顺序连接，不存活的代理服务器会被跳过 </li><li>严格模式     按照配置的代理顺序连接，必须保证所有代理服务器都是存活的，否则会连接失败 </li><li>随机模式     随机选择一台代理服务器连接，也可以使用代理链</li></ol><p>如果不需要代理DNS的话，可以注释掉proxy_dns这行。</p><p>使用的时候在命令行前加上proxychains即可。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">root@ubuntu-pc:~# proxychains telnet [www.baidu.com](http://www.baidu.com) 80 ProxyChains-3.1 ([http://proxychains.sf.net](http://proxychains.sf.net/)) Trying 14.215.177.37… |R-chain|-&lt;&gt;-10.0.0.10:8080-&lt;&gt;&lt;&gt;-14.215.177.37:80-&lt;&gt;&lt;&gt;-OK Connected to [www.a.shifen.com](http://www.a.shifen.com). Escape character is ‘^]’. </span><br><span class="line"></span><br><span class="line">proxychains命令其实是个脚本文件，内容如下：</span><br><span class="line"></span><br><span class="line">\#!/bin/sh</span><br><span class="line"> echo &quot;ProxyChains-3.1 (http://proxychains.sf.net)&quot;</span><br><span class="line"> if [ $# = 0 ] ; then</span><br><span class="line">     echo &quot; usage:&quot;</span><br><span class="line">     echo &quot;     proxychains &lt;prog&gt; [args]&quot;</span><br><span class="line">     exit</span><br><span class="line"> fi</span><br><span class="line"> export LD_PRELOAD=libproxychains.so.3</span><br><span class="line"> exec &quot;$@&quot;</span><br></pre></td></tr></table></figure><p>它的目的是设置LD_PRELOAD环境变量，以便创建的新进程会加载libproxychains.so.3，这个so的作用是Hook Socket函数。因此，也可以在当前shell中执行： </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">export LD_PRELOAD=libproxychains.so.3</span><br></pre></td></tr></table></figure><p>这样之后执行的命令都会使用代理访问。</p><p>不过这个版本有个问题，配置代理后所有的连接都会走代理，包括对回环地址的访问。这并不是我们所期望的，幸好有个版本提供了解决方案。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/rofl0r/proxychains cd proxychains ./configure make make install </span><br></pre></td></tr></table></figure><p>安装后在配置文件中加入：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">localnet 127.0.0.0/255.0.0.0 </span><br></pre></td></tr></table></figure><p>安装后的命令是proxychains4，因此可以和旧版本命令并存。这样对于回环地址就可以绕过代理，使用直连了。</p><p>相对于Proxifier而言，这种方式还是弱了一点，毕竟有时候我们还是需要根据不同的情况使用不同的代理服务器。</p><h2 id="有东西传不到github上去？"><a href="#有东西传不到github上去？" class="headerlink" title="有东西传不到github上去？"></a>有东西传不到github上去？</h2><p>删掉.deploy_git:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- rm -rf .deploy_git/</span><br></pre></td></tr></table></figure><h2 id="语雀防盗链解决办法："><a href="#语雀防盗链解决办法：" class="headerlink" title="语雀防盗链解决办法："></a>语雀防盗链解决办法：</h2><p>临时方案是直接在 html 模版中添加 head 进行绕过</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;referrer&quot;</span> <span class="attr">content</span>=<span class="string">&quot;no-referrer&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure><p> (来自 <a href="https://github.com/x-cold/yuque-hexo/issues/41">https://github.com/x-cold/yuque-hexo/issues/41</a> )</p><p>注：对于butterfly主题的话对themes\Butterfly\layout\includes\layout.pug修改head部分即可，但是会造成网站访客数和文章阅读数无法加载</p><h2 id="gem失败"><a href="#gem失败" class="headerlink" title="gem失败"></a>gem失败</h2><p>apt-get install ruby-dev </p><h2 id="Windows-的-Linux-子系统的文件同步和-Windows-不是实时的问题"><a href="#Windows-的-Linux-子系统的文件同步和-Windows-不是实时的问题" class="headerlink" title="Windows 的 Linux 子系统的文件同步和 Windows 不是实时的问题"></a>Windows 的 Linux 子系统的文件同步和 Windows 不是实时的问题</h2><p>如果使用windows子系统的Ubuntu的话，可能会出现Windows 的 Linux 子系统的文件同步和 Windows 不是实时的问题（来自 <a href="https://www.zhihu.com/question/318832524/answer/641951256">https://www.zhihu.com/question/318832524/answer/641951256</a> ）</p><p>你可以在Windows下存储文件，然后在wsl中使用/mnt/盘符/路径 访问</p><p>你也可以在1903更新发布后在Linux rootfs中存储文件，Windows程序使用\wsl$\Ubuntu\unix路径 访问</p><p>唯独不正确的操作是找到AppData里rootfs文件夹直接用Windows程序修改，因为这里面的文件在NTFS中除了存储文件内容，Windows文件元数据，还存储unix文件元数据（比如rwx权限，unix用户组和用户），你创建的文件并不具有这样的属性，因此会导致权限混乱。</p><p>详见：<a href="https://link.zhihu.com/?target=https%3A//blogs.msdn.microsoft.com/commandline/2016/11/17/do-not-change-linux-files-using-windows-apps-and-tools/">https://blogs.msdn.microsoft.com/commandline/2016/11/17/do-not-change-linux-files-using-windows-apps-and-tools/</a></p><p>1903（19H1，20195月更新）的改动</p><p><strong>Linux Files inside of File Explorer</strong></p><p>The best way to get started with this feature is to open your Linux files in File Explorer! To do this, open your favorite distro, make sure your current folder is your Linux home directory, and type in:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">explorer.exe .</span><br></pre></td></tr></table></figure><p>来自 <a href="https://devblogs.microsoft.com/commandline/whats-new-for-wsl-in-windows-10-version-1903/">https://devblogs.microsoft.com/commandline/whats-new-for-wsl-in-windows-10-version-1903/</a> </p><h2 id="npm淘宝源的问题"><a href="#npm淘宝源的问题" class="headerlink" title="npm淘宝源的问题"></a>npm淘宝源的问题</h2><p>这玩意有毛病，经常会出奇奇怪怪的bug，最好的方式还是挂代理</p><p>C盘用户文件夹下的.npmrc</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">proxy=http://127.0.0.1:1081</span><br><span class="line">https-proxy=http://127.0.0.1:1081/</span><br></pre></td></tr></table></figure><h2 id="github-action错误提示"><a href="#github-action错误提示" class="headerlink" title="github action错误提示"></a>github action错误提示</h2><blockquote><p>How to fix ‘Unsupported platform for fsevents@1.2.9: wanted {“os”:”darwin”,”arch”:”any”} (current: {“os”:”win32”,”arch”:”x64”})</p></blockquote><p>解决办法：</p><ul><li><p>在deploy.yml中添加          </p><p><code>npm i -f</code></p></li></ul><h1 id="参考："><a href="#参考：" class="headerlink" title="参考："></a>参考：</h1><ul><li><p>[语雀+TravisCI+Serverless]: <a href="https://segmentfault.com/a/1190000017797561">https://segmentfault.com/a/1190000017797561</a></p></li><li><p>[【持续更新】最全Hexo博客搭建+主题优化+插件配置+常用操作+错误分析]: <a href="https://www.simon96.online/2018/10/12/hexo-tutorial/">https://www.simon96.online/2018/10/12/hexo-tutorial/</a></p></li><li><p>[使用Travis CI自动部署Hexo博客]: <a href="https://www.itfanr.cc/2017/08/09/using-travis-ci-automatic-deploy-hexo-blogs/">https://www.itfanr.cc/2017/08/09/using-travis-ci-automatic-deploy-hexo-blogs/</a></p></li><li><p>[hexo-theme-butterfly安裝文檔]: <a href="https://jerryc.me/posts/21cfbf15/">https://jerryc.me/posts/21cfbf15/</a></p></li><li><p>[Hexo 博客终极玩法：云端写作，自动部署]: <a href="https://segmentfault.com/a/1190000017797561">https://segmentfault.com/a/1190000017797561</a></p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 博客 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hexo </tag>
            
            <tag> travis CI </tag>
            
            <tag> serverless </tag>
            
            <tag> 语雀 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
